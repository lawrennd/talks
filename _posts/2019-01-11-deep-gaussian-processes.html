---
title: "Deep Gaussian Processes"
venue: "MLSS, Stellenbosch, South Africa"
abstract: "<p>Classical machine learning and statistical approaches to learning, such as neural networks and linear regression, assume a parametric form for functions. Gaussian process models are an alternative approach that assumes a probabilistic prior over functions. This brings benefits, in that uncertainty of function estimation is sustained throughout inference, and some challenges: algorithms for fitting Gaussian processes tend to be more complex than parametric models. In these sessions I will introduce Gaussian processes and explain why sustaining uncertainty is important. We’ll then look at some extensions of Gaussian process models, in particular composition of Gaussian processes, or deep Gaussian processes.</p>"
author:
- given: Neil D.
  family: Lawrence
  url: http://inverseprobability.com
  institute: Amazon Cambridge and University of Sheffield
  twitter: lawrennd
  gscholar: r3SJcvoAAAAJ
  orchid: 
date: 2019-01-11
published: 2019-01-11
reveal: 2019-01-11-deep-gaussian-processes.slides.html
layout: talk
categories:
- notes
---


<div style="display:none">
  $${% include talk-notation.tex %}$$
</div>

<!-- Enables links to pages-->
<p><!--% not ipynb--></p>
<div style="text-align:center">
<img class="" src="../slides/diagrams/sparse-gps.jpg.jpg" width="45%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</div>
<center>
<em>Image credit: Kai Arulkumaran </em>
</center>
<h3 id="a-simple-regression-problem">A Simple Regression Problem</h3>
<p>Here we set up a simple one dimensional regression problem. The input locations, <span class="math inline">$\inputMatrix$</span>, are in two separate clusters. The response variable, <span class="math inline">$\dataVector$</span>, is sampled from a Gaussian process with an exponentiated quadratic covariance.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> GPy</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.random.seed(<span class="dv">101</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">N <span class="op">=</span> <span class="dv">50</span>
noise_var <span class="op">=</span> <span class="fl">0.01</span>
X <span class="op">=</span> np.zeros((<span class="dv">50</span>, <span class="dv">1</span>))
X[:<span class="dv">25</span>, :] <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">25</span>)[:,<span class="va">None</span>] <span class="co"># First cluster of inputs/covariates</span>
X[<span class="dv">25</span>:, :] <span class="op">=</span> np.linspace(<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">25</span>)[:,<span class="va">None</span>] <span class="co"># Second cluster of inputs/covariates</span>

<span class="co"># Sample response variables from a Gaussian process with exponentiated quadratic covariance.</span>
k <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>)
y <span class="op">=</span> np.random.multivariate_normal(np.zeros(N),k.K(X)<span class="op">+</span>np.eye(N)<span class="op">*</span>np.sqrt(noise_var)).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</code></pre></div>
<p>First we perform a full Gaussian process regression on the data. We create a GP model, <code>m_full</code>, and fit it to the data, plotting the resulting fit.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m_full <span class="op">=</span> GPy.models.GPRegression(X,y)
_ <span class="op">=</span> m_full.optimize(messages<span class="op">=</span><span class="va">True</span>) <span class="co"># Optimize parameters of covariance function</span></code></pre></div>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-full-gp.svg" style>
</object>
<center>
<em>Full Gaussian process fitted to the data set. </em>
</center>
<p>Now we set up the inducing variables, <span class="math inline"><strong>u</strong></span>. Each inducing variable has its own associated input index, <span class="math inline"><strong>Z</strong></span>, which lives in the same space as <span class="math inline">$\inputMatrix$</span>. Here we are using the true covariance function parameters to generate the fit.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>)
Z <span class="op">=</span> np.hstack(
        (np.linspace(<span class="fl">2.5</span>,<span class="dv">4</span>.,<span class="dv">3</span>),
        np.linspace(<span class="dv">7</span>,<span class="fl">8.5</span>,<span class="dv">3</span>)))[:,<span class="va">None</span>]
m <span class="op">=</span> GPy.models.SparseGPRegression(X,y,kernel<span class="op">=</span>kern,Z<span class="op">=</span>Z)
m.noise_var <span class="op">=</span> noise_var
m.inducing_inputs.constrain_fixed()
display(m)</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-constrained-inducing-6-unlearned-gp.svg" style>
</object>
<center>
<em>Sparse Gaussian process fitted with six inducing variables, no optimization of parameters or inducing variables. </em>
</center>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)
display(m)</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-constrained-inducing-6-learned-gp.svg" style>
</object>
<center>
<em>Gaussian process fitted with inducing variables fixed and parameters optimized </em>
</center>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.randomize()
m.inducing_inputs.unconstrain()
_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-unconstrained-inducing-6-gp.svg" style>
</object>
<center>
<em>Gaussian process fitted with location of inducing variables and parameters both optimized </em>
</center>
<p>Now we will vary the number of inducing points used to form the approximation.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.num_inducing<span class="op">=</span><span class="dv">8</span>
m.randomize()
M <span class="op">=</span> <span class="dv">8</span>
m.set_Z(np.random.rand(M,<span class="dv">1</span>)<span class="op">*</span><span class="dv">12</span>)

_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-sparse-inducing-8-gp.svg" style>
</object>
<object class="svgplot " align data="../slides/diagrams/gp/sparse-demo-full-gp.svg" style>
</object>
<center>
<em>Comparison of the full Gaussian process fit with a sparse Gaussian process using eight inducing varibles. Both inducing variables and parameters are optimized. </em>
</center>
<p>And we can compare the probability of the result to the full model.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(m.log_likelihood(), m_full.log_likelihood())</code></pre></div>
<ul>
<li><p><em>A Unifying Framework for Gaussian Process Pseudo-Point Approximations using Power Expectation Propagation</em> <span class="citation">Bui, Yan, and Turner (2017)</span></p></li>
<li><p><em>Deep Gaussian Processes and Variational Propagation of Uncertainty</em> <span class="citation">A. Damianou (2015)</span></p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/deepgp/deep-nn2.svg" style>
</object>
<center>
<em>A deep neural network. Input nodes are shown at the bottom. Each hidden layer is the result of applying an affine transformation to the previous layer and placing through an activation function. </em>
</center>
<p>Mathematically, each layer of a neural network is given through computing the activation function, <span class="math inline">$\basisFunction(\cdot)$</span>, contingent on the previous layer, or the inputs. In this way the activation functions, are composed to generate more complex interactions than would be possible with any single layer. <br /><span class="math display">$$
\begin{align}
    \hiddenVector_{1} &amp;= \basisFunction\left(\mappingMatrix_1 \inputVector\right)\\
    \hiddenVector_{2} &amp;=  \basisFunction\left(\mappingMatrix_2\hiddenVector_{1}\right)\\
    \hiddenVector_{3} &amp;= \basisFunction\left(\mappingMatrix_3 \hiddenVector_{2}\right)\\
    \dataVector &amp;= \mappingVector_4 ^\top\hiddenVector_{3}
\end{align}
$$</span><br /></p>
<h3 id="overfitting">Overfitting</h3>
<p>One potential problem is that as the number of nodes in two adjacent layers increases, the number of parameters in the affine transformation between layers, <span class="math inline">$\mappingMatrix$</span>, increases. If there are <span class="math inline"><em>k</em><sub><em>i</em> − 1</sub></span> nodes in one layer, and <span class="math inline"><em>k</em><sub><em>i</em></sub></span> nodes in the following, then that matrix contains <span class="math inline"><em>k</em><sub><em>i</em></sub><em>k</em><sub><em>i</em> − 1</sub></span> parameters, when we have layer widths in the 1000s that leads to millions of parameters.</p>
<p>One proposed solution is known as <em>dropout</em> where only a sub-set of the neural network is trained at each iteration. An alternative solution would be to reparameterize <span class="math inline">$\mappingMatrix$</span> with its <em>singular value decomposition</em>. <br /><span class="math display">$$
  \mappingMatrix = \eigenvectorMatrix\eigenvalueMatrix\eigenvectwoMatrix^\top
  $$</span><br /> or <br /><span class="math display">$$
  \mappingMatrix = \eigenvectorMatrix\eigenvectwoMatrix^\top
  $$</span><br /> where if <span class="math inline">$\mappingMatrix \in \Re^{k_1\times k_2}$</span> then <span class="math inline">$\eigenvectorMatrix\in \Re^{k_1\times q}$</span> and <span class="math inline">$\eigenvectwoMatrix \in \Re^{k_2\times q}$</span>, i.e. we have a low rank matrix factorization for the weights.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/wisuvt.svg" style>
</object>
<center>
<em>Pictorial representation of the low rank form of the matrix <span class="math inline">$\mappingMatrix$</span> </em>
</center>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/deepgp/deep-nn-bottleneck2.svg" style>
</object>
<p>Including the low rank decomposition of <span class="math inline">$\mappingMatrix$</span> in the neural network, we obtain a new mathematical form. Effectively, we are adding additional <em>latent</em> layers, <span class="math inline">$\latentVector$</span>, in between each of the existing hidden layers. In a neural network these are sometimes known as <em>bottleneck</em> layers. The network can now be written mathematically as <br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \eigenvectwoMatrix^\top_1 \inputVector\\
  \hiddenVector_{1} &amp;= \basisFunction\left(\eigenvectorMatrix_1 \latentVector_{1}\right)\\
  \latentVector_{2} &amp;= \eigenvectwoMatrix^\top_2 \hiddenVector_{1}\\
  \hiddenVector_{2} &amp;= \basisFunction\left(\eigenvectorMatrix_2 \latentVector_{2}\right)\\
  \latentVector_{3} &amp;= \eigenvectwoMatrix^\top_3 \hiddenVector_{2}\\
  \hiddenVector_{3} &amp;= \basisFunction\left(\eigenvectorMatrix_3 \latentVector_{3}\right)\\
  \dataVector &amp;= \mappingVector_4^\top\hiddenVector_{3}.
\end{align}
$$</span><br /></p>
<h3 id="a-cascade-of-neural-networks">A Cascade of Neural Networks</h3>
<p><br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \eigenvectwoMatrix^\top_1 \inputVector\\
  \latentVector_{2} &amp;= \eigenvectwoMatrix^\top_2 \basisFunction\left(\eigenvectorMatrix_1 \latentVector_{1}\right)\\
  \latentVector_{3} &amp;= \eigenvectwoMatrix^\top_3 \basisFunction\left(\eigenvectorMatrix_2 \latentVector_{2}\right)\\
  \dataVector &amp;= \mappingVector_4 ^\top \latentVector_{3}
\end{align}
$$</span><br /></p>
<h3 id="cascade-of-gaussian-processes">Cascade of Gaussian Processes</h3>
<ul>
<li><p>Replace each neural network with a Gaussian process <br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \mappingFunctionVector_1\left(\inputVector\right)\\
  \latentVector_{2} &amp;= \mappingFunctionVector_2\left(\latentVector_{1}\right)\\
  \latentVector_{3} &amp;= \mappingFunctionVector_3\left(\latentVector_{2}\right)\\
  \dataVector &amp;= \mappingFunctionVector_4\left(\latentVector_{3}\right)
\end{align}
$$</span><br /></p></li>
<li><p>Equivalent to prior over parameters, take width of each layer to infinity.</p></li>
</ul>
<p>Mathematically, a deep Gaussian process can be seen as a composite <em>multivariate</em> function, <br /><span class="math display">$$
  \mathbf{g}(\inputVector)=\mappingFunctionVector_5(\mappingFunctionVector_4(\mappingFunctionVector_3(\mappingFunctionVector_2(\mappingFunctionVector_1(\inputVector))))).
  $$</span><br /> Or if we view it from the probabilistic perspective we can see that a deep Gaussian process is specifying a factorization of the joint density, the standard deep model takes the form of a Markov chain.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> matplotlib <span class="im">import</span> rc

rc(<span class="st">&quot;font&quot;</span>, <span class="op">**</span>{<span class="st">&#39;family&#39;</span>:<span class="st">&#39;sans-serif&#39;</span>,<span class="st">&#39;sans-serif&#39;</span>:[<span class="st">&#39;Helvetica&#39;</span>],<span class="st">&#39;size&#39;</span>:<span class="dv">30</span>})
rc(<span class="st">&quot;text&quot;</span>, usetex<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p><br /><span class="math display">$$
  p(\dataVector|\inputVector)= p(\dataVector|\mappingFunctionVector_5)p(\mappingFunctionVector_5|\mappingFunctionVector_4)p(\mappingFunctionVector_4|\mappingFunctionVector_3)p(\mappingFunctionVector_3|\mappingFunctionVector_2)p(\mappingFunctionVector_2|\mappingFunctionVector_1)p(\mappingFunctionVector_1|\inputVector)
  $$</span><br /></p>
<object class="svgplot " align data="../slides/diagrams/deepgp/deep-markov.svg" style>
</object>
<center>
<em>Probabilistically the deep Gaussian process can be represented as a Markov chain. </em>
</center>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> matplotlib <span class="im">import</span> rc
rc(<span class="st">&quot;font&quot;</span>, <span class="op">**</span>{<span class="st">&#39;family&#39;</span>:<span class="st">&#39;sans-serif&#39;</span>,<span class="st">&#39;sans-serif&#39;</span>:[<span class="st">&#39;Helvetica&#39;</span>], <span class="st">&#39;size&#39;</span>:<span class="dv">15</span>})
rc(<span class="st">&quot;text&quot;</span>, usetex<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<object class="svgplot " align data="../slides/diagrams/deepgp/deep-markov-vertical.svg" style>
</object>
<h3 id="why-deep">Why Deep?</h3>
<p>If the result of composing many functions together is simply another function, then why do we bother? The key point is that we can change the class of functions we are modeling by composing in this manner. A Gaussian process is specifying a prior over functions, and one with a number of elegant properties. For example, the derivative process (if it exists) of a Gaussian process is also Gaussian distributed. That makes it easy to assimilate, for example, derivative observations. But that also might raise some alarm bells. That implies that the <em>marginal derivative distribution</em> is also Gaussian distributed. If that's the case, then it means that functions which occasionally exhibit very large derivatives are hard to model with a Gaussian process. For example, a function with jumps in.</p>
<p>A one off discontinuity is easy to model with a Gaussian process, or even multiple discontinuities. They can be introduced in the mean function, or independence can be forced between two covariance functions that apply in different areas of the input space. But in these cases we will need to specify the number of discontinuities and where they occur. In otherwords we need to <em>parameterise</em> the discontinuities. If we do not know the number of discontinuities and don't wish to specify where they occur, i.e. if we want a non-parametric representation of discontinuities, then the standard Gaussian process doesn't help.</p>
<h3 id="stochastic-process-composition">Stochastic Process Composition</h3>
<p>The deep Gaussian process leads to <em>non-Gaussian</em> models, and non-Gaussian characteristics in the covariance function. In effect, what we are proposing is that we change the properties of the functions we are considering by *composing stochastic processes$. This is an approach to creating new stochastic processes from well known processes.</p>
<object class="svgplot " align data="../slides/diagrams/deepgp/deep-markov-vertical.svg" style>
</object>
<p>Additionally, we are not constrained to the formalism of the chain. For example, we can easily add single nodes emerging from some point in the depth of the chain. This allows us to combine the benefits of the graphical modelling formalism, but with a powerful framework for relating one set of variables to another, that of Gaussian processes <object class="svgplot " align="" data="../slides/diagrams/deepgp/deep-markov-vertical-side.svg" style=""></object></p>
<h3 id="difficulty-for-probabilistic-approaches" data-transition="None">Difficulty for Probabilistic Approaches</h3>
<ul>
<li><p>Propagate a probability distribution through a non-linear mapping.</p></li>
<li><p>Normalisation of distribution becomes intractable.</p></li>
</ul>
<object class="svgplot " align="center" data="../slides/diagrams/dimred/nonlinear-mapping-3d-plot.svg" style>
</object>
<h3 id="difficulty-for-probabilistic-approaches-1" data-transition="None">Difficulty for Probabilistic Approaches</h3>
<ul>
<li><p>Propagate a probability distribution through a non-linear mapping.</p></li>
<li><p>Normalisation of distribution becomes intractable.</p></li>
</ul>
<object class="svgplot " align="center" data="../slides/diagrams/dimred/nonlinear-mapping-2d-plot.svg" style>
</object>
<h3 id="difficulty-for-probabilistic-approaches-2" data-transition="None">Difficulty for Probabilistic Approaches</h3>
<ul>
<li><p>Propagate a probability distribution through a non-linear mapping.</p></li>
<li><p>Normalisation of distribution becomes intractable.</p></li>
</ul>
<object class="svgplot " align="center" data="../slides/diagrams/dimred/gaussian-through-nonlinear.svg" style>
</object>
<h3 id="deep-gaussian-processes">Deep Gaussian Processes</h3>
<ul>
<li><p>Deep architectures allow abstraction of features <span class="citation">(Bengio 2009; Hinton and Osindero 2006; Salakhutdinov and Murray, n.d.)</span></p></li>
<li><p>We use variational approach to stack GP models.</p></li>
</ul>
<h3 id="stacked-pca">Stacked PCA</h3>
<object class="svgplot " align data="../slides/diagrams/stack-pca-sample-4.svg" style>
</object>
<h3 id="stacked-gp">Stacked GP</h3>
<object class="svgplot " align data="../slides/diagrams/stack-gp-sample-4.svg" style>
</object>
<h3 id="analysis-of-deep-gps">Analysis of Deep GPs</h3>
<ul>
<li><p><em>Avoiding pathologies in very deep networks</em> <span class="citation">Duvenaud et al. (2014)</span> show that the derivative distribution of the process becomes more <em>heavy tailed</em> as number of layers increase.</p></li>
<li><p><em>How Deep Are Deep Gaussian Processes?</em> <span class="citation">Dunlop et al. (n.d.)</span> perform a theoretical analysis possible through conditional Gaussian Markov property.</p></li>
</ul>
<p><a href="https://www.youtube.com/watch?v=XhIvygQYFFQ&amp;t="><img src="https://img.youtube.com/vi/XhIvygQYFFQ/0.jpg" /></a></p>
<h3 id="olympic-marathon-data">Olympic Marathon Data</h3>
<table>
<tr>
<td width="70%">
<ul>
<li><p>Gold medal times for Olympic Marathon since 1896.</p></li>
<li><p>Marathons before 1924 didn’t have a standardised distance.</p></li>
<li><p>Present results using pace per km.</p></li>
<li>In 1904 Marathon was badly organised leading to very slow times.</li>
</ul>
</td>
<td width="30%">
<div style="text-align:center">
<img class="" src="../slides/diagrams/Stephen_Kiprotich.jpg" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</div>
<small>Image from Wikimedia Commons <a href="http://bit.ly/16kMKHQ" class="uri">http://bit.ly/16kMKHQ</a></small>
</td>
</tr>
</table>
<p>The first thing we will do is load a standard data set for regression modelling. The data consists of the pace of Olympic Gold Medal Marathon winners for the Olympics from 1896 to present. First we load in the data and plot.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> pods</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data <span class="op">=</span> pods.datasets.olympic_marathon_men()
x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]
y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]

offset <span class="op">=</span> y.mean()
scale <span class="op">=</span> np.sqrt(y.var())</code></pre></div>
<div style="text-align:center">
<object class="svgplot " align data="../slides/diagrams/datasets/olympic-marathon.svg" style>
</object>
</div>
<p>Things to notice about the data include the outlier in 1904, in this year, the olympics was in St Louis, USA. Organizational problems and challenges with dust kicked up by the cars following the race meant that participants got lost, and only very few participants completed.</p>
<p>More recent years see more consistently quick marathons.</p>
<p>Our first objective will be to perform a Gaussian process fit to the data, we'll do this using the <a href="https://github.com/SheffieldML/GPy">GPy software</a>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> GPy</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)
_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></code></pre></div>
<p>The first command sets up the model, then</p>
<pre><code>m_full.optimize()</code></pre>
<p>optimizes the parameters of the covariance function and the noise level of the model. Once the fit is complete, we'll try creating some test points, and computing the output of the GP model in terms of the mean and standard deviation of the posterior functions between 1870 and 2030. We plot the mean function and the standard deviation at 200 locations. We can obtain the predictions using</p>
<pre><code>y_mean, y_var = m_full.predict(xt)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">xt <span class="op">=</span> np.linspace(<span class="dv">1870</span>,<span class="dv">2030</span>,<span class="dv">200</span>)[:,np.newaxis]
yt_mean, yt_var <span class="op">=</span> m_full.predict(xt)
yt_sd<span class="op">=</span>np.sqrt(yt_var)</code></pre></div>
<p>Now we plot the results using the helper function in <code>teaching_plots</code>.</p>
<object class="svgplot " align data="../slides/diagrams/gp/olympic-marathon-gp.svg" style>
</object>
<h3 id="fit-quality">Fit Quality</h3>
<p>In the fit we see that the error bars (coming mainly from the noise variance) are quite large. This is likely due to the outlier point in 1904, ignoring that point we can see that a tighter fit is obtained. To see this making a version of the model, <code>m_clean</code>, where that point is removed.</p>
<pre><code>x_clean=np.vstack((x[0:2, :], x[3:, :]))
y_clean=np.vstack((y[0:2, :], y[3:, :]))

m_clean = GPy.models.GPRegression(x_clean,y_clean)
_ = m_clean.optimize()</code></pre>
<p>Data is fine for answering very specific questions, like &quot;Who won the Olympic Marathon in 2012?&quot;, because we have that answer stored, however, we are not given the answer to many other questions. For example, Alan Turing was a formidable marathon runner, in 1946 he ran a time 2 hours 46 minutes (just under four minutes per kilometer, faster than I and most of the other <a href="http://www.parkrun.org.uk/sheffieldhallam/">Endcliffe Park Run</a> runners can do 5 km). What is the probability he would have won an Olympics if one had been held in 1946?</p>
<table>
<tr>
<td width="40%">
<img class="" src="../slides/diagrams/turing-run.jpg" width="" height="auto" align="" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</td>
<td width="50%">
<img class="" src="../slides/diagrams/turing-times.gif" width="" height="auto" align="" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</td>
</tr>
</table>
<center>
<em>Alan Turing, in 1946 he was only 11 minutes slower than the winner of the 1948 games. Would he have won a hypothetical games held in 1946? Source: <a href="http://www.turing.org.uk/scrapbook/run.html">Alan Turing Internet Scrapbook</a> </em>
</center>
<h3 id="deep-gp-fit">Deep GP Fit</h3>
<p>Let's see if a deep Gaussian process can help here. We will construct a deep Gaussian process with one hidden layer (i.e. one Gaussian process feeding into another).</p>
<p>Build a Deep GP with an additional hidden layer (one dimensional) to fit the model.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> GPy
<span class="im">import</span> deepgp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">hidden <span class="op">=</span> <span class="dv">1</span>
m <span class="op">=</span> deepgp.DeepGP([y.shape[<span class="dv">1</span>],hidden,x.shape[<span class="dv">1</span>]],Y<span class="op">=</span>yhat, X<span class="op">=</span>x, inits<span class="op">=</span>[<span class="st">&#39;PCA&#39;</span>,<span class="st">&#39;PCA&#39;</span>], 
                  kernels<span class="op">=</span>[GPy.kern.RBF(hidden,ARD<span class="op">=</span><span class="va">True</span>),
                           GPy.kern.RBF(x.shape[<span class="dv">1</span>],ARD<span class="op">=</span><span class="va">True</span>)], <span class="co"># the kernels for each layer</span>
                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<p>Deep Gaussian process models also can require some thought in initialization. Here we choose to start by setting the noise variance to be one percent of the data variance.</p>
<p>Optimization requires moving variational parameters in the hidden layer representing the mean and variance of the expected values in that layer. Since all those values can be scaled up, and this only results in a downscaling in the output of the first GP, and a downscaling of the input length scale to the second GP. It makes sense to first of all fix the scales of the covariance function in each of the GPs.</p>
<p>Sometimes, deep Gaussian processes can find a local minima which involves increasing the noise level of one or more of the GPs. This often occurs because it allows a minimum in the KL divergence term in the lower bound on the likelihood. To avoid this minimum we habitually train with the likelihood variance (the noise on the output of the GP) fixed to some lower value for some iterations.</p>
<p>Let's create a helper function to initialize the models we use in the notebook.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> GPy
<span class="im">import</span> deepgp</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> initialize(<span class="va">self</span>, noise_factor<span class="op">=</span><span class="fl">0.01</span>, linear_factor<span class="op">=</span><span class="dv">1</span>):
    <span class="co">&quot;&quot;&quot;Helper function for deep model initialization.&quot;&quot;&quot;</span>
    <span class="va">self</span>.obslayer.likelihood.variance <span class="op">=</span> <span class="va">self</span>.Y.var()<span class="op">*</span>noise_factor
    <span class="cf">for</span> layer <span class="kw">in</span> <span class="va">self</span>.layers:
        <span class="cf">if</span> <span class="bu">type</span>(layer.X) <span class="kw">is</span> GPy.core.parameterization.variational.NormalPosterior:
            <span class="cf">if</span> layer.kern.ARD:
                var <span class="op">=</span> layer.X.mean.var(<span class="dv">0</span>)
            <span class="cf">else</span>:
                var <span class="op">=</span> layer.X.mean.var()
        <span class="cf">else</span>:
            <span class="cf">if</span> layer.kern.ARD:
                var <span class="op">=</span> layer.X.var(<span class="dv">0</span>)
            <span class="cf">else</span>:
                var <span class="op">=</span> layer.X.var()

        <span class="co"># Average 0.5 upcrossings in four standard deviations. </span>
        layer.kern.lengthscale <span class="op">=</span> linear_factor<span class="op">*</span>np.sqrt(layer.kern.input_dim)<span class="op">*</span><span class="dv">2</span><span class="op">*</span><span class="dv">4</span><span class="op">*</span>np.sqrt(var)<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.pi)
<span class="co"># Bind the new method to the Deep GP object.</span>
deepgp.DeepGP.initialize<span class="op">=</span>initialize</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Call the initalization</span>
m.initialize()</code></pre></div>
<p>Now optimize the model. The first stage of optimization is working on variational parameters and lengthscales only.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</code></pre></div>
<p>Now we remove the constraints on the scale of the covariance functions associated with each GP and optimize again.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:
    <span class="cf">pass</span> <span class="co">#layer.kern.variance.constrain_positive(warning=False)</span>
m.obslayer.kern.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</code></pre></div>
<p>Finally, we allow the noise variance to change and optimize for a large number of iterations.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:
    layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
m.optimize(messages<span class="op">=</span><span class="va">True</span>,max_iters<span class="op">=</span><span class="dv">10000</span>)</code></pre></div>
<p>For our optimization process we define a new function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> staged_optimize(<span class="va">self</span>, iters<span class="op">=</span>(<span class="dv">1000</span>,<span class="dv">1000</span>,<span class="dv">10000</span>), messages<span class="op">=</span>(<span class="va">False</span>, <span class="va">False</span>, <span class="va">True</span>)):
    <span class="co">&quot;&quot;&quot;Optimize with parameters constrained and then with parameters released&quot;&quot;&quot;</span>
    <span class="cf">for</span> layer <span class="kw">in</span> <span class="va">self</span>.layers:
        <span class="co"># Fix the scale of each of the covariance functions.</span>
        layer.kern.variance.fix(warning<span class="op">=</span><span class="va">False</span>)
        layer.kern.lengthscale.fix(warning<span class="op">=</span><span class="va">False</span>)

        <span class="co"># Fix the variance of the noise in each layer.</span>
        layer.likelihood.variance.fix(warning<span class="op">=</span><span class="va">False</span>)

    <span class="va">self</span>.optimize(messages<span class="op">=</span>messages[<span class="dv">0</span>],max_iters<span class="op">=</span>iters[<span class="dv">0</span>])
    
    <span class="cf">for</span> layer <span class="kw">in</span> <span class="va">self</span>.layers:
        layer.kern.lengthscale.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
    <span class="va">self</span>.obslayer.kern.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)


    <span class="va">self</span>.optimize(messages<span class="op">=</span>messages[<span class="dv">1</span>],max_iters<span class="op">=</span>iters[<span class="dv">1</span>])

    <span class="cf">for</span> layer <span class="kw">in</span> <span class="va">self</span>.layers:
        layer.kern.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
        layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
    <span class="va">self</span>.optimize(messages<span class="op">=</span>messages[<span class="dv">2</span>],max_iters<span class="op">=</span>iters[<span class="dv">2</span>])
    
<span class="co"># Bind the new method to the Deep GP object.</span>
deepgp.DeepGP.staged_optimize<span class="op">=</span>staged_optimize</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.staged_optimize(messages<span class="op">=</span>(<span class="va">True</span>,<span class="va">True</span>,<span class="va">True</span>))</code></pre></div>
<h3 id="plot-the-prediction">Plot the prediction</h3>
<p>The prediction of the deep GP can be extracted in a similar way to the normal GP. Although, in this case, it is an approximation to the true distribution, because the true distribution is not Gaussian.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)
plot.model_output(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;year&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;pace min/km&#39;</span>, 
          fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)
ax.set_xlim(xlim)

ax.set_ylim(ylim)
mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/olympic-marathon-deep-gp.svg&#39;</span>, 
                transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<h3 id="olympic-marathon-data-deep-gp">Olympic Marathon Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/olympic-marathon-deep-gp.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> posterior_sample(<span class="va">self</span>, X, <span class="op">**</span>kwargs):
    <span class="co">&quot;&quot;&quot;Give a sample from the posterior of the deep GP.&quot;&quot;&quot;</span>
    Z <span class="op">=</span> X
    <span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">reversed</span>(<span class="va">self</span>.layers)):
        Z <span class="op">=</span> layer.posterior_samples(Z, size<span class="op">=</span><span class="dv">1</span>, <span class="op">**</span>kwargs)[:, :, <span class="dv">0</span>]
 
    <span class="cf">return</span> Z
deepgp.DeepGP.posterior_sample <span class="op">=</span> posterior_sample</code></pre></div>
<h3 id="olympic-marathon-data-deep-gp-1" data-transition="None">Olympic Marathon Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-samples.svg" style>
</object>
<h3 id="fitted-gp-for-each-layer">Fitted GP for each layer</h3>
<p>Now we explore the GPs the model has used to fit each layer. First of all, we look at the hidden layer.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> visualize(<span class="va">self</span>, scale<span class="op">=</span><span class="fl">1.0</span>, offset<span class="op">=</span><span class="fl">0.0</span>, xlabel<span class="op">=</span><span class="st">&#39;input&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;output&#39;</span>, 
              xlim<span class="op">=</span><span class="va">None</span>, ylim<span class="op">=</span><span class="va">None</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>,dataset<span class="op">=</span><span class="va">None</span>, 
              diagrams<span class="op">=</span><span class="st">&#39;../diagrams&#39;</span>):
    <span class="co">&quot;&quot;&quot;Visualize the layers in a deep GP with one-d input and output.&quot;&quot;&quot;</span>
    depth <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.layers)
    <span class="cf">if</span> dataset <span class="kw">is</span> <span class="va">None</span>:
        fname <span class="op">=</span> <span class="st">&#39;deep-gp-layer&#39;</span>
    <span class="cf">else</span>:
        fname <span class="op">=</span> dataset <span class="op">+</span> <span class="st">&#39;-deep-gp-layer&#39;</span>
    filename <span class="op">=</span> os.path.join(diagrams, fname)
    last_name <span class="op">=</span> xlabel
    last_x <span class="op">=</span> <span class="va">self</span>.X
    <span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">reversed</span>(<span class="va">self</span>.layers)):
        <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">0</span>:
            plt.plot(last_x, layer.X.mean, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)
            last_x<span class="op">=</span>layer.X.mean
            ax<span class="op">=</span>plt.gca()
            name <span class="op">=</span> <span class="st">&#39;layer &#39;</span> <span class="op">+</span> <span class="bu">str</span>(i)
            plt.xlabel(last_name, fontsize<span class="op">=</span>fontsize)
            plt.ylabel(name, fontsize<span class="op">=</span>fontsize)
            last_name<span class="op">=</span>name
            mlai.write_figure(filename<span class="op">=</span>filename <span class="op">+</span> <span class="st">&#39;-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(i<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, 
                              transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)
            
        <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span> <span class="kw">and</span> xlim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
            xt <span class="op">=</span> plot.pred_range(np.array(xlim), portion<span class="op">=</span><span class="fl">0.0</span>)
        <span class="cf">elif</span> i<span class="op">&gt;</span><span class="dv">0</span>:
            xt <span class="op">=</span> plot.pred_range(np.array(next_lim), portion<span class="op">=</span><span class="fl">0.0</span>)
        <span class="cf">else</span>:
            xt <span class="op">=</span> plot.pred_range(last_x, portion<span class="op">=</span>portion)
        yt_mean, yt_var <span class="op">=</span> layer.predict(xt)
        <span class="cf">if</span> layer<span class="op">==</span><span class="va">self</span>.obslayer:
            yt_mean <span class="op">=</span> yt_mean<span class="op">*</span>scale <span class="op">+</span> offset
            yt_var <span class="op">*=</span> scale<span class="op">*</span>scale
        yt_sd <span class="op">=</span> np.sqrt(yt_var)
        gpplot(xt,yt_mean,yt_mean<span class="op">-</span><span class="dv">2</span><span class="op">*</span>yt_sd,yt_mean<span class="op">+</span><span class="dv">2</span><span class="op">*</span>yt_sd)
        ax <span class="op">=</span> plt.gca()
        <span class="cf">if</span> i<span class="op">&gt;</span><span class="dv">0</span>:
            ax.set_xlim(next_lim)
        <span class="cf">elif</span> xlim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
            ax.set_xlim(xlim)
        next_lim <span class="op">=</span> plt.gca().get_ylim()
        
    plt.plot(last_x, <span class="va">self</span>.Y<span class="op">*</span>scale <span class="op">+</span> offset, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)
    plt.xlabel(last_name, fontsize<span class="op">=</span>fontsize)
    plt.ylabel(ylabel, fontsize<span class="op">=</span>fontsize)
    mlai.write_figure(filename<span class="op">=</span>filename <span class="op">+</span> <span class="st">&#39;-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(i) <span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, 
                      transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)

    <span class="cf">if</span> ylim <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
        ax<span class="op">=</span>plt.gca()
        ax.set_ylim(ylim)

<span class="co"># Bind the new method to the Deep GP object.</span>
deepgp.DeepGP.visualize<span class="op">=</span>visualize</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> scale_data(x, portion):     
    scale <span class="op">=</span> (x.<span class="bu">max</span>()<span class="op">-</span>x.<span class="bu">min</span>())<span class="op">/</span>(<span class="dv">1</span><span class="op">-</span><span class="dv">2</span><span class="op">*</span>portion)
    offset <span class="op">=</span> x.<span class="bu">min</span>() <span class="op">-</span> portion<span class="op">*</span>scale
    <span class="cf">return</span> (x<span class="op">-</span>offset)<span class="op">/</span>scale, scale, offset</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> visualize_pinball(<span class="va">self</span>, ax<span class="op">=</span><span class="va">None</span>, scale<span class="op">=</span><span class="fl">1.0</span>, offset<span class="op">=</span><span class="fl">0.0</span>, xlabel<span class="op">=</span><span class="st">&#39;input&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;output&#39;</span>, 
                  xlim<span class="op">=</span><span class="va">None</span>, ylim<span class="op">=</span><span class="va">None</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>, points<span class="op">=</span><span class="dv">50</span>, vertical<span class="op">=</span><span class="va">True</span>):
    <span class="co">&quot;&quot;&quot;Visualize the layers in a deep GP with one-d input and output.&quot;&quot;&quot;</span>

    <span class="cf">if</span> ax <span class="kw">is</span> <span class="va">None</span>:
        fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)

    depth <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.layers)

    last_name <span class="op">=</span> xlabel
    last_x <span class="op">=</span> <span class="va">self</span>.X

    <span class="co"># Recover input and output scales from output plot</span>
    plot_model_output(<span class="va">self</span>, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, 
                      xlabel<span class="op">=</span>xlabel, ylabel<span class="op">=</span>ylabel, 
                      fontsize<span class="op">=</span>fontsize, portion<span class="op">=</span>portion)
    xlim<span class="op">=</span>ax.get_xlim()
    xticks<span class="op">=</span>ax.get_xticks()
    xtick_labels<span class="op">=</span>ax.get_xticklabels().copy()
    ylim<span class="op">=</span>ax.get_ylim()
    yticks<span class="op">=</span>ax.get_yticks()
    ytick_labels<span class="op">=</span>ax.get_yticklabels().copy()

    <span class="co"># Clear axes and start again</span>
    ax.cla()
    <span class="cf">if</span> vertical:
        ax.set_xlim((<span class="dv">0</span>, <span class="dv">1</span>))
        ax.invert_yaxis()

        ax.set_ylim((depth, <span class="dv">0</span>))
    <span class="cf">else</span>:
        ax.set_ylim((<span class="dv">0</span>, <span class="dv">1</span>))
        ax.set_xlim((<span class="dv">0</span>, depth))
        
    ax.set_axis_off()<span class="co">#frame_on(False)</span>


    <span class="kw">def</span> pinball(x, y, y_std, color_scale<span class="op">=</span><span class="va">None</span>, 
                layer<span class="op">=</span><span class="dv">0</span>, depth<span class="op">=</span><span class="dv">1</span>, ax<span class="op">=</span><span class="va">None</span>, 
                alpha<span class="op">=</span><span class="fl">1.0</span>, portion<span class="op">=</span><span class="fl">0.0</span>, vertical<span class="op">=</span><span class="va">True</span>):  

        scaledx, xscale, xoffset <span class="op">=</span> scale_data(x, portion<span class="op">=</span>portion)
        scaledy, yscale, yoffset <span class="op">=</span> scale_data(y, portion<span class="op">=</span>portion)
        y_std <span class="op">/=</span> yscale

        <span class="co"># Check whether data is anti-correlated on output</span>
        <span class="cf">if</span> np.dot((scaledx<span class="op">-</span><span class="fl">0.5</span>).T, (scaledy<span class="op">-</span><span class="fl">0.5</span>))<span class="op">&lt;</span><span class="dv">0</span>:
            scaledy<span class="op">=</span><span class="dv">1</span><span class="op">-</span>scaledy
            flip<span class="op">=-</span><span class="dv">1</span>
        <span class="cf">else</span>:
            flip<span class="op">=</span><span class="dv">1</span>

        <span class="cf">if</span> color_scale <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
            color_scale, _, _<span class="op">=</span>scale_data(color_scale, portion<span class="op">=</span><span class="dv">0</span>)
        scaledy <span class="op">=</span> (<span class="dv">1</span><span class="op">-</span>alpha)<span class="op">*</span>scaledx <span class="op">+</span> alpha<span class="op">*</span>scaledy

        <span class="kw">def</span> color_value(x, cmap<span class="op">=</span><span class="va">None</span>, width<span class="op">=</span><span class="va">None</span>, centers<span class="op">=</span><span class="va">None</span>):
            <span class="co">&quot;&quot;&quot;Return color as a function of position along x axis&quot;&quot;&quot;</span>
            <span class="cf">if</span> cmap <span class="kw">is</span> <span class="va">None</span>:
                cmap <span class="op">=</span> np.asarray([[<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>], [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]])
            ncenters <span class="op">=</span> cmap.shape[<span class="dv">0</span>]
            <span class="cf">if</span> centers <span class="kw">is</span> <span class="va">None</span>:
                centers <span class="op">=</span> np.linspace(<span class="dv">0</span><span class="op">+</span><span class="fl">0.5</span><span class="op">/</span>ncenters, <span class="dv">1</span><span class="op">-</span><span class="fl">0.5</span><span class="op">/</span>ncenters, ncenters)
            <span class="cf">if</span> width <span class="kw">is</span> <span class="va">None</span>:
                width <span class="op">=</span> <span class="fl">0.25</span><span class="op">/</span>ncenters
            
            r <span class="op">=</span> (x<span class="op">-</span>centers)<span class="op">/</span>width
            weights <span class="op">=</span> np.exp(<span class="op">-</span><span class="fl">0.5</span><span class="op">*</span>r<span class="op">*</span>r).flatten()
            weights <span class="op">/=</span>weights.<span class="bu">sum</span>()
            weights <span class="op">=</span> weights[:, np.newaxis]
            <span class="cf">return</span> np.dot(cmap.T, weights).flatten()


        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x.shape[<span class="dv">0</span>]):
            <span class="cf">if</span> color_scale <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
                color <span class="op">=</span> color_value(color_scale[i])
            <span class="cf">else</span>:
                color<span class="op">=</span>(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>)
            x_plot <span class="op">=</span> np.asarray((scaledx[i], scaledy[i])).flatten()
            y_plot <span class="op">=</span> np.asarray((layer, layer<span class="op">+</span>alpha)).flatten()
            <span class="cf">if</span> vertical:
                ax.plot(x_plot, y_plot, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">3</span>)
                ax.plot(x_plot, y_plot, color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)
            <span class="cf">else</span>:
                ax.plot(y_plot, x_plot, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="dv">3</span>)
                ax.plot(y_plot, x_plot, color<span class="op">=</span><span class="st">&#39;k&#39;</span>, alpha<span class="op">=</span><span class="fl">0.5</span>, linewidth<span class="op">=</span><span class="fl">0.5</span>)

            <span class="co"># Plot error bars that increase as sqrt of distance from start.</span>
            std_points <span class="op">=</span> <span class="dv">50</span>
            stdy <span class="op">=</span> np.linspace(<span class="dv">0</span>, alpha,std_points)
            stdx <span class="op">=</span> np.sqrt(stdy)<span class="op">*</span>y_std[i]
            stdy <span class="op">+=</span> layer
            mean_vals <span class="op">=</span> np.linspace(scaledx[i], scaledy[i], std_points)
            upper <span class="op">=</span> mean_vals<span class="op">+</span>stdx 
            lower <span class="op">=</span> mean_vals<span class="op">-</span>stdx 
            fillcolor<span class="op">=</span>color
            x_errorbars<span class="op">=</span>np.hstack((upper,lower[::<span class="op">-</span><span class="dv">1</span>]))
            y_errorbars<span class="op">=</span>np.hstack((stdy,stdy[::<span class="op">-</span><span class="dv">1</span>]))
            <span class="cf">if</span> vertical:
                ax.fill(x_errorbars,y_errorbars,
                        color<span class="op">=</span>fillcolor, alpha<span class="op">=</span><span class="fl">0.1</span>)
                ax.plot(scaledy[i], layer<span class="op">+</span>alpha, <span class="st">&#39;.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.5</span>)
            <span class="cf">else</span>:
                ax.fill(y_errorbars,x_errorbars,
                        color<span class="op">=</span>fillcolor, alpha<span class="op">=</span><span class="fl">0.1</span>)
                ax.plot(layer<span class="op">+</span>alpha, scaledy[i], <span class="st">&#39;.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>, color<span class="op">=</span>color, alpha<span class="op">=</span><span class="fl">0.5</span>)
            <span class="co"># Marker to show end point</span>
        <span class="cf">return</span> flip


    <span class="co"># Whether final axis is flipped</span>
    flip <span class="op">=</span> <span class="dv">1</span>
    first_x<span class="op">=</span>last_x
    <span class="cf">for</span> i, layer <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">reversed</span>(<span class="va">self</span>.layers)):     
        <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span>:
            xt <span class="op">=</span> plot.pred_range(last_x, portion<span class="op">=</span>portion, points<span class="op">=</span>points)
            color_scale<span class="op">=</span>xt
        yt_mean, yt_var <span class="op">=</span> layer.predict(xt)
        <span class="cf">if</span> layer<span class="op">==</span><span class="va">self</span>.obslayer:
            yt_mean <span class="op">=</span> yt_mean<span class="op">*</span>scale <span class="op">+</span> offset
            yt_var <span class="op">*=</span> scale<span class="op">*</span>scale
        yt_sd <span class="op">=</span> np.sqrt(yt_var)
        flip <span class="op">=</span> flip<span class="op">*</span>pinball(xt,yt_mean,yt_sd,color_scale,portion<span class="op">=</span>portion, 
                            layer<span class="op">=</span>i, ax<span class="op">=</span>ax, depth<span class="op">=</span>depth,vertical<span class="op">=</span>vertical)<span class="co">#yt_mean-2*yt_sd,yt_mean+2*yt_sd)</span>
        xt <span class="op">=</span> yt_mean
    <span class="co"># Make room for axis labels</span>
    <span class="cf">if</span> vertical:
        ax.set_ylim((<span class="fl">2.1</span>, <span class="op">-</span><span class="fl">0.1</span>))
        ax.set_xlim((<span class="op">-</span><span class="fl">0.02</span>, <span class="fl">1.02</span>))
        ax.set_yticks(<span class="bu">range</span>(depth,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>))
    <span class="cf">else</span>:
        ax.set_xlim((<span class="op">-</span><span class="fl">0.1</span>, <span class="fl">2.1</span>))
        ax.set_ylim((<span class="op">-</span><span class="fl">0.02</span>, <span class="fl">1.02</span>))
        ax.set_xticks(<span class="bu">range</span>(<span class="dv">0</span>, depth))
        
    <span class="kw">def</span> draw_axis(ax, scale<span class="op">=</span><span class="fl">1.0</span>, offset<span class="op">=</span><span class="fl">0.0</span>, level<span class="op">=</span><span class="fl">0.0</span>, flip<span class="op">=</span><span class="dv">1</span>, 
                  label<span class="op">=</span><span class="va">None</span>,up<span class="op">=</span><span class="va">False</span>, nticks<span class="op">=</span><span class="dv">10</span>, ticklength<span class="op">=</span><span class="fl">0.05</span>,
                  vertical<span class="op">=</span><span class="va">True</span>,
                 fontsize<span class="op">=</span><span class="dv">20</span>):
        <span class="kw">def</span> clean_gap(gap):
            nsf <span class="op">=</span> np.log10(gap)
            <span class="cf">if</span> nsf<span class="op">&gt;</span><span class="dv">0</span>:
                nsf <span class="op">=</span> np.ceil(nsf)
            <span class="cf">else</span>:
                nsf <span class="op">=</span> np.floor(nsf)
            lower_gaps <span class="op">=</span> np.asarray([<span class="fl">0.005</span>, <span class="fl">0.01</span>, <span class="fl">0.02</span>, <span class="fl">0.03</span>, <span class="fl">0.04</span>, <span class="fl">0.05</span>, 
                                     <span class="fl">0.1</span>, <span class="fl">0.25</span>, <span class="fl">0.5</span>, 
                                     <span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>, <span class="fl">2.5</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">25</span>, <span class="dv">50</span>, <span class="dv">100</span>])
            upper_gaps <span class="op">=</span> np.asarray([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">10</span>])
            <span class="cf">if</span> nsf <span class="op">&gt;</span><span class="dv">2</span> <span class="kw">or</span> nsf<span class="op">&lt;-</span><span class="dv">2</span>:
                d <span class="op">=</span> np.<span class="bu">abs</span>(gap<span class="op">-</span>upper_gaps<span class="op">*</span><span class="dv">10</span><span class="op">**</span>nsf)
                ind <span class="op">=</span> np.argmin(d)
                <span class="cf">return</span> upper_gaps[ind]<span class="op">*</span><span class="dv">10</span><span class="op">**</span>nsf
            <span class="cf">else</span>:
                d <span class="op">=</span> np.<span class="bu">abs</span>(gap<span class="op">-</span>lower_gaps)
                ind <span class="op">=</span> np.argmin(d)
                <span class="cf">return</span> lower_gaps[ind]
            
        tickgap <span class="op">=</span> clean_gap(scale<span class="op">/</span>(nticks<span class="op">-</span><span class="dv">1</span>))
        nticks <span class="op">=</span> <span class="bu">int</span>(scale<span class="op">/</span>tickgap) <span class="op">+</span> <span class="dv">1</span>
        tickstart <span class="op">=</span> np.<span class="bu">round</span>(offset<span class="op">/</span>tickgap)<span class="op">*</span>tickgap
        ticklabels <span class="op">=</span> np.asarray(<span class="bu">range</span>(<span class="dv">0</span>, nticks))<span class="op">*</span>tickgap <span class="op">+</span> tickstart
        ticks <span class="op">=</span> (ticklabels<span class="op">-</span>offset)<span class="op">/</span>scale
        axargs <span class="op">=</span> {<span class="st">&#39;color&#39;</span>:<span class="st">&#39;k&#39;</span>, <span class="st">&#39;linewidth&#39;</span>:<span class="dv">1</span>}
        
        <span class="cf">if</span> <span class="kw">not</span> up:
            ticklength<span class="op">=-</span>ticklength
        tickspot <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, nticks)
        <span class="cf">if</span> flip <span class="op">&lt;</span> <span class="dv">0</span>:
            ticks <span class="op">=</span> <span class="dv">1</span><span class="op">-</span>ticks
        <span class="cf">for</span> tick, ticklabel <span class="kw">in</span> <span class="bu">zip</span>(ticks, ticklabels):
            <span class="cf">if</span> vertical:
                ax.plot([tick, tick], [level, level<span class="op">-</span>ticklength], <span class="op">**</span>axargs)
                ax.text(tick, level<span class="op">-</span>ticklength<span class="op">*</span><span class="dv">2</span>, ticklabel, horizontalalignment<span class="op">=</span><span class="st">&#39;center&#39;</span>, 
                        fontsize<span class="op">=</span>fontsize<span class="op">/</span><span class="dv">2</span>)
                ax.text(<span class="fl">0.5</span>, level<span class="op">-</span><span class="dv">5</span><span class="op">*</span>ticklength, label, horizontalalignment<span class="op">=</span><span class="st">&#39;center&#39;</span>, fontsize<span class="op">=</span>fontsize)
            <span class="cf">else</span>:
                ax.plot([level, level<span class="op">-</span>ticklength], [tick, tick],  <span class="op">**</span>axargs)
                ax.text(level<span class="op">-</span>ticklength<span class="op">*</span><span class="dv">2</span>, tick, ticklabel, horizontalalignment<span class="op">=</span><span class="st">&#39;center&#39;</span>, 
                        fontsize<span class="op">=</span>fontsize<span class="op">/</span><span class="dv">2</span>)
                ax.text(level<span class="op">-</span><span class="dv">5</span><span class="op">*</span>ticklength, <span class="fl">0.5</span>, label, horizontalalignment<span class="op">=</span><span class="st">&#39;center&#39;</span>, fontsize<span class="op">=</span>fontsize)
        
        <span class="cf">if</span> vertical:
            xlim <span class="op">=</span> <span class="bu">list</span>(ax.get_xlim())
            <span class="cf">if</span> ticks.<span class="bu">min</span>()<span class="op">&lt;</span>xlim[<span class="dv">0</span>]:
                xlim[<span class="dv">0</span>] <span class="op">=</span> ticks.<span class="bu">min</span>()
            <span class="cf">if</span> ticks.<span class="bu">max</span>()<span class="op">&gt;</span>xlim[<span class="dv">1</span>]:
                xlim[<span class="dv">1</span>] <span class="op">=</span> ticks.<span class="bu">max</span>()
            ax.set_xlim(xlim)
            
            ax.plot([ticks.<span class="bu">min</span>(), ticks.<span class="bu">max</span>()], [level, level], <span class="op">**</span>axargs)
        <span class="cf">else</span>:
            ylim <span class="op">=</span> <span class="bu">list</span>(ax.get_ylim())
            <span class="cf">if</span> ticks.<span class="bu">min</span>()<span class="op">&lt;</span>ylim[<span class="dv">0</span>]:
                ylim[<span class="dv">0</span>] <span class="op">=</span> ticks.<span class="bu">min</span>()
            <span class="cf">if</span> ticks.<span class="bu">max</span>()<span class="op">&gt;</span>ylim[<span class="dv">1</span>]:
                ylim[<span class="dv">1</span>] <span class="op">=</span> ticks.<span class="bu">max</span>()
            ax.set_ylim(ylim)
            ax.plot([level, level], [ticks.<span class="bu">min</span>(), ticks.<span class="bu">max</span>()], <span class="op">**</span>axargs)


    _, xscale, xoffset <span class="op">=</span> scale_data(first_x, portion<span class="op">=</span>portion)
    _, yscale, yoffset <span class="op">=</span> scale_data(yt_mean, portion<span class="op">=</span>portion)
    draw_axis(ax<span class="op">=</span>ax, scale<span class="op">=</span>xscale, offset<span class="op">=</span>xoffset, level<span class="op">=</span><span class="fl">0.0</span>, label<span class="op">=</span>xlabel, 
              up<span class="op">=</span><span class="va">True</span>, vertical<span class="op">=</span>vertical)
    draw_axis(ax<span class="op">=</span>ax, scale<span class="op">=</span>yscale, offset<span class="op">=</span>yoffset, 
              flip<span class="op">=</span>flip, level<span class="op">=</span>depth, label<span class="op">=</span>ylabel, up<span class="op">=</span><span class="va">False</span>, vertical<span class="op">=</span>vertical)
    
    <span class="co">#for txt in xticklabels:</span>
    <span class="co">#    txt.set</span>
<span class="co"># Bind the new method to the Deep GP object.</span>
deepgp.DeepGP.visualize_pinball<span class="op">=</span>visualize_pinball</code></pre></div>
<h3 id="olympic-marathon-pinball-plot">Olympic Marathon Pinball Plot</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-pinball.svg" style>
</object>
<p>The pinball plot shows the flow of any input ball through the deep Gaussian process. In a pinball plot a series of vertical parallel lines would indicate a purely linear function. For the olypmic marathon data we can see the first layer begins to shift from input towards the right. Note it also does so with some uncertainty (indicated by the shaded backgrounds). The second layer has less uncertainty, but bunches the inputs more strongly to the right. This input layer of uncertainty, followed by a layer that pushes inputs to the right is what gives the heteroschedastic noise.</p>
<h3 id="step-function">Step Function</h3>
<p>Next we consider a simple step function data set.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">num_low<span class="op">=</span><span class="dv">25</span>
num_high<span class="op">=</span><span class="dv">25</span>
gap <span class="op">=</span> <span class="op">-</span>.<span class="dv">1</span>
noise<span class="op">=</span><span class="fl">0.0001</span>
x <span class="op">=</span> np.vstack((np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span>gap<span class="op">/</span><span class="fl">2.0</span>, num_low)[:, np.newaxis],
              np.linspace(gap<span class="op">/</span><span class="fl">2.0</span>, <span class="dv">1</span>, num_high)[:, np.newaxis]))
y <span class="op">=</span> np.vstack((np.zeros((num_low, <span class="dv">1</span>)), np.ones((num_high,<span class="dv">1</span>))))
scale <span class="op">=</span> np.sqrt(y.var())
offset <span class="op">=</span> y.mean()
yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</code></pre></div>
<h3 id="step-function-data" data-transition="None">Step Function Data</h3>
<object class="svgplot " align data="../slides/diagrams/datasets/step-function.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)
_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></code></pre></div>
<h3 id="step-function-data-gp" data-transition="None">Step Function Data GP</h3>
<object class="svgplot " align data="../slides/diagrams/gp/step-function-gp.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,x.shape[<span class="dv">1</span>]]
inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)
kernels <span class="op">=</span> []
<span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:
    kernels <span class="op">+=</span> [GPy.kern.RBF(i)]
m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>yhat, X<span class="op">=</span>x, 
                  inits<span class="op">=</span>inits, 
                  kernels<span class="op">=</span>kernels, <span class="co"># the kernels for each layer</span>
                  num_inducing<span class="op">=</span><span class="dv">20</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.initialize()
m.staged_optimize()</code></pre></div>
<h3 id="step-function-data-deep-gp" data-transition="None">Step Function Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp.svg" style>
</object>
<h3 id="step-function-data-deep-gp-1" data-transition="None">Step Function Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-samples.svg" style>
</object>
<h3 id="step-function-data-latent-1" data-transition="None">Step Function Data Latent 1</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-layer-0.svg" style>
</object>
<h3 id="step-function-data-latent-2" data-transition="None">Step Function Data Latent 2</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-layer-1.svg" style>
</object>
<h3 id="step-function-data-latent-3" data-transition="None">Step Function Data Latent 3</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-layer-2.svg" style>
</object>
<h3 id="step-function-data-latent-4" data-transition="None">Step Function Data Latent 4</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-layer-3.svg" style>
</object>
<h3 id="step-function-pinball-plot" data-transition="None">Step Function Pinball Plot</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/step-function-deep-gp-pinball.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pods
data <span class="op">=</span> pods.datasets.mcycle()
x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]
y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]
scale<span class="op">=</span>np.sqrt(y.var())
offset<span class="op">=</span>y.mean()
yhat <span class="op">=</span> (y <span class="op">-</span> offset)<span class="op">/</span>scale</code></pre></div>
<h3 id="motorcycle-helmet-data" data-transition="None">Motorcycle Helmet Data</h3>
<object class="svgplot " align data="../slides/diagrams/datasets/motorcycle-helmet.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)
_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></code></pre></div>
<h3 id="motorcycle-helmet-data-gp" data-transition="None">Motorcycle Helmet Data GP</h3>
<object class="svgplot " align data="../slides/diagrams/gp/motorcycle-helmet-gp.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">1</span>, x.shape[<span class="dv">1</span>]]
inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)
kernels <span class="op">=</span> []
<span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:
    kernels <span class="op">+=</span> [GPy.kern.RBF(i)]
m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>yhat, X<span class="op">=</span>x, 
                  inits<span class="op">=</span>inits, 
                  kernels<span class="op">=</span>kernels, <span class="co"># the kernels for each layer</span>
                  num_inducing<span class="op">=</span><span class="dv">20</span>, back_constraint<span class="op">=</span><span class="va">False</span>)



m.initialize()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.staged_optimize(iters<span class="op">=</span>(<span class="dv">1000</span>,<span class="dv">1000</span>,<span class="dv">10000</span>), messages<span class="op">=</span>(<span class="va">True</span>, <span class="va">True</span>, <span class="va">True</span>))</code></pre></div>
<h3 id="motorcycle-helmet-data-deep-gp" data-transition="None">Motorcycle Helmet Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp.svg" style>
</object>
<h3 id="motorcycle-helmet-data-deep-gp-1" data-transition="None">Motorcycle Helmet Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-samples.svg" style>
</object>
<h3 id="motorcycle-helmet-data-latent-1" data-transition="None">Motorcycle Helmet Data Latent 1</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-layer-0.svg" style>
</object>
<h3 id="motorcycle-helmet-data-latent-2" data-transition="None">Motorcycle Helmet Data Latent 2</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-layer-1.svg" style>
</object>
<h3 id="motorcycle-helmet-pinball-plot" data-transition="None">Motorcycle Helmet Pinball Plot</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-pinball.svg" style>
</object>
<h3 id="robot-wireless-data">Robot Wireless Data</h3>
<p>The robot wireless data is taken from an experiment run by Brian Ferris at University of Washington. It consists of the measurements of WiFi access point signal strengths as Brian walked in a loop.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">data<span class="op">=</span>pods.datasets.robot_wireless()

x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">215</span>)[:, np.newaxis]
y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]
offset <span class="op">=</span> y.mean()
scale <span class="op">=</span> np.sqrt(y.var())
yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</code></pre></div>
<p>The ground truth is recorded in the data, the actual loop is given in the plot below.</p>
<h3 id="robot-wireless-ground-truth" data-transition="None">Robot Wireless Ground Truth</h3>
<object class="svgplot " align data="../slides/diagrams/datasets/robot-wireless-ground-truth.svg" style>
</object>
<p>We will ignore this ground truth in making our predictions, but see if the model can recover something similar in one of the latent layers.</p>
<h3 id="robot-wifi-data" data-transition="None">Robot WiFi Data</h3>
<object class="svgplot " align data="../slides/diagrams/datasets/robot-wireless-dim-1.svg" style>
</object>
<p>Perform a Gaussian process fit on the data using GPy.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)
_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></code></pre></div>
<h3 id="robot-wifi-data-gp" data-transition="None">Robot WiFi Data GP</h3>
<object class="svgplot " align data="../slides/diagrams/gp/robot-wireless-gp-dim-1.svg" style>
</object>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">2</span>, x.shape[<span class="dv">1</span>]]
inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)
kernels <span class="op">=</span> []
<span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:
    kernels <span class="op">+=</span> [GPy.kern.RBF(i, ARD<span class="op">=</span><span class="va">True</span>)]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>y, X<span class="op">=</span>x, inits<span class="op">=</span>inits, 
                  kernels<span class="op">=</span>kernels,
                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>)
m.initialize()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.staged_optimize(messages<span class="op">=</span>(<span class="va">True</span>,<span class="va">True</span>,<span class="va">True</span>))</code></pre></div>
<h3 id="robot-wifi-data-deep-gp" data-transition="None">Robot WiFi Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/robot-wireless-deep-gp-dim-1.svg" style>
</object>
<h3 id="robot-wifi-data-deep-gp-1" data-transition="None">Robot WiFi Data Deep GP</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/robot-wireless-deep-gp-samples-dim-1.svg" style>
</object>
<h3 id="robot-wifi-data-latent-space" data-transition="None">Robot WiFi Data Latent Space</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/robot-wireless-ground-truth.svg" style>
</object>
<h3 id="robot-wifi-data-latent-space-1" data-transition="None">Robot WiFi Data Latent Space</h3>
<object class="svgplot " align data="../slides/diagrams/deepgp/robot-wireless-latent-space.svg" style>
</object>
<h3 id="motion-capture" data-transition="none">Motion Capture</h3>
<ul>
<li><p>‘High five’ data.</p></li>
<li><p>Model learns structure between two interacting subjects.</p></li>
</ul>
<h3 id="shared-lvm" data-transition="none">Shared LVM</h3>
<object class="svgplot " align data="../slides/diagrams/shared.svg" style>
</object>
<h3 id="section" data-transition="none"></h3>
<p><img class="negate" src="../slides/diagrams/deep-gp-high-five2.png" width="100%" height="auto" align="" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto"></p>
<p><small><span style="text-align:right">Thanks to: Zhenwen Dai and Neil D. Lawrence</span></small></p>
<p>This notebook explores the deep Gaussian processes' capacity to perform unsupervised learning.</p>
<p>We will look at a sub-sample of the MNIST digit data set.</p>
<p>This notebook depends on GPy and PyDeepGP. These libraries can be installed via pip:</p>
<pre><code>pip install GPy
pip install git+https://github.com/SheffieldML/PyDeepGP.git</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt
<span class="im">from</span> matplotlib <span class="im">import</span> rc
<span class="im">from</span> IPython.display <span class="im">import</span> display

<span class="im">import</span> deepgp
<span class="im">import</span> GPy

<span class="im">from</span> gp_tutorial <span class="im">import</span> ax_default, meanplot, gpplot
<span class="im">import</span> mlai
<span class="im">import</span> teaching_plots <span class="im">as</span> plot</code></pre></div>
<p>First load in the MNIST data set from scikit learn. This can take a little while because it's large to download.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_mldata
mnist <span class="op">=</span> fetch_mldata(<span class="st">&#39;MNIST original&#39;</span>)</code></pre></div>
<p>Sub-sample the dataset to make the training faster.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">np.random.seed(<span class="dv">0</span>)
digits <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]
N_per_digit <span class="op">=</span> <span class="dv">100</span>
Y <span class="op">=</span> []
labels <span class="op">=</span> []
<span class="cf">for</span> d <span class="kw">in</span> digits:
    imgs <span class="op">=</span> mnist[<span class="st">&#39;data&#39;</span>][mnist[<span class="st">&#39;target&#39;</span>]<span class="op">==</span>d]
    Y.append(imgs[np.random.permutation(imgs.shape[<span class="dv">0</span>])][:N_per_digit])
    labels.append(np.ones(N_per_digit)<span class="op">*</span>d)
Y <span class="op">=</span> np.vstack(Y).astype(np.float64)
labels <span class="op">=</span> np.hstack(labels)
Y <span class="op">/=</span> <span class="dv">255</span>.</code></pre></div>
<h3 id="fit-a-deep-gp">Fit a Deep GP</h3>
<p>We're going to fit a Deep Gaussian process model to the MNIST data with two hidden layers. Each of the two Gaussian processes (one from the first hidden layer to the second, one from the second hidden layer to the data) has an exponentiated quadratic covariance.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">num_latent <span class="op">=</span> <span class="dv">2</span>
num_hidden_2 <span class="op">=</span> <span class="dv">5</span>
m <span class="op">=</span> deepgp.DeepGP([Y.shape[<span class="dv">1</span>],num_hidden_2,num_latent],
                  Y,
                  kernels<span class="op">=</span>[GPy.kern.RBF(num_hidden_2,ARD<span class="op">=</span><span class="va">True</span>), 
                           GPy.kern.RBF(num_latent,ARD<span class="op">=</span><span class="va">False</span>)], 
                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>, 
                  encoder_dims<span class="op">=</span>[[<span class="dv">200</span>],[<span class="dv">200</span>]])</code></pre></div>
<h3 id="initialization">Initialization</h3>
<p>Just like deep neural networks, there are some tricks to intitializing these models. The tricks we use here include some early training of the model with model parameters constrained. This gives the variational inducing parameters some scope to tighten the bound for the case where the noise variance is small and the variances of the Gaussian processes are around 1.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.obslayer.likelihood.variance[:] <span class="op">=</span> Y.var()<span class="op">*</span><span class="fl">0.01</span>
<span class="cf">for</span> layer <span class="kw">in</span> m.layers:
    layer.kern.variance.fix(warning<span class="op">=</span><span class="va">False</span>)
    layer.likelihood.variance.fix(warning<span class="op">=</span><span class="va">False</span>)</code></pre></div>
<p>We now we optimize for a hundred iterations with the constrained model.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</code></pre></div>
<p>Now we remove the fixed constraint on the kernel variance parameters, but keep the noise output constrained, and run for a further 100 iterations.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:
    layer.kern.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</code></pre></div>
<p>Finally we unconstrain the layer likelihoods and allow the full model to be trained for 1000 iterations.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:
    layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)
m.optimize(messages<span class="op">=</span><span class="va">True</span>,max_iters<span class="op">=</span><span class="dv">10000</span>)</code></pre></div>
<h3 id="visualize-the-latent-space-of-the-top-layer">Visualize the latent space of the top layer</h3>
<p>Now the model is trained, let's plot the mean of the posterior distributions in the top latent layer of the model.</p>
<object class="svgplot " align data="../slides/diagrams/usps-digits-latent.svg" style>
</object>
<h3 id="visualize-the-latent-space-of-the-intermediate-layer">Visualize the latent space of the intermediate layer</h3>
<p>We can also visualize dimensions of the intermediate layer. First the lengthscale of those dimensions is given by</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.obslayer.kern.lengthscale</code></pre></div>
<h3 id="section-1" data-transition="none"></h3>
<object class="svgplot " align data="../slides/diagrams/usps-digits-hidden-1-0.svg" style>
</object>
<h3 id="section-2" data-transition="none"></h3>
<object class="svgplot " align data="../slides/diagrams/usps-digits-hidden-2-0.svg" style>
</object>
<h3 id="section-3" data-transition="none"></h3>
<object class="svgplot " align data="../slides/diagrams/usps-digits-hidden-3-0.svg" style>
</object>
<h3 id="section-4" data-transition="none"></h3>
<object class="svgplot " align data="../slides/diagrams/usps-digits-hidden-4-0.svg" style>
</object>
<h3 id="generate-from-model">Generate From Model</h3>
<p>Now we can take a look at a sample from the model, by drawing a Gaussian random sample in the latent space and propagating it through the model.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">
rows <span class="op">=</span> <span class="dv">10</span>
cols <span class="op">=</span> <span class="dv">20</span>
t<span class="op">=</span>np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, rows<span class="op">*</span>cols)[:, <span class="va">None</span>]
kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>,lengthscale<span class="op">=</span><span class="fl">0.05</span>)
cov <span class="op">=</span> kern.K(t, t)
x <span class="op">=</span> np.random.multivariate_normal(np.zeros(rows<span class="op">*</span>cols), cov, num_latent).T</code></pre></div>
<h3 id="section-5" data-transition="none"></h3>
<object class="svgplot " align data="../slides/diagrams/digit-samples-deep-gp.svg" style>
</object>
<div style="text-align:center">
<object class="svgplot " align data="../slides/diagrams/deep-health.svg" style>
</object>
</div>
<ul>
<li><em>Gaussian process based nonlinear latent structure discovery in multivariate spike train data</em> <span class="citation">Wu et al. (2017)</span></li>
<li><em>Doubly Stochastic Variational Inference for Deep Gaussian Processes</em> <span class="citation">Salimbeni and Deisenroth (2017)</span></li>
<li><em>Deep Multi-task Gaussian Processes for Survival Analysis with Competing Risks</em> <span class="citation">Alaa and van der Schaar (2017)</span></li>
<li><p><em>Counterfactual Gaussian Processes for Reliable Decision-making and What-if Reasoning</em> <span class="citation">Schulam and Saria (2017)</span></p></li>
<li><em>Deep Survival Analysis</em> <span class="citation">Ranganath et al. (2016)</span></li>
<li><em>Recurrent Gaussian Processes</em> <span class="citation">Mattos et al. (2015)</span></li>
<li><p><em>Gaussian Process Based Approaches for Survival Analysis</em> <span class="citation">Saul (2016)</span></p></li>
</ul>
<div style="text-align:center">
<a href="https://amzn.github.io/emukit-playground/"><img class="" src="../slides/diagrams/uq/emukit-playground.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto"></a>
</div>
<center>
<em>Emukit playground is a tutorial for understanding the simulation/emulation relationship. </em>
</center>
<div style="text-align:center">
<a href="https://amzn.github.io/emukit-playground/#!/learn/bayesian_optimization"><img class="negate" src="../slides/diagrams/uq/emukit-playground-bayes-opt.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto"></a>
</div>
<center>
<em>Tutorial on Bayesian optimization of the number of taxis deployed from Emukit playground. </em>
</center>
<h3 id="uncertainty-quantification">Uncertainty Quantification</h3>
<blockquote>
<p>Uncertainty quantification (UQ) is the science of quantitative characterization and reduction of uncertainties in both computational and real world applications. It tries to determine how likely certain outcomes are if some aspects of the system are not exactly known.</p>
</blockquote>
<p>We will to illustrate different concepts of <a href="https://en.wikipedia.org/wiki/Uncertainty_quantification">Uncertainty Quantification</a> (UQ) and the role that Gaussian processes play in this field. Based on a simple simulator of a car moving between a valley and a mountain, we are going to illustrate the following concepts:</p>
<ul>
<li><p><strong>Systems emulation</strong>. Many real world decisions are based on simulations that can be computationally very demanding. We will show how simulators can be replaced by <em>emulators</em>: Gaussian process models fitted on a few simulations that can be used to replace the <em>simulator</em>. Emulators are cheap to compute, fast to run, and always provide ways to quantify the uncertainty of how precise they are compared the original simulator.</p></li>
<li><p><strong>Emulators in optimization problems</strong>. We will show how emulators can be used to optimize black-box functions that are expensive to evaluate. This field is also called Bayesian Optimization and has gained an increasing relevance in machine learning as emulators can be used to optimize computer simulations (and machine learning algorithms) quite efficiently.</p></li>
<li><p><strong>Multi-fidelity emulation methods</strong>. In many scenarios we have simulators of different quality about the same measure of interest. In these cases the goal is to merge all sources of information under the same model so the final emulator is cheaper and more accurate than an emulator fitted only using data from the most accurate and expensive simulator.</p></li>
</ul>
<h3 id="mountain-car-simulator">Mountain Car Simulator</h3>
<p>To illustrate the above mentioned concepts we we use the <a href="https://github.com/openai/gym/wiki/MountainCarContinuous-v0">mountain car simulator</a>. This simulator is widely used in machine learning to test reinforcement learning algorithms. The goal is to define a control policy on a car whose objective is to climb a mountain. Graphically, the problem looks as follows:</p>
<div style="text-align:center">
<img class="negate" src="../slides/diagrams/uq/mountaincar.png" width="" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</div>
<center>
<em>The mountain car simulation from the Open AI gym. </em>
</center>
<p>The goal is to define a sequence of actions (push the car right or left with certain intensity) to make the car reach the flag after a number <span class="math inline"><em>T</em></span> of time steps.</p>
<p>At each time step <span class="math inline"><em>t</em></span>, the car is characterized by a vector <span class="math inline">$\inputVector_{t} = (p_t,v_t)$</span> of states which are respectively the the position and velocity of the car at time <span class="math inline"><em>t</em></span>. For a sequence of states (an episode), the dynamics of the car is given by</p>
<p><br /><span class="math display">$$\inputVector_{t+1} = \mappingFunction(\inputVector_{t},\textbf{u}_{t})$$</span><br /></p>
<p>where <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span> is the value of an action force, which in this example corresponds to push car to the left (negative value) or to the right (positive value). The actions across a full episode are represented in a policy <span class="math inline">$\textbf{u}_{t} = \pi(\inputVector_{t},\theta)$</span> that acts according to the current state of the car and some parameters <span class="math inline"><em>θ</em></span>. In the following examples we will assume that the policy is linear which allows us to write <span class="math inline">$\pi(\inputVector_{t},\theta)$</span> as</p>
<p><br /><span class="math display">$$\pi(\inputVector,\theta)= \theta_0 + \theta_p p + \theta_vv.$$</span><br /></p>
<p>For <span class="math inline"><em>t</em> = 1, …, <em>T</em></span> now given some initial state <span class="math inline">$\inputVector_{0}$</span> and some some values of each <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span>, we can <strong>simulate</strong> the full dynamics of the car for a full episode using <a href="https://gym.openai.com/envs/">Gym</a>. The values of <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span> are fully determined by the parameters of the linear controller.</p>
<p>After each episode of length <span class="math inline"><em>T</em></span> is complete, a reward function <span class="math inline"><em>R</em><sub><em>T</em></sub>(<em>θ</em>)</span> is computed. In the mountain car example the reward is computed as 100 for reaching the target of the hill on the right hand side, minus the squared sum of actions (a real negative to push to the left and a real positive to push to the right) from start to goal. Note that our reward depend on <span class="math inline"><em>θ</em></span> as we make it dependent on the parameters of the linear controller.</p>
<h3 id="emulate-the-mountain-car">Emulate the Mountain Car</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> gym</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</code></pre></div>
<p>Our goal in this section is to find the parameters <span class="math inline"><em>θ</em></span> of the linear controller such that</p>
<p><br /><span class="math display"><em>θ</em><sup>*</sup> = <em>a</em><em>r</em><em>g</em>max<sub><em>θ</em></sub><em>R</em><sub><em>T</em></sub>(<em>θ</em>).</span><br /></p>
<p>In this section, we directly use Bayesian optimization to solve this problem. We will use <a href="https://sheffieldml.github.io/GPyOpt/">GPyOpt</a> so we first define the objective function:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> mountain_car <span class="im">as</span> mc
<span class="im">import</span> GPyOpt</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">obj_func <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_simulation(env, x)[<span class="dv">0</span>]
objective <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func)</code></pre></div>
<p>For each set of parameter values of the linear controller we can run an episode of the simulator (that we fix to have a horizon of <span class="math inline"><em>T</em> = 500</span>) to generate the reward. Using as input the parameters of the controller and as outputs the rewards we can build a Gaussian process emulator of the reward.</p>
<p>We start defining the input space, which is three-dimensional:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">## --- We define the input space of the emulator</span>

space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;postion_parameter&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity_parameter&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]

design_space <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)</code></pre></div>
<p>Now we initizialize a Gaussian process emulator.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p>In Bayesian optimization an acquisition function is used to balance exploration and exploitation to evaluate new locations close to the optimum of the objective. In this notebook we select the expected improvement (EI). For further details have a look to the review paper of <a href="http://www.cs.ox.ac.uk/people/nando.defreitas/publications/BayesOptLoop.pdf">Shahriari et al (2015)</a>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)
acquisition <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)
evaluator <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition) <span class="co"># Collect points sequentially, no parallelization.</span></code></pre></div>
<p>To initalize the model we start sampling some initial points (25) for the linear controler randomly.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">n_initial_points <span class="op">=</span> <span class="dv">25</span>
random_design <span class="op">=</span> RandomDesign(design_space)
initial_design <span class="op">=</span> random_design.get_samples(n_initial_points)</code></pre></div>
<p>Before we start any optimization, lets have a look to the behavior of the car with the first of these initial points that we have selected randomly.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">random_controller <span class="op">=</span> initial_design[<span class="dv">0</span>,:]
_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(random_controller), render<span class="op">=</span><span class="va">True</span>)
anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Random linear controller&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</code></pre></div>
<iframe src="../slides/diagrams/uq/mountain_car_random.html" width="1024" height="768" allowtransparency="true" frameborder="0">
</iframe>
<p>As we can see the random linear controller does not manage to push the car to the top of the mountain. Now, let's optimize the regret using Bayesian optimization and the emulator for the reward. We try 50 new parameters chosen by the EI.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">max_iter <span class="op">=</span> <span class="dv">50</span>
bo <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective, acquisition, evaluator, initial_design)
bo.run_optimization(max_iter <span class="op">=</span> max_iter )</code></pre></div>
<p>Now we visualize the result for the best controller that we have found with Bayesian optimization.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo.x_opt), render<span class="op">=</span><span class="va">True</span>)
anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller after 50 iterations of Bayesian optimization&#39;</span>)</code></pre></div>
<iframe src="../slides/diagrams/uq/mountain_car_simulated.html" width="1024" height="768" allowtransparency="true" frameborder="0">
</iframe>
<p>he car can now make it to the top of the mountain! Emulating the reward function and using the EI helped as to find a linear controller that solves the problem.</p>
<h3 id="data-efficient-emulation">Data Efficient Emulation</h3>
<p>In the previous section we solved the mountain car problem by directly emulating the reward but no considerations about the dynamics <span class="math inline">$\inputVector_{t+1} = \mappingFunction(\inputVector_{t},\textbf{u}_{t})$</span> of the system were made. Note that we had to run 75 episodes of 500 steps each to solve the problem, which required to call the simulator <span class="math inline">500 × 75 = 37500</span> times. In this section we will show how it is possible to reduce this number by building an emulator for <span class="math inline"><em>f</em></span> that can later be used to directly optimize the control.</p>
<p>The inputs of the model for the dynamics are the velocity, the position and the value of the control so create this space accordingly.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> gym</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> GPyOpt</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">space_dynamics <span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;position&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="fl">0.6</span>]},
                  {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="fl">0.07</span>, <span class="op">+</span><span class="fl">0.07</span>]},
                  {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;action&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]}]
design_space_dynamics <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space_dynamics)</code></pre></div>
<p>The outputs are the velocity and the position. Indeed our model will capture the change in position and velocity on time. That is, we will model</p>
<p><br /><span class="math display"><em>Δ</em><em>v</em><sub><em>t</em> + 1</sub> = <em>v</em><sub><em>t</em> + 1</sub> − <em>v</em><sub><em>t</em></sub></span><br /></p>
<p><br /><span class="math display"><em>Δ</em><em>x</em><sub><em>t</em> + 1</sub> = <em>p</em><sub><em>t</em> + 1</sub> − <em>p</em><sub><em>t</em></sub></span><br /></p>
<p>with Gaussian processes with prior mean <span class="math inline"><em>v</em><sub><em>t</em></sub></span> and <span class="math inline"><em>p</em><sub><em>t</em></sub></span> respectively. As a covariance function, we use a Matern52. We need therefore two models to capture the full dynamics of the system.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">position_model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)
velocity_model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p>Next, we sample some input parameters and use the simulator to compute the outputs. Note that in this case we are not running the full episodes, we are just using the simulator to compute <span class="math inline">$\inputVector_{t+1}$</span> given <span class="math inline">$\inputVector_{t}$</span> and <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign
<span class="im">import</span> mountain_car <span class="im">as</span> mc</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Random locations of the inputs</span>
n_initial_points <span class="op">=</span> <span class="dv">500</span>
random_design_dynamics <span class="op">=</span> RandomDesign(design_space_dynamics)
initial_design_dynamics <span class="op">=</span> random_design_dynamics.get_samples(n_initial_points)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Simulation of the (normalized) outputs</span>
y <span class="op">=</span> np.zeros((initial_design_dynamics.shape[<span class="dv">0</span>], <span class="dv">2</span>))
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(initial_design_dynamics.shape[<span class="dv">0</span>]):
    y[i, :] <span class="op">=</span> mc.simulation(initial_design_dynamics[i, :])

<span class="co"># Normalize the data from the simulation</span>
y_normalisation <span class="op">=</span> np.std(y, axis<span class="op">=</span><span class="dv">0</span>)
y_normalised <span class="op">=</span> y<span class="op">/</span>y_normalisation</code></pre></div>
<p>In general we might use much smarter strategies to design our emulation of the simulator. For example, we could use the variance of the predictive distributions of the models to collect points using uncertainty sampling, which will give us a better coverage of the space. For simplicity, we move ahead with the 500 randomly selected points.</p>
<p>Now that we have a data set, we can update the emulators for the location and the velocity.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">position_model.updateModel(initial_design_dynamics, y[:, [<span class="dv">0</span>]], <span class="va">None</span>, <span class="va">None</span>)
velocity_model.updateModel(initial_design_dynamics, y[:, [<span class="dv">1</span>]], <span class="va">None</span>, <span class="va">None</span>)</code></pre></div>
<p>We can now have a look to how the emulator and the simulator match. First, we show a contour plot of the car aceleration for each pair of can position and velocity. You can use the bar bellow to play with the values of the controler to compare the emulator and the simulator.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> IPython.html.widgets <span class="im">import</span> interact</code></pre></div>
<p>We can see how the emulator is doing a fairly good job approximating the simulator. On the edges, however, it struggles to captures the dynamics of the simulator.</p>
<p>Given some input parameters of the linear controlling, how do the dynamics of the emulator and simulator match? In the following figure we show the position and velocity of the car for the 500 time steps of an episode in which the parameters of the linear controller have been fixed beforehand. The value of the input control is also shown.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">controller_gains <span class="op">=</span> np.atleast_2d([<span class="dv">0</span>, .<span class="dv">6</span>, <span class="dv">1</span>])  <span class="co"># change the valus of the linear controller to observe the trayectories.</span></code></pre></div>
<object class="svgplot " align data="../slides/diagrams/uq/emu_sim_comparison.svg" style>
</object>
<p>We now make explicit use of the emulator, using it to replace the simulator and optimize the linear controller. Note that in this optimization, we don't need to query the simulator anymore as we can reproduce the full dynamics of an episode using the emulator. For illustrative purposes, in this example we fix the initial location of the car.</p>
<p>We define the objective reward function in terms of the simulator.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Optimize control parameters with emulator</span>
car_initial_location <span class="op">=</span> np.asarray([<span class="op">-</span><span class="fl">0.58912799</span>, <span class="dv">0</span>]) 

<span class="co">### --- Reward objective function using the emulator</span>
obj_func_emulator <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_emulation([position_model, velocity_model], x, car_initial_location)[<span class="dv">0</span>]
objective_emulator <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func_emulator)</code></pre></div>
<p>And as before, we use Bayesian optimization to find the best possible linear controller.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Elements of the optimization that will use the multi-fidelity emulator</span>
model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</code></pre></div>
<p>The design space is the three continuous variables that make up the linear controller.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_1&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_2&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]

design_space         <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)
aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)

random_design <span class="op">=</span> RandomDesign(design_space)
initial_design <span class="op">=</span> random_design.get_samples(<span class="dv">25</span>)</code></pre></div>
<p>We set the acquisition function to be expected improvement using <code>GPyOpt</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">acquisition          <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)
evaluator            <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">bo_emulator <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective_emulator, acquisition, evaluator, initial_design)
bo_emulator.run_optimization(max_iter<span class="op">=</span><span class="dv">50</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo_emulator.x_opt), render<span class="op">=</span><span class="va">True</span>)
anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller using the emulator of the dynamics&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</code></pre></div>
<iframe src="../slides/diagrams/uq/mountain_car_emulated.html" width="1024" height="768" allowtransparency="true" frameborder="0">
</iframe>
<p>And the problem is again solved, but in this case we have replaced the simulator of the car dynamics by a Gaussian process emulator that we learned by calling the simulator only 500 times. Compared to the 37500 calls that we needed when applying Bayesian optimization directly on the simulator this is a great gain.</p>
<p>In some scenarios we have simulators of the same environment that have different fidelities, that is that reflect with different level of accuracy the dynamics of the real world. Running simulations of the different fidelities also have a different cost: hight fidelity simulations are more expensive the cheaper ones. If we have access to these simulators we can combine high and low fidelity simulations under the same model.</p>
<p>So let's assume that we have two simulators of the mountain car dynamics, one of high fidelity (the one we have used) and another one of low fidelity. The traditional approach to this form of multi-fidelity emulation is to assume that</p>
<p><br /><span class="math display">$$\mappingFunction_i\left(\inputVector\right) = \rho\mappingFunction_{i-1}\left(\inputVector\right) + \delta_i\left(\inputVector \right)$$</span><br /></p>
<p>where <span class="math inline">$\mappingFunction_{i-1}\left(\inputVector\right)$</span> is a low fidelity simulation of the problem of interest and <span class="math inline">$\mappingFunction_i\left(\inputVector\right)$</span> is a higher fidelity simulation. The function <span class="math inline">$\delta_i\left(\inputVector \right)$</span> represents the difference between the lower and higher fidelity simulation, which is considered additive. The additive form of this covariance means that if <span class="math inline">$\mappingFunction_{0}\left(\inputVector\right)$</span> and <span class="math inline">$\left\{\delta_i\left(\inputVector \right)\right\}_{i=1}^m$</span> are all Gaussian processes, then the process over all fidelities of simuation will be a joint Gaussian process.</p>
<p>But with Deep Gaussian processes we can consider the form</p>
<p><br /><span class="math display">$$\mappingFunction_i\left(\inputVector\right) = \mappingFunctionTwo_{i}\left(\mappingFunction_{i-1}\left(\inputVector\right)\right) + \delta_i\left(\inputVector \right),$$</span><br /></p>
<p>where the low fidelity representation is non linearly transformed by <span class="math inline">$\mappingFunctionTwo(\cdot)$</span> before use in the process. This is the approach taken in <span class="citation">Perdikaris et al. (2017)</span>. But once we accept that these models can be composed, a highly flexible framework can emerge. A key point is that the data enters the model at different levels, and represents different aspects. For example these correspond to the two fidelities of the mountain car simulator.</p>
<p>We start by sampling both of them at 250 random input locations.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> gym</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> GPyOpt</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Collect points from low and high fidelity simulator --- </span><span class="al">###</span>

space <span class="op">=</span> GPyOpt.Design_space([
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;position&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">0.07</span>, <span class="op">+</span><span class="fl">0.07</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;action&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}])

n_points <span class="op">=</span> <span class="dv">250</span>
random_design <span class="op">=</span> GPyOpt.experiment_design.RandomDesign(space)
x_random <span class="op">=</span> random_design.get_samples(n_points)</code></pre></div>
<p>Next, we evaluate the high and low fidelity simualtors at those locations.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np
<span class="im">import</span> mountain_car <span class="im">as</span> mc</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">d_position_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))
d_velocity_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))
d_position_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))
d_velocity_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))

<span class="co"># --- Collect high fidelity points</span>
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):
    d_position_hf[i], d_velocity_hf[i] <span class="op">=</span> mc.simulation(x_random[i, :])

<span class="co"># --- Collect low fidelity points  </span>
<span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):
    d_position_lf[i], d_velocity_lf[i] <span class="op">=</span> mc.low_cost_simulation(x_random[i, :])</code></pre></div>
<p>It is time to build the multi-fidelity model for both the position and the velocity.</p>
<p>As we did in the previous section we use the emulator to optimize the simulator. In this case we use the high fidelity output of the emulator.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co">### --- Optimize controller parameters </span>
obj_func <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_simulation(env, x)[<span class="dv">0</span>]
obj_func_emulator <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_emulation([position_model, velocity_model], x, car_initial_location)[<span class="dv">0</span>]
objective_multifidelity <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func)</code></pre></div>
<p>And we optimize using Bayesian optimzation.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)
space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_1&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_2&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},
        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]

design_space <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)
aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)

n_initial_points <span class="op">=</span> <span class="dv">25</span>
random_design <span class="op">=</span> RandomDesign(design_space)
initial_design <span class="op">=</span> random_design.get_samples(n_initial_points)
acquisition <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)
evaluator <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">bo_multifidelity <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective_multifidelity, acquisition, evaluator, initial_design)
bo_multifidelity.run_optimization(max_iter<span class="op">=</span><span class="dv">50</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo_multifidelity.x_opt), render<span class="op">=</span><span class="va">True</span>)
anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller with multi-fidelity emulator&#39;</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</code></pre></div>
<iframe src="../slides/diagrams/uq/mountain_car_multi_fidelity.html" width="1024" height="768" allowtransparency="true" frameborder="0">
</iframe>
<p>And problem solved! We see how the problem is also solved with 250 observations of the high fidelity simulator and 250 of the low fidelity simulator.</p>
<ul>
<li><em>Multi-fidelity emulation</em>: build surrogate models when data is obtained from multiple information sources that have different fidelity and/or cost;</li>
<li><em>Bayesian optimisation</em>: optimise physical experiments and tune parameters of machine learning algorithms;</li>
<li><em>Experimental design/Active learning</em>: design the most informative experiments and perform active learning with machine learning models;</li>
<li><em>Sensitivity analysis</em>: analyse the influence of inputs on the outputs of a given system;</li>
<li><em>Bayesian quadrature</em>: efficiently compute the integrals of functions that are expensive to evaluate.</li>
</ul>
<h3 id="mxfusion">MxFusion</h3>
<table>
<tr>
<td width="70%">
<ul>
<li>Work by Eric Meissner and Zhenwen Dai.</li>
<li>Probabilistic programming.</li>
<li>Available on <a href="https://github.com/amzn/mxfusion">Github</a>
</td>
<td width="30%">
<img class="" src="../slides/diagrams/mxfusion-logo.png" width="" height="auto" align="" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto">
</td>
</tr>
</table></li>
</ul>
<h3 id="mxfusion-1">MxFusion</h3>
<h3 id="why-another-framework">Why another framework?</h3>
<h3 id="key-requirements">Key Requirements</h3>
<p>Specialized inference methods + models, without requiring users to reimplement nor understand them every time. Leverage expert knowledge. Efficient inference, flexible framework. Existing frameworks either did one or the other: flexible, or efficient.</p>
<h3 id="what-does-it-look-like">What does it look like?</h3>
<p><strong>Modelling</strong></p>
<p><strong>Inference</strong></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m <span class="op">=</span> Model()
m.mu <span class="op">=</span> Variable()
m.s <span class="op">=</span> Variable(transformation<span class="op">=</span>PositiveTransformation())
m.Y <span class="op">=</span> Normal.define_variable(mean<span class="op">=</span>m.mu, variance<span class="op">=</span>m.s)</code></pre></div>
<ul>
<li>Variable</li>
<li>Distribution</li>
<li><p>Function</p></li>
<li><code>log_pdf</code></li>
<li><p><code>draw_samples</code></p></li>
<li>Variational Inference</li>
<li><p>MCMC Sampling (<em>soon</em>) Built on MXNet Gluon (imperative code, not static graph)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">infr <span class="op">=</span> GradBasedInference(inference_algorithm<span class="op">=</span>MAP(model<span class="op">=</span>m, observed<span class="op">=</span>[m.Y]))
infr.run(Y<span class="op">=</span>data)</code></pre></div>
<ul>
<li>Model + Inference together form building blocks.
<ul>
<li>Just doing modular modeling with universal inference doesn't really scale, need specialized inference methods for specialized modelling objects like non-parametrics.</li>
</ul></li>
</ul>
<h3 id="long-term-aim">Long term Aim</h3>
<ul>
<li>Simulate/Emulate the components of the system.
<ul>
<li>Validate with real world using multifidelity.</li>
<li>Interpret system using e.g. sensitivity analysis.</li>
</ul></li>
<li>Perform end to end learning to optimize.
<ul>
<li>Maintain interpretability.</li>
</ul></li>
</ul>
<p>Stefanos Eleftheriadis, John Bronskill, Hugh Salimbeni, Rich Turner, Zhenwen Dai, Javier Gonzalez, Andreas Damianou, Mark Pullin.</p>
<ul>
<li>twitter: @lawrennd</li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
<h3 id="references" class="unnumbered">References</h3>
<div id="refs" class="references">
<div id="ref-Alaa:deep2017">
<p>Alaa, Ahmed M., and Mihaela van der Schaar. 2017. “Deep Multi-Task Gaussian Processes for Survival Analysis with Competing Risks.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 2326–34. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6827-deep-multi-task-gaussian-processes-for-survival-analysis-with-competing-risks.pdf" class="uri">http://papers.nips.cc/paper/6827-deep-multi-task-gaussian-processes-for-survival-analysis-with-competing-risks.pdf</a>.</p>
</div>
<div id="ref-Bengio:deep09">
<p>Bengio, Yoshua. 2009. “Learning Deep Architectures for AI.” <em>Found. Trends Mach. Learn.</em> 2 (1). Hanover, MA, USA: Now Publishers Inc.: 1–127. doi:<a href="https://doi.org/10.1561/2200000006">10.1561/2200000006</a>.</p>
</div>
<div id="ref-Thang:unifying17">
<p>Bui, Thang D., Josiah Yan, and Richard E. Turner. 2017. “A Unifying Framework for Gaussian Process Pseudo-Point Approximations Using Power Expectation Propagation.” <em>Journal of Machine Learning Research</em> 18 (104): 1–72. <a href="http://jmlr.org/papers/v18/16-603.html" class="uri">http://jmlr.org/papers/v18/16-603.html</a>.</p>
</div>
<div id="ref-Damianou:thesis2015">
<p>Damianou, Andreas. 2015. “Deep Gaussian Processes and Variational Propagation of Uncertainty.” PhD thesis, University of Sheffield.</p>
</div>
<div id="ref-Dunlop:deep2017">
<p>Dunlop, Matthew M., Mark A. Girolami, Andrew M. Stuart, and Aretha L. Teckentrup. n.d. “How Deep Are Deep Gaussian Processes?” <em>Journal of Machine Learning Research</em> 19 (54): 1–46. <a href="http://jmlr.org/papers/v19/18-015.html" class="uri">http://jmlr.org/papers/v19/18-015.html</a>.</p>
</div>
<div id="ref-Duvenaud:pathologies14">
<p>Duvenaud, David, Oren Rippel, Ryan Adams, and Zoubin Ghahramani. 2014. “Avoiding Pathologies in Very Deep Networks.” In.</p>
</div>
<div id="ref-Hinton:fast06">
<p>Hinton, Geoffrey E., and Simon Osindero. 2006. “A Fast Learning Algorithm for Deep Belief Nets.” <em>Neural Computation</em> 18: 2006.</p>
</div>
<div id="ref-Mattos:recurrent15">
<p>Mattos, César Lincoln C., Zhenwen Dai, Andreas C. Damianou, Jeremy Forth, Guilherme A. Barreto, and Neil D. Lawrence. 2015. “Recurrent Gaussian Processes.” <em>CoRR</em> abs/1511.06644. <a href="http://arxiv.org/abs/1511.06644" class="uri">http://arxiv.org/abs/1511.06644</a>.</p>
</div>
<div id="ref-Perdikaris:multifidelity17">
<p>Perdikaris, P., M. Raissi, A. Damianou, N. D. Lawrence, and G. E. Karniadakis. 2017. “Nonlinear Information Fusion Algorithms for Data-Efficient Multi-Fidelity Modelling.” <em>Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences</em> 473 (2198). The Royal Society. doi:<a href="https://doi.org/10.1098/rspa.2016.0751">10.1098/rspa.2016.0751</a>.</p>
</div>
<div id="ref-Ranganath-survival16">
<p>Ranganath, Rajesh, Adler Perotte, Noémie Elhadad, and David Blei. 2016. “Deep Survival Analysis.” In <em>Proceedings of the 1st Machine Learning for Healthcare Conference</em>, edited by Finale Doshi-Velez, Jim Fackler, David Kale, Byron Wallace, and Jenna Wiens, 56:101–14. Proceedings of Machine Learning Research. Children’s Hospital LA, Los Angeles, CA, USA: PMLR. <a href="http://proceedings.mlr.press/v56/Ranganath16.html" class="uri">http://proceedings.mlr.press/v56/Ranganath16.html</a>.</p>
</div>
<div id="ref-Salakhutdinov:quantitative08">
<p>Salakhutdinov, Ruslan, and Iain Murray. n.d. “On the Quantitative Analysis of Deep Belief Networks.” In, 872–79.</p>
</div>
<div id="ref-Salimbeni:doubly2017">
<p>Salimbeni, Hugh, and Marc Deisenroth. 2017. “Doubly Stochastic Variational Inference for Deep Gaussian Processes.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 4591–4602. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/7045-doubly-stochastic-variational-inference-for-deep-gaussian-processes.pdf" class="uri">http://papers.nips.cc/paper/7045-doubly-stochastic-variational-inference-for-deep-gaussian-processes.pdf</a>.</p>
</div>
<div id="ref-Saul:thesis2016">
<p>Saul, Alan Daniel. 2016. “Gaussian Process Based Approaches for Survival Analysis.” PhD thesis, University of Sheffield.</p>
</div>
<div id="ref-Schulam:counterfactual17">
<p>Schulam, Peter, and Suchi Saria. 2017. “Counterfactual Gaussian Processes for Reliable Decision-Making and What-If Reasoning.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 1696–1706. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6767-counterfactual-gaussian-processes-for-reliable-decision-making-and-what-if-reasoning.pdf" class="uri">http://papers.nips.cc/paper/6767-counterfactual-gaussian-processes-for-reliable-decision-making-and-what-if-reasoning.pdf</a>.</p>
</div>
<div id="ref-Anqi:gpspike2017">
<p>Wu, Anqi, Nicholas G Roy, Stephen Keeley, and Jonathan W Pillow. 2017. “Gaussian Process Based Nonlinear Latent Structure Discovery in Multivariate Spike Train Data.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 3499–3508. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6941-gaussian-process-based-nonlinear-latent-structure-discovery-in-multivariate-spike-train-data.pdf" class="uri">http://papers.nips.cc/paper/6941-gaussian-process-based-nonlinear-latent-structure-discovery-in-multivariate-spike-train-data.pdf</a>.</p>
</div>
</div>


