---
title: "Deep Probabilistic Modelling with with Gaussian Processes"
venue: "NIPS Tutorial 2017"
abstract: "Neural network models are algorithmically simple, but mathematically complex. Gaussian process models are mathematically simple, but algorithmically complex. In this tutorial we will explore Deep Gaussian Process models. They bring advantages in their mathematical simplicity but are challenging in their algorithmic complexity. We will give an overview of Gaussian processes and highlight the algorithmic approximations that allow us to stack Gaussian process models: they are based on variational methods. In the last part of the tutorial will explore a use case exemplar: uncertainty quantification. We end with open questions."
author:
- given: Neil D.
  family: Lawrence
  url: http://inverseprobability.com
  institute: Amazon and University of Sheffield
  twitter: lawrennd
  gscholar: r3SJcvoAAAAJ
  orchid: 
date: 2019-11-30
published: 2019-11-30
reveal: 2019-11-30-deep-probabilistic-modelling-with-gaussian-processes.slides.html
youtube: "NHTGY8VCinY"
layout: talk
categories:
- notes
---


<div style="display:none">
  $${% include talk-notation.tex %}$$
</div>

<script src="/talks/figure-magnify.js"></script>
<script src="/talks/figure-animate.js"></script>
    
<div id="modal-frame" class="modal">
  <span class="close" onclick="closeMagnify()">&times;</span>
  <div class="modal-figure">
    <div class="figure-frame">
      <div class="modal-content" id="modal01"></div>
      <!--<img class="modal-content" id="object01">-->
    </div>
    <div class="caption-frame" id="modal-caption"></div>
  </div>
</div>	  

<!-- Front matter -->
<!-- Front matter -->
<!-- Do not edit this file locally. -->
<!-- Do not edit this file locally. -->
<!---->
<!-- Do not edit this file locally. -->
<!--Back matter-->
<!-- Do not edit this file locally. -->
<!-- The last names to be defined. Should be defined entirely in terms of macros from above-->
<h1 id="what-is-machine-learning-edit">What is Machine Learning? <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/what-is-ml.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/what-is-ml.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h1>
<p>What is machine learning? At its most basic level machine learning is a combination of</p>
<p><br /><span class="math display">$$\text{data} + \text{model} \xrightarrow{\text{compute}} \text{prediction}$$</span><br /></p>
<p>where <em>data</em> is our observations. They can be actively or passively acquired (meta-data). The <em>model</em> contains our assumptions, based on previous experience. That experience can be other data, it can come from transfer learning, or it can merely be our beliefs about the regularities of the universe. In humans our models include our inductive biases. The <em>prediction</em> is an action to be taken or a categorization or a quality score. The reason that machine learning has become a mainstay of artificial intelligence is the importance of predictions in artificial intelligence. The data and the model are combined through computation.</p>
<p>In practice we normally perform machine learning using two functions. To combine data with a model we typically make use of:</p>
<p><strong>a prediction function</strong> a function which is used to make the predictions. It includes our beliefs about the regularities of the universe, our assumptions about how the world works, e.g. smoothness, spatial similarities, temporal similarities.</p>
<p><strong>an objective function</strong> a function which defines the cost of misprediction. Typically it includes knowledge about the world’s generating processes (probabilistic objectives) or the costs we pay for mispredictions (empiricial risk minimization).</p>
<p>The combination of data and model through the prediction function and the objectie function leads to a <em>learning algorithm</em>. The class of prediction functions and objective functions we can make use of is restricted by the algorithms they lead to. If the prediction function or the objective function are too complex, then it can be difficult to find an appropriate learning algorithm. Much of the acdemic field of machine learning is the quest for new learning algorithms that allow us to bring different types of models and data together.</p>
<p>A useful reference for state of the art in machine learning is the UK Royal Society Report, <a href="https://royalsociety.org/~/media/policy/projects/machine-learning/publications/machine-learning-report.pdf">Machine Learning: Power and Promise of Computers that Learn by Example</a>.</p>
<p>You can also check my post blog post on <a href="http://inverseprobability.com/2017/07/17/what-is-machine-learning">What is Machine Learning?</a>..</p>
<p>In practice, we normally also have uncertainty associated with these functions. Uncertainty in the prediction function arises from</p>
<ol type="1">
<li>scarcity of training data and</li>
<li>mismatch between the set of prediction functions we choose and all possible prediction functions.</li>
</ol>
<p>There are also challenges around specification of the objective function, but for we will save those for another day. For the moment, let us focus on the prediction function.</p>
<h2 id="neural-networks-and-prediction-functions-edit">Neural Networks and Prediction Functions <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/neural-networks.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/neural-networks.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Neural networks are adaptive non-linear function models. Originally, they were studied (by McCulloch and Pitts <span class="citation" data-cites="McCulloch:neuron43">(McCulloch and Pitts 1943)</span>) as simple models for neurons, but over the last decade they have become popular because they are a flexible approach to modelling complex data. A particular characteristic of neural network models is that they can be composed to form highly complex functions which encode many of our expectations of the real world. They allow us to encode our assumptions about how the world works.</p>
<p>We will return to composition later, but for the moment, let’s focus on a one hidden layer neural network. We are interested in the prediction function, so we’ll ignore the objective function (which is often called an error function) for the moment, and just describe the mathematical object of interest</p>
<p><br /><span class="math display">$$
\mappingFunction(\inputVector) = \mappingMatrix^\top \activationVector(\mappingMatrixTwo, \inputVector)
$$</span><br /></p>
<p>Where in this case <span class="math inline">$\mappingFunction(\cdot)$</span> is a scalar function with vector inputs, and <span class="math inline">$\activationVector(\cdot)$</span> is a vector function with vector inputs. The dimensionality of the vector function is known as the number of hidden units, or the number of neurons. The elements of this vector function are known as the <em>activation</em> function of the neural network and <span class="math inline">$\mappingMatrixTwo$</span> are the parameters of the activation functions.</p>
<h2 id="relations-with-classical-statistics">Relations with Classical Statistics</h2>
<p>In statistics activation functions are traditionally known as <em>basis functions</em>. And we would think of this as a <em>linear model</em>. It’s doesn’t make linear predictions, but it’s linear because in statistics estimation focuses on the parameters, <span class="math inline">$\mappingMatrix$</span>, not the parameters, <span class="math inline">$\mappingMatrixTwo$</span>. The linear model terminology refers to the fact that the model is <em>linear in the parameters</em>, but it is <em>not</em> linear in the data unless the activation functions are chosen to be linear.</p>
<h2 id="adaptive-basis-functions">Adaptive Basis Functions</h2>
<p>The first difference in the (early) neural network literature to the classical statistical literature is the decision to optimize these parameters, <span class="math inline">$\mappingMatrixTwo$</span>, as well as the parameters, <span class="math inline">$\mappingMatrix$</span> (which would normally be denoted in statistics by <span class="math inline"><strong>β</strong></span>)<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<h2 id="integrated-basis-functions">Integrated Basis Functions</h2>
<p>We’re going to go revisit that decision, and follow the path of Radford Neal <span class="citation" data-cites="Neal:bayesian94">(Neal 1994)</span> who, inspired by work of David MacKay <span class="citation" data-cites="MacKay:bayesian92">(MacKay 1992)</span> and others did his PhD thesis on Bayesian Neural Networks. If we take a Bayesian approach to parameter inference (note I am using inference here in the classical sense, not in the sense of prediction of test data, which seems to be a newer usage), then we don’t wish to fit parameters at all, rather we wish to integrate them away and understand the family of functions that the model describes.</p>
<h2 id="probabilistic-modelling-edit">Probabilistic Modelling <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/probabilistic-modelling.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/probabilistic-modelling.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>This Bayesian approach is designed to deal with uncertainty arising from fitting our prediction function to the data we have, a reduced data set.</p>
<p>The Bayesian approach can be derived from a broader understanding of what our objective is. If we accept that we can jointly represent all things that happen in the world with a probability distribution, then we can interogate that probability to make predictions. So, if we are interested in predictions, <span class="math inline">$\dataScalar_*$</span> at future points input locations of interest, <span class="math inline">$\inputVector_*$</span> given previously training data, <span class="math inline">$\dataVector$</span> and corresponding inputs, <span class="math inline">$\inputMatrix$</span>, then we are really interogating the following probability density, <br /><span class="math display">$$
p(\dataScalar_*|\dataVector, \inputMatrix, \inputVector_*),
$$</span><br /> there is nothing controversial here, as long as you accept that you have a good joint model of the world around you that relates test data to training data, <span class="math inline">$p(\dataScalar_*, \dataVector, \inputMatrix, \inputVector_*)$</span> then this conditional distribution can be recovered through standard rules of probability (<span class="math inline">data + model → prediction</span>).</p>
<p>We can construct this joint density through the use of the following decomposition: <br /><span class="math display">$$
p(\dataScalar_*|\dataVector, \inputMatrix, \inputVector_*) = \int p(\dataScalar_*|\inputVector_*, \mappingMatrix) p(\mappingMatrix | \dataVector, \inputMatrix) \text{d} \mappingMatrix
$$</span><br /></p>
<p>where, for convenience, we are assuming <em>all</em> the parameters of the model are now represented by <span class="math inline">$\parameterVector$</span> (which contains <span class="math inline">$\mappingMatrix$</span> and <span class="math inline">$\mappingMatrixTwo$</span>) and <span class="math inline">$p(\parameterVector | \dataVector, \inputMatrix)$</span> is recognised as the posterior density of the parameters given data and <span class="math inline">$p(\dataScalar_*|\inputVector_*, \parameterVector)$</span> is the <em>likelihood</em> of an individual test data point given the parameters.</p>
<p>The likelihood of the data is normally assumed to be independent across the parameters, <br /><span class="math display">$$
p(\dataVector|\inputMatrix, \mappingMatrix) = \prod_{i=1}^\numData p(\dataScalar_i|\inputVector_i, \mappingMatrix),$$</span><br /></p>
<p>and if that is so, it is easy to extend our predictions across all future, potential, locations, <br /><span class="math display">$$
p(\dataVector_*|\dataVector, \inputMatrix, \inputMatrix_*) = \int p(\dataVector_*|\inputMatrix_*, \parameterVector) p(\parameterVector | \dataVector, \inputMatrix) \text{d} \parameterVector.
$$</span><br /></p>
<p>The likelihood is also where the <em>prediction function</em> is incorporated. For example in the regression case, we consider an objective based around the Gaussian density, <br /><span class="math display">$$
p(\dataScalar_i | \mappingFunction(\inputVector_i)) = \frac{1}{\sqrt{2\pi \dataStd^2}} \exp\left(-\frac{\left(\dataScalar_i - \mappingFunction(\inputVector_i)\right)^2}{2\dataStd^2}\right)
$$</span><br /></p>
<p>In short, that is the classical approach to probabilistic inference, and all approaches to Bayesian neural networks fall within this path. For a deep probabilistic model, we can simply take this one stage further and place a probability distribution over the input locations, <br /><span class="math display">$$
p(\dataVector_*|\dataVector) = \int p(\dataVector_*|\inputMatrix_*, \parameterVector) p(\parameterVector | \dataVector, \inputMatrix) p(\inputMatrix) p(\inputMatrix_*) \text{d} \parameterVector \text{d} \inputMatrix \text{d}\inputMatrix_*
$$</span><br /> and we have <em>unsupervised learning</em> (from where we can get deep generative models).</p>
<h2 id="graphical-models-edit">Graphical Models <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/graphical-models.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/graphical-models.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>One way of representing a joint distribution is to consider conditional dependencies between data. Conditional dependencies allow us to factorize the distribution. For example, a Markov chain is a factorization of a distribution into components that represent the conditional relationships between points that are neighboring, often in time or space. It can be decomposed in the following form. <br /><span class="math display">$$p(\dataVector) = p(\dataScalar_\numData | \dataScalar_{\numData-1}) p(\dataScalar_{\numData-1}|\dataScalar_{\numData-2}) \dots p(\dataScalar_{2} | \dataScalar_{1})$$</span><br /></p>
<div class="figure">
<div id="markov-chain-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/ml/markov.svg" width="50%" style=" ">
</object>
</div>
<div id="markov-chain-magnify" class="magnify" onclick="magnifyFigure(&#39;markov-chain&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="markov-chain-caption" class="caption-frame">
<p>Figure: A Markov chain is a simple form of probabilistic graphical model providing a particular decomposition of the joint density.</p>
</div>
</div>
<p>By specifying conditional independencies we can reduce the parameterization required for our data, instead of directly specifying the parameters of the joint distribution, we can specify each set of parameters of the conditonal independently. This can also give an advantage in terms of interpretability. Understanding a conditional independence structure gives a structured understanding of data. If developed correctly, according to causal methodology, it can even inform how we should intervene in the system to drive a desired result <span class="citation" data-cites="Pearl:causality95">(Pearl 1995)</span>.</p>
<p>However, a challenge arises when the data becomes more complex. Consider the graphical model shown below, used to predict the perioperative risk of <em>C Difficile</em> infection following colon surgery <span class="citation" data-cites="Steele:predictive12">(Steele et al. 2012)</span>.</p>
<div class="figure">
<div id="c-difficile-bayes-net-diagnosis-figure" class="figure-frame">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/bayes-net-diagnosis.png" width="60%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="c-difficile-bayes-net-diagnosis-magnify" class="magnify" onclick="magnifyFigure(&#39;c-difficile-bayes-net-diagnosis&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="c-difficile-bayes-net-diagnosis-caption" class="caption-frame">
<p>Figure: A probabilistic directed graph used to predict the perioperative risk of <em>C Difficile</em> infection following colon surgery. When these models have good predictive performance they are often difficult to interpret. This may be due to the limited representation capability of the conditional densities in the model.</p>
</div>
</div>
<p>To capture the complexity in the interelationship between the data, the graph itself becomes more complex, and less interpretable.</p>
<h2 id="performing-inference">Performing Inference</h2>
<p>As far as combining our data and our model to form our prediction, the devil is in the detail. While everything is easy to write in terms of probability densities, as we move from <span class="math inline">data</span> and <span class="math inline">model</span> to <span class="math inline">prediction</span> there is that simple <span class="math inline">$\xrightarrow{\text{compute}}$</span> sign, which is now burying a wealth of difficulties. Each integral sign above is a high dimensional integral which will typically need approximation. Approximations also come with computational demands. As we consider more complex classes of functions, the challenges around the integrals become harder and prediction of future test data given our model and the data becomes so involved as to be impractical or impossible.</p>
<p>Statisticians realized these challenges early on, indeed, so early that they were actually physicists, both Laplace and Gauss worked on models such as this, in Gauss’s case he made his career on prediction of the location of the lost planet (later reclassified as a asteroid, then dwarf planet), Ceres. Gauss and Laplace made use of maximum a posteriori estimates for simplifying their computations and Laplace developed Laplace’s method (and invented the Gaussian density) to expand around that mode. But classical statistics needs better guarantees around model performance and interpretation, and as a result has focussed more on the <em>linear</em> model implied by <br /><span class="math display">$$
  \mappingFunction(\inputVector) = \left.\mappingVector^{(2)}\right.^\top \activationVector(\mappingMatrix_1, \inputVector)
  $$</span><br /></p>
<p><br /><span class="math display">$$
  \mappingVector^{(2)} \sim \gaussianSamp{\zerosVector}{\covarianceMatrix}.
  $$</span><br /></p>
<p>The Gaussian likelihood given above implies that the data observation is related to the function by noise corruption so we have, <br /><span class="math display">$$
  \dataScalar_i = \mappingFunction(\inputVector_i) + \noiseScalar_i,
  $$</span><br /> where <br /><span class="math display">$$
  \noiseScalar_i \sim \gaussianSamp{0}{\dataStd^2}
  $$</span><br /></p>
<p>and while normally integrating over high dimensional parameter vectors is highly complex, here it is <em>trivial</em>. That is because of a property of the multivariate Gaussian.</p>
<p>Gaussian processes are initially of interest because</p>
<ol type="1">
<li>linear Gaussian models are easier to deal with</li>
<li>Even the parameters <em>within</em> the process can be handled, by considering a particular limit.</li>
</ol>
<p>Let’s first of all review the properties of the multivariate Gaussian distribution that make linear Gaussian models easier to deal with. We’ll return to the, perhaps surprising, result on the parameters within the nonlinearity, <span class="math inline">$\parameterVector$</span>, shortly.</p>
<p>To work with linear Gaussian models, to find the marginal likelihood all you need to know is the following rules. If <br /><span class="math display">$$
\dataVector = \mappingMatrix \inputVector + \noiseVector,
$$</span><br /> where <span class="math inline">$\dataVector$</span>, <span class="math inline">$\inputVector$</span> and <span class="math inline">$\noiseVector$</span> are vectors and we assume that <span class="math inline">$\inputVector$</span> and <span class="math inline">$\noiseVector$</span> are drawn from multivariate Gaussians, <br /><span class="math display">$$
\begin{align}
\inputVector &amp; \sim \gaussianSamp{\meanVector}{\covarianceMatrix}\\
\noiseVector &amp; \sim \gaussianSamp{\zerosVector}{\covarianceMatrixTwo}
\end{align}
$$</span><br /> then we know that <span class="math inline">$\dataVector$</span> is also drawn from a multivariate Gaussian with, <br /><span class="math display">$$
\dataVector \sim \gaussianSamp{\mappingMatrix\meanVector}{\mappingMatrix\covarianceMatrix\mappingMatrix^\top + \covarianceMatrixTwo}.
$$</span><br /></p>
<p>With apprioriately defined covariance, <span class="math inline">$\covarianceMatrixTwo$</span>, this is actually the marginal likelihood for Factor Analysis, or Probabilistic Principal Component Analysis <span class="citation" data-cites="Tipping:probpca99">(Tipping and Bishop 1999)</span>, because we integrated out the inputs (or <em>latent</em> variables they would be called in that case).</p>
<p>However, we are focussing on what happens in models which are non-linear in the inputs, whereas the above would be <em>linear</em> in the inputs. To consider these, we introduce a matrix, called the design matrix. We set each activation function computed at each data point to be <br /><span class="math display">$$
\activationScalar_{i,j} = \activationScalar(\mappingVector^{(1)}_{j}, \inputVector_{i})
$$</span><br /> and define the matrix of activations (known as the <em>design matrix</em> in statistics) to be, <br /><span class="math display">$$
\activationMatrix = 
\begin{bmatrix}
\activationScalar_{1, 1} &amp; \activationScalar_{1, 2} &amp; \dots &amp; \activationScalar_{1, \numHidden} \\
\activationScalar_{1, 2} &amp; \activationScalar_{1, 2} &amp; \dots &amp; \activationScalar_{1, \numData} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\activationScalar_{\numData, 1} &amp; \activationScalar_{\numData, 2} &amp; \dots &amp; \activationScalar_{\numData, \numHidden}
\end{bmatrix}.
$$</span><br /> By convention this matrix always has <span class="math inline">$\numData$</span> rows and <span class="math inline">$\numHidden$</span> columns, now if we define the vector of all noise corruptions, <span class="math inline">$\noiseVector = \left[\noiseScalar_1, \dots \noiseScalar_\numData\right]^\top$</span>.</p>
<p>If we define the prior distribution over the vector <span class="math inline">$\mappingVector$</span> to be Gaussian, <br /><span class="math display">$$
\mappingVector \sim \gaussianSamp{\zerosVector}{\alpha\eye},
$$</span><br /></p>
<p>then we can use rules of multivariate Gaussians to see that, <br /><span class="math display">$$
\dataVector \sim \gaussianSamp{\zerosVector}{\alpha \activationMatrix \activationMatrix^\top + \dataStd^2 \eye}.
$$</span><br /></p>
<p>In other words, our training data is distributed as a multivariate Gaussian, with zero mean and a covariance given by <br /><span class="math display">$$
\kernelMatrix = \alpha \activationMatrix \activationMatrix^\top + \dataStd^2 \eye.
$$</span><br /></p>
<p>This is an <span class="math inline">$\numData \times \numData$</span> size matrix. Its elements are in the form of a function. The maths shows that any element, index by <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span>, is a function <em>only</em> of inputs associated with data points <span class="math inline"><em>i</em></span> and <span class="math inline"><em>j</em></span>, <span class="math inline">$\dataVector_i$</span>, <span class="math inline">$\dataVector_j$</span>. <span class="math inline">$\kernel_{i,j} = \kernel\left(\inputVector_i, \inputVector_j\right)$</span></p>
<p>If we look at the portion of this function associated only with <span class="math inline">$\mappingFunction(\cdot)$</span>, i.e. we remove the noise, then we can write down the covariance associated with our neural network, <br /><span class="math display">$$
\kernel_\mappingFunction\left(\inputVector_i, \inputVector_j\right) = \alpha \activationVector\left(\mappingMatrix_1, \inputVector_i\right)^\top \activationVector\left(\mappingMatrix_1, \inputVector_j\right)
$$</span><br /> so the elements of the covariance or <em>kernel</em> matrix are formed by inner products of the rows of the <em>design matrix</em>.</p>
<h2 id="gaussian-process-edit">Gaussian Process <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/multivariate-gaussian-properties.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/multivariate-gaussian-properties.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>This is the essence of a Gaussian process. Instead of making assumptions about our density over each data point, <span class="math inline">$\dataScalar_i$</span> as i.i.d. we make a joint Gaussian assumption over our data. The covariance matrix is now a function of both the parameters of the activation function, <span class="math inline">$\mappingMatrixTwo$</span>, and the input variables, <span class="math inline">$\inputMatrix$</span>. This comes about through integrating out the parameters of the model, <span class="math inline">$\mappingVector$</span>.</p>
<h2 id="basis-functions">Basis Functions</h2>
<p>We can basically put anything inside the basis functions, and many people do. These can be deep kernels <span class="citation" data-cites="Cho:deep09">(Cho and Saul 2009)</span> or we can learn the parameters of a convolutional neural network inside there.</p>
<p>Viewing a neural network in this way is also what allows us to beform sensible <em>batch</em> normalizations <span class="citation" data-cites="Ioffe:batch15">(Ioffe and Szegedy 2015)</span>.</p>
<h2 id="non-degenerate-gaussian-processes-edit">Non-degenerate Gaussian Processes <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/non-degenerate-gps.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/non-degenerate-gps.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The process described above is degenerate. The covariance function is of rank at most <span class="math inline">$\numHidden$</span> and since the theoretical amount of data could always increase <span class="math inline">$\numData \rightarrow \infty$</span>, the covariance function is not full rank. This means as we increase the amount of data to infinity, there will come a point where we can’t normalize the process because the multivariate Gaussian has the form, <br /><span class="math display">$$
\gaussianDist{\mappingFunctionVector}{\zerosVector}{\kernelMatrix} = \frac{1}{\left(2\pi\right)^{\frac{\numData}{2}}\det{\kernelMatrix}^\frac{1}{2}} \exp\left(-\frac{\mappingFunctionVector^\top\kernelMatrix \mappingFunctionVector}{2}\right)
$$</span><br /> and a non-degenerate kernel matrix leads to <span class="math inline">$\det{\kernelMatrix} = 0$</span> defeating the normalization (it’s equivalent to finding a projection in the high dimensional Gaussian where the variance of the the resulting univariate Gaussian is zero, i.e. there is a null space on the covariance, or alternatively you can imagine there are one or more directions where the Gaussian has become the delta function).</p>
<p>In the machine learning field, it was Radford Neal <span class="citation" data-cites="Neal:bayesian94">(Neal 1994)</span> that realized the potential of the next step. In his 1994 thesis, he was considering Bayesian neural networks, of the type we described above, and in considered what would happen if you took the number of hidden nodes, or neurons, to infinity, i.e. <span class="math inline">$\numHidden \rightarrow \infty$</span>.</p>
<div class="figure">
<div id="neal-infinite-priors-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/neal-infinite-priors.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="neal-infinite-priors-magnify" class="magnify" onclick="magnifyFigure(&#39;neal-infinite-priors&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="neal-infinite-priors-caption" class="caption-frame">
<p>Figure: Page 37 of <a href="http://www.cs.toronto.edu/~radford/ftp/thesis.pdf">Radford Neal’s 1994 thesis</a></p>
</div>
</div>
<p>In loose terms, what Radford considers is what happens to the elements of the covariance function, <br /><span class="math display">$$
  \begin{align*}
  \kernel_\mappingFunction\left(\inputVector_i, \inputVector_j\right) &amp; = \alpha \activationVector\left(\mappingMatrix_1, \inputVector_i\right)^\top \activationVector\left(\mappingMatrix_1, \inputVector_j\right)\\
  &amp; = \alpha \sum_k \activationScalar\left(\mappingVector^{(1)}_k, \inputVector_i\right) \activationScalar\left(\mappingVector^{(1)}_k, \inputVector_j\right)
  \end{align*}
  $$</span><br /> if instead of considering a finite number you sample infinitely many of these activation functions, sampling parameters from a prior density, <span class="math inline">$p(\mappingVectorTwo)$</span>, for each one, <br /><span class="math display">$$
\kernel_\mappingFunction\left(\inputVector_i, \inputVector_j\right) = \alpha \int \activationScalar\left(\mappingVector^{(1)}, \inputVector_i\right) \activationScalar\left(\mappingVector^{(1)}, \inputVector_j\right) p(\mappingVector^{(1)}) \text{d}\mappingVector^{(1)}
$$</span><br /> And that’s not <em>only</em> for Gaussian <span class="math inline">$p(\mappingVectorTwo)$</span>. In fact this result holds for a range of activations, and a range of prior densities because of the <em>central limit theorem</em>.</p>
<p>To write it in the form of a probabilistic program, as long as the distribution for <span class="math inline"><em>ϕ</em><sub><em>i</em></sub></span> implied by this short probabilistic program, <br /><span class="math display">$$
  \begin{align*}
  \mappingVectorTwo &amp; \sim p(\cdot)\\
  \phi_i &amp; = \activationScalar\left(\mappingVectorTwo, \inputVector_i\right), 
  \end{align*}
  $$</span><br /> has finite variance, then the result of taking the number of hidden units to infinity, with appropriate scaling, is also a Gaussian process.</p>
<h2 id="further-reading">Further Reading</h2>
<p>To understand this argument in more detail, I highly recommend reading chapter 2 of Neal’s thesis <span class="citation" data-cites="Neal:bayesian94">(Neal 1994)</span>, which remains easy to read and clear today. Indeed, for readers interested in Bayesian neural networks, both Raford Neal’s and David MacKay’s PhD thesis <span class="citation" data-cites="MacKay:bayesian92">(MacKay 1992)</span> remain essential reading. Both theses embody a clarity of thought, and an ability to weave together threads from different fields that was the business of machine learning in the 1990s. Radford and David were also pioneers in making their software widely available and publishing material on the web.</p>
<h2 id="bayesian-inference-by-rejection-sampling-edit">Bayesian Inference by Rejection Sampling <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gp-intro-very-short.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gp-intro-very-short.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>One view of Bayesian inference is to assume we are given a mechanism for generating samples, where we assume that mechanism is representing on accurate view on the way we believe the world works.</p>
<p>This mechanism is known as our <em>prior</em> belief.</p>
<p>We combine our prior belief with our observations of the real world by discarding all those samples that are inconsistent with our prior. The <em>likelihood</em> defines mathematically what we mean by inconsistent with the prior. The higher the noise level in the likelihood, the looser the notion of consistent.</p>
<p>The samples that remain are considered to be samples from the <em>posterior</em>.</p>
<p>This approach to Bayesian inference is closely related to two sampling techniques known as <em>rejection sampling</em> and <em>importance sampling</em>. It is realized in practice in an approach known as <em>approximate Bayesian computation</em> (ABC) or likelihood-free inference.</p>
<p>In practice, the algorithm is often too slow to be practical, because most samples will be inconsistent with the data and as a result the mechanism has to be operated many times to obtain a few posterior samples.</p>
<p>However, in the Gaussian process case, when the likelihood also assumes Gaussian noise, we can operate this mechanism mathematically, and obtain the posterior density <em>analytically</em>. This is the benefit of Gaussian processes.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">import</span> pods</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="im">from</span> ipywidgets <span class="im">import</span> IntSlider</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;gp_rejection_sample</span><span class="sc">{sample:0&gt;3}</span><span class="st">.png&#39;</span>, </a>
<a class="sourceLine" id="cb2-2" data-line-number="2">                            directory<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp&#39;</span>, </a>
<a class="sourceLine" id="cb2-3" data-line-number="3">                            sample<span class="op">=</span>IntSlider(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>))</a></code></pre></div>
<div class="figure">
<div id="gp-rejection-samples-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/gp/gp_rejection_sample003.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
<div class="centered" style="">
<img class="" src="../slides/diagrams/gp/gp_rejection_sample004.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
<div class="centered" style="">
<img class="" src="../slides/diagrams/gp/gp_rejection_sample005.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="gp-rejection-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;gp-rejection-samples&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gp-rejection-samples-caption" class="caption-frame">
<p>Figure: One view of Bayesian inference is we have a machine for generating samples (the <em>prior</em>), and we discard all samples inconsistent with our data, leaving the samples of interest (the <em>posterior</em>). The Gaussian process allows us to do this analytically.</p>
</div>
</div>
<!-- ### Two Dimensional Gaussian Distribution -->
<!-- include{_ml/includes/two-d-gaussian.md} -->
<h2 id="sampling-a-function-edit">Sampling a Function <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpdistfunc.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpdistfunc.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>We will consider a Gaussian distribution with a particular structure of covariance matrix. We will generate <em>one</em> sample from a 25-dimensional Gaussian density. <br /><span class="math display">$$
\mappingFunctionVector=\left[\mappingFunction_{1},\mappingFunction_{2}\dots \mappingFunction_{25}\right].
$$</span><br /> in the figure below we plot these data on the <span class="math inline"><em>y</em></span>-axis against their <em>indices</em> on the <span class="math inline"><em>x</em></span>-axis.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s Kernel mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s polynomial_cov mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s exponentiated_quadratic mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="im">import</span> pods</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="im">from</span> ipywidgets <span class="im">import</span> IntSlider</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;two_point_sample</span><span class="sc">{sample:0&gt;3}</span><span class="st">.svg&#39;</span>, <span class="st">&#39;../slides/diagrams/gp&#39;</span>, sample<span class="op">=</span>IntSlider(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">8</span>, <span class="dv">1</span>))</a></code></pre></div>
<div class="figure">
<div id="gp-two-point-sample-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/two_point_sample008.svg" width="80%" style=" ">
</object>
</div>
<div id="gp-two-point-sample-1-magnify" class="magnify" onclick="magnifyFigure(&#39;gp-two-point-sample-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gp-two-point-sample-1-caption" class="caption-frame">
<p>Figure: A 25 dimensional correlated random variable (values ploted against index)</p>
</div>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="im">import</span> pods</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="im">from</span> ipywidgets <span class="im">import</span> IntSlider</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;two_point_sample</span><span class="sc">{sample:0&gt;3}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb9-2" data-line-number="2">                            <span class="st">&#39;../slides/diagrams/gp&#39;</span>, </a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                            sample<span class="op">=</span>IntSlider(<span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">1</span>))</a></code></pre></div>
{
<div class="figure">
<div id="two-point-sample-one-two-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/two_point_sample012.svg" width="80%" style=" ">
</object>
</div>
<div id="two-point-sample-one-two-magnify" class="magnify" onclick="magnifyFigure(&#39;two-point-sample-one-two&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="two-point-sample-one-two-caption" class="caption-frame">
<p>Figure: The joint Gaussian over <span class="math inline">$\mappingFunction_1$</span> and <span class="math inline">$\mappingFunction_2$</span> along with the conditional distribution of <span class="math inline">$\mappingFunction_2$</span> given <span class="math inline">$\mappingFunction_1$</span></p>
</div>
</div>
<h2 id="uluru-edit">Uluru <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpdistfunc.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpdistfunc.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="uluru-as-probability-figure" class="figure-frame">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/gp/799px-Uluru_Panorama.jpg" width="" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="uluru-as-probability-magnify" class="magnify" onclick="magnifyFigure(&#39;uluru-as-probability&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="uluru-as-probability-caption" class="caption-frame">
<p>Figure: Uluru, the sacred rock in Australia. If we think of it as a probability density, viewing it from this side gives us one <em>marginal</em> from the density. Figuratively speaking, slicing through the rock would give a conditional density.</p>
</div>
</div>
<p>When viewing these contour plots, I sometimes find it helpful to think of Uluru, the prominent rock formation in Australia. The rock rises above the surface of the plane, just like a probability density rising above the zero line. The rock is three dimensional, but when we view Uluru from the classical position, we are looking at one side of it. This is equivalent to viewing the marginal density.</p>
<p>The joint density can be viewed from above, using contours. The conditional density is equivalent to <em>slicing</em> the rock. Uluru is a holy rock, so this has to be an imaginary slice. Imagine we cut down a vertical plane orthogonal to our view point (e.g. coming across our view point). This would give a profile of the rock, which when renormalized, would give us the conditional distribution, the value of conditioning would be the location of the slice in the direction we are facing.</p>
<h2 id="prediction-with-correlated-gaussians">Prediction with Correlated Gaussians</h2>
<p>Of course in practice, rather than manipulating mountains physically, the advantage of the Gaussian density is that we can perform these manipulations mathematically.</p>
<p>Prediction of <span class="math inline">$\mappingFunction_2$</span> given <span class="math inline">$\mappingFunction_1$</span> requires the <em>conditional density</em>, <span class="math inline">$p(\mappingFunction_2|\mappingFunction_1)$</span>.Another remarkable property of the Gaussian density is that this conditional distribution is <em>also</em> guaranteed to be a Gaussian density. It has the form, <br /><span class="math display">$$
p(\mappingFunction_2|\mappingFunction_1) = \gaussianDist{\mappingFunction_2}{\frac{\kernelScalar_{1, 2}}{\kernelScalar_{1, 1}}\mappingFunction_1}{ \kernelScalar_{2, 2} - \frac{\kernelScalar_{1,2}^2}{\kernelScalar_{1,1}}}
$$</span><br />where we have assumed that the covariance of the original joint density was given by <br /><span class="math display">$$
\kernelMatrix = \begin{bmatrix} \kernelScalar_{1, 1} &amp; \kernelScalar_{1, 2}\\ \kernelScalar_{2, 1} &amp; \kernelScalar_{2, 2}.\end{bmatrix}
$$</span><br /></p>
<p>Using these formulae we can determine the conditional density for any of the elements of our vector <span class="math inline">$\mappingFunctionVector$</span>. For example, the variable <span class="math inline">$\mappingFunction_8$</span> is less correlated with <span class="math inline">$\mappingFunction_1$</span> than <span class="math inline">$\mappingFunction_2$</span>. If we consider this variable we see the conditional density is more diffuse.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="im">import</span> pods</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="im">from</span> ipywidgets <span class="im">import</span> IntSlider</a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;two_point_sample</span><span class="sc">{sample:0&gt;3}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb11-2" data-line-number="2">                            <span class="st">&#39;../slides/diagrams/gp&#39;</span>, </a>
<a class="sourceLine" id="cb11-3" data-line-number="3">                            sample<span class="op">=</span>IntSlider(<span class="dv">13</span>, <span class="dv">13</span>, <span class="dv">17</span>, <span class="dv">1</span>))</a></code></pre></div>
<div class="figure">
<div id="two-point-sample-13-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/two_point_sample013.svg" width="80%" style=" ">
</object>
</div>
<div id="two-point-sample-13-magnify" class="magnify" onclick="magnifyFigure(&#39;two-point-sample-13&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="two-point-sample-13-caption" class="caption-frame">
<p>Figure: Sample from the joint Gaussian model, points indexed by 1 and 8 highlighted.</p>
</div>
</div>
<div class="figure">
<div id="two-point-sample-one-eight-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/two_point_sample017.svg" width="80%" style=" ">
</object>
</div>
<div id="two-point-sample-one-eight-magnify" class="magnify" onclick="magnifyFigure(&#39;two-point-sample-one-eight&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="two-point-sample-one-eight-caption" class="caption-frame">
<p>Figure: The joint Gaussian over <span class="math inline">$\mappingFunction_1$</span> and <span class="math inline">$\mappingFunction_8$</span> along with the conditional distribution of <span class="math inline">$\mappingFunction_8$</span> given <span class="math inline">$\mappingFunction_1$</span></p>
</div>
</div>
<ul>
<li>Covariance function, <span class="math inline">$\kernelMatrix$</span></li>
<li>Determines properties of samples.</li>
<li><p>Function of <span class="math inline">$\inputMatrix$</span>, <br /><span class="math display">$$\kernelScalar_{i,j} = \kernelScalar(\inputVector_i, \inputVector_j)$$</span><br /></p></li>
<li><p>Posterior mean <br /><span class="math display">$$\mappingFunction_D(\inputVector_*) = \kernelVector(\inputVector_*, \inputMatrix) \kernelMatrix^{-1}
\dataVector$$</span><br /></p></li>
<li><p>Posterior covariance <br /><span class="math display">$$\mathbf{C}_* = \kernelMatrix_{*,*} - \kernelMatrix_{*,\mappingFunctionVector}
\kernelMatrix^{-1} \kernelMatrix_{\mappingFunctionVector, *}$$</span><br /></p></li>
<li><p>Posterior mean</p>
<p><br /><span class="math display">$$\mappingFunction_D(\inputVector_*) = \kernelVector(\inputVector_*, \inputMatrix) \boldsymbol{\alpha}$$</span><br /></p></li>
<li><p>Posterior covariance <br /><span class="math display">$$\covarianceMatrix_* = \kernelMatrix_{*,*} - \kernelMatrix_{*,\mappingFunctionVector}
\kernelMatrix^{-1} \kernelMatrix_{\mappingFunctionVector, *}$$</span><br /></p></li>
</ul>
<h2 id="exponentiated-quadratic-covariance-edit">Exponentiated Quadratic Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/eq-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/eq-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The exponentiated quadratic covariance, also known as the Gaussian covariance or the RBF covariance and the squared exponential. Covariance between two points is related to the negative exponential of the squared distnace between those points. This covariance function can be derived in a few different ways: as the infinite limit of a radial basis function neural network, as diffusion in the heat equation, as a Gaussian filter in <em>Fourier space</em> or as the composition as a series of linear filters applied to a base function.</p>
<p>The covariance takes the following form, <br /><span class="math display">$$
\kernelScalar(\inputVector, \inputVector^\prime) = \alpha \exp\left(-\frac{\ltwoNorm{\inputVector-\inputVector^\prime}^2}{2\lengthScale^2}\right)
$$</span><br /> where <span class="math inline">ℓ</span> is the <em>length scale</em> or <em>time scale</em> of the process and <span class="math inline"><em>α</em></span> represents the overall process variance.</p>
<center>
<br /><span class="math display">$$\kernelScalar(\inputVector, \inputVector^\prime) = \alpha \exp\left(-\frac{\ltwoNorm{\inputVector-\inputVector^\prime}^2}{2\lengthScale^2}\right)$$</span><br />
</center>
<div class="figure">
<div id="eq-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/eq_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/eq_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="eq-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;eq-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="eq-covariance-plot-caption" class="caption-frame">
<p>Figure: The exponentiated quadratic covariance function.</p>
</div>
</div>
<h2 id="olympic-marathon-data-edit">Olympic Marathon Data <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/olympic-marathon-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/olympic-marathon-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<table>
<tr>
<td width="70%">
<ul>
<li>Gold medal times for Olympic Marathon since 1896.</li>
<li>Marathons before 1924 didn’t have a standardised distance.</li>
<li>Present results using pace per km.</li>
<li>In 1904 Marathon was badly organised leading to very slow times.</li>
</ul>
</td>
<td width="30%">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/Stephen_Kiprotich.jpg" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
<small>Image from Wikimedia Commons <a href="http://bit.ly/16kMKHQ" class="uri">http://bit.ly/16kMKHQ</a></small>
</td>
</tr>
</table>
<p>The first thing we will do is load a standard data set for regression modelling. The data consists of the pace of Olympic Gold Medal Marathon winners for the Olympics from 1896 to present. First we load in the data and plot.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="im">import</span> pods</a></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" data-line-number="1">data <span class="op">=</span> pods.datasets.olympic_marathon_men()</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">offset <span class="op">=</span> y.mean()</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">scale <span class="op">=</span> np.sqrt(y.var())</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" data-line-number="1"></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">xlim <span class="op">=</span> (<span class="dv">1875</span>,<span class="dv">2030</span>)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">ylim <span class="op">=</span> (<span class="fl">2.5</span>, <span class="fl">6.5</span>)</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">_ <span class="op">=</span> ax.plot(x, y, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">ax.set_xlabel(<span class="st">&#39;year&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">ax.set_ylabel(<span class="st">&#39;pace min/km&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">mlai.write_figure(figure<span class="op">=</span>fig, </a>
<a class="sourceLine" id="cb15-14" data-line-number="14">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/datasets/olympic-marathon.svg&#39;</span>, </a>
<a class="sourceLine" id="cb15-15" data-line-number="15">                  transparent<span class="op">=</span><span class="va">True</span>, </a>
<a class="sourceLine" id="cb15-16" data-line-number="16">                  frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="olympic-marathon-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/olympic-marathon.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-caption" class="caption-frame">
<p>Figure: Olympic marathon pace times since 1892.</p>
</div>
</div>
<p>Things to notice about the data include the outlier in 1904, in this year, the olympics was in St Louis, USA. Organizational problems and challenges with dust kicked up by the cars following the race meant that participants got lost, and only very few participants completed.</p>
<p>More recent years see more consistently quick marathons.</p>
<h2 id="alan-turing-edit">Alan Turing <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/alan-turing-marathon.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/alan-turing-marathon.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="turing-run-times-figure" class="figure-frame">
<table>
<tr>
<td width="50%">
<div class="centered" style="">
<img class="" src="../slides/diagrams/turing-times.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
<td width="50%">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/turing-run.jpg" width="50%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="turing-run-times-magnify" class="magnify" onclick="magnifyFigure(&#39;turing-run-times&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="turing-run-times-caption" class="caption-frame">
<p>Figure: Alan Turing, in 1946 he was only 11 minutes slower than the winner of the 1948 games. Would he have won a hypothetical games held in 1946? Source: <a href="http://www.turing.org.uk/scrapbook/run.html">Alan Turing Internet Scrapbook</a>.</p>
</div>
</div>
<p>If we had to summarise the objectives of machine learning in one word, a very good candidate for that word would be <em>generalization</em>. What is generalization? From a human perspective it might be summarised as the ability to take lessons learned in one domain and apply them to another domain. If we accept the definition given in the first session for machine learning, <br /><span class="math display">$$
\text{data} + \text{model} \xrightarrow{\text{compute}} \text{prediction}
$$</span><br /> then we see that without a model we can’t generalise: we only have data. Data is fine for answering very specific questions, like “Who won the Olympic Marathon in 2012?”, because we have that answer stored, however, we are not given the answer to many other questions. For example, Alan Turing was a formidable marathon runner, in 1946 he ran a time 2 hours 46 minutes (just under four minutes per kilometer, faster than I and most of the other <a href="http://www.parkrun.org.uk/sheffieldhallam/">Endcliffe Park Run</a> runners can do 5 km). What is the probability he would have won an Olympics if one had been held in 1946?</p>
<p>To answer this question we need to generalize, but before we formalize the concept of generalization let’s introduce some formal representation of what it means to generalize in machine learning.</p>
<p>Our first objective will be to perform a Gaussian process fit to the data, we’ll do this using the <a href="https://github.com/SheffieldML/GPy">GPy software</a>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="im">import</span> GPy</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<p>The first command sets up the model, then <code>m_full.optimize()</code> optimizes the parameters of the covariance function and the noise level of the model. Once the fit is complete, we’ll try creating some test points, and computing the output of the GP model in terms of the mean and standard deviation of the posterior functions between 1870 and 2030. We plot the mean function and the standard deviation at 200 locations. We can obtain the predictions using <code>y_mean, y_var = m_full.predict(xt)</code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" data-line-number="1">xt <span class="op">=</span> np.linspace(<span class="dv">1870</span>,<span class="dv">2030</span>,<span class="dv">200</span>)[:,np.newaxis]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">yt_mean, yt_var <span class="op">=</span> m_full.predict(xt)</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">yt_sd<span class="op">=</span>np.sqrt(yt_var)</a></code></pre></div>
<p>Now we plot the results using the helper function in <code>teaching_plots</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">plot.model_output(m_full, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;year&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;pace min/km&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/olympic-marathon-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb20-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="olympic-marathon-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/olympic-marathon-gp.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the Olympic Marathon data. The error bars are too large, perhaps due to the outlier from 1904.</p>
</div>
</div>
<h2 id="fit-quality">Fit Quality</h2>
<p>In the fit we see that the error bars (coming mainly from the noise variance) are quite large. This is likely due to the outlier point in 1904, ignoring that point we can see that a tighter fit is obtained. To see this making a version of the model, <code>m_clean</code>, where that point is removed.</p>
<pre><code>x_clean=np.vstack((x[0:2, :], x[3:, :]))
y_clean=np.vstack((y[0:2, :], y[3:, :]))

m_clean = GPy.models.GPRegression(x_clean,y_clean)
_ = m_clean.optimize()</code></pre>
<p>Can we determine covariance parameters from the data?</p>
<p><br /><span class="math display">$$\gaussianDist{\dataVector}{\mathbf{0}}{\kernelMatrix}=\frac{1}{(2\pi)^\frac{\numData}{2}{\det{\kernelMatrix}^{\frac{1}{2}}}}{\exp\left(-\frac{\dataVector^{\top}\kernelMatrix^{-1}\dataVector}{2}\right)}$$</span><br /></p>
<p><br /><span class="math display">$$\begin{aligned}
    \gaussianDist{\dataVector}{\mathbf{0}}{\kernelMatrix}=\frac{1}{(2\pi)^\frac{\numData}{2}{\color{black} \det{\kernelMatrix}^{\frac{1}{2}}}}{\color{black}\exp\left(-\frac{\dataVector^{\top}\kernelMatrix^{-1}\dataVector}{2}\right)}
\end{aligned}
$$</span><br /></p>
<p><br /><span class="math display">$$
\begin{aligned}
    \log \gaussianDist{\dataVector}{\mathbf{0}}{\kernelMatrix}=&amp;{\color{black}-\frac{1}{2}\log\det{\kernelMatrix}}{\color{black}-\frac{\dataVector^{\top}\kernelMatrix^{-1}\dataVector}{2}} \\ &amp;-\frac{\numData}{2}\log2\pi
\end{aligned}
$$</span><br /></p>
<p><br /><span class="math display">$$
\errorFunction(\parameterVector) = {\color{black} \frac{1}{2}\log\det{\kernelMatrix}} + {\color{black} \frac{\dataVector^{\top}\kernelMatrix^{-1}\dataVector}{2}}
$$</span><br /></p>
<p>The parameters are <em>inside</em> the covariance function (matrix).  <br /><span class="math display">$$\kernelScalar_{i, j} = \kernelScalar(\inputVals_i, \inputVals_j; \parameterVector)$$</span><br /></p>
<p><span> <br /><span class="math display">$$\kernelMatrix = \rotationMatrix \eigenvalueMatrix^2 \rotationMatrix^\top$$</span><br /></span></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" data-line-number="1">gpoptimizePlot1</a></code></pre></div>
<table>
<tr>
<td width="50%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/gp/gp-optimize-eigen.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
<td width="50%">
<span class="math inline">$\eigenvalueMatrix$</span> represents distance on axes. <span class="math inline">$\rotationMatrix$</span> gives rotation.
</td>
</tr>
</table>
<ul>
<li><span class="math inline">$\eigenvalueMatrix$</span> is <em>diagonal</em>, <span class="math inline">$\rotationMatrix^\top\rotationMatrix = \eye$</span>.</li>
<li>Useful representation since <span class="math inline">$\det{\kernelMatrix} = \det{\eigenvalueMatrix^2} = \det{\eigenvalueMatrix}^2$</span>.</li>
</ul>
<!--
\only<1>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant1}}\only<2>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant2}}\only<3>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant3}}\only<4>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant4}}\only<5>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant5}}\only<6>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant6}}\only<7>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant7}}\only<8>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant8}}\only<9>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant9}}\only<10>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseDeterminant10}}-->
<!--```{.python}
gpoptimizePlot3
```

\only<1>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseQuadratic1}}\only<2>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseQuadratic2}}\only<3>{\inputdiagram{../../../gp/tex/diagrams/gpOptimiseQuadratic3}}-->
<div class="figure">
<div id="gp-optimise-figure" class="figure-frame">
<table>
<tr>
<td width="50%">
<object class="svgplot " data="../slides/diagrams/gp/gp-optimise006.svg" width="100%" style=" ">
</object>
</td>
<td width="50%">
<object class="svgplot " data="../slides/diagrams/gp/gp-optimise010.svg" width="100%" style=" ">
</object>
</td>
</tr>
</table>
<table>
<tr>
<td width="50%">
<object class="svgplot " data="../slides/diagrams/gp/gp-optimise016.svg" width="100%" style=" ">
</object>
</td>
<td width="50%">
<object class="svgplot " data="../slides/diagrams/gp/gp-optimise021.svg" width="100%" style=" ">
</object>
</td>
</tr>
</table>
</div>
<div id="gp-optimise-magnify" class="magnify" onclick="magnifyFigure(&#39;gp-optimise&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gp-optimise-caption" class="caption-frame">
<p>Figure: Variation in the data fit term, the capacity term and the negative log likelihood for different lengthscales.</p>
</div>
</div>
<h2 id="gene-expression-example-edit">Gene Expression Example <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/della-gatta-gene-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/della-gatta-gene-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>We now consider an example in gene expression. Gene expression is the measurement of mRNA levels expressed in cells. These mRNA levels show which genes are ‘switched on’ and producing data. In the example we will use a Gaussian process to determine whether a given gene is active, or we are merely observing a noise response.</p>
<h2 id="della-gatta-gene-data-edit">Della Gatta Gene Data <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/della-gatta-gene-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/della-gatta-gene-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<ul>
<li>Given given expression levels in the form of a time series from <span class="citation" data-cites="DellaGatta:direct08">Della Gatta et al. (2008)</span>.</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="im">import</span> pods</a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb24-1" data-line-number="1">data <span class="op">=</span> pods.datasets.della_gatta_TRP63_gene_expression(data_set<span class="op">=</span><span class="st">&#39;della_gatta&#39;</span>,gene_number<span class="op">=</span><span class="dv">937</span>)</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</a>
<a class="sourceLine" id="cb24-5" data-line-number="5"></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">offset <span class="op">=</span> y.mean()</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">scale <span class="op">=</span> np.sqrt(y.var())</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb26-1" data-line-number="1"></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">xlim <span class="op">=</span> (<span class="op">-</span><span class="dv">20</span>,<span class="dv">260</span>)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">ylim <span class="op">=</span> (<span class="dv">5</span>, <span class="fl">7.5</span>)</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</a>
<a class="sourceLine" id="cb26-5" data-line-number="5"></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">_ <span class="op">=</span> ax.plot(x, y, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">ax.set_xlabel(<span class="st">&#39;time/min&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">ax.set_ylabel(<span class="st">&#39;expression&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb26-12" data-line-number="12"></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">mlai.write_figure(figure<span class="op">=</span>fig, </a>
<a class="sourceLine" id="cb26-14" data-line-number="14">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/datasets/della-gatta-gene.svg&#39;</span>, </a>
<a class="sourceLine" id="cb26-15" data-line-number="15">                  transparent<span class="op">=</span><span class="va">True</span>, </a>
<a class="sourceLine" id="cb26-16" data-line-number="16">                  frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="della-gatta-gene-data-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/della-gatta-gene.svg" width="80%" style=" ">
</object>
</div>
<div id="della-gatta-gene-data-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-data&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-data-caption" class="caption-frame">
<p>Figure: Gene expression levels over time for a gene from data provided by <span class="citation" data-cites="DellaGatta:direct08">Della Gatta et al. (2008)</span>. We would like to understand whethere there is signal in the data, or we are only observing noise.</p>
</div>
</div>
<ul>
<li>Want to detect if a gene is expressed or not, fit a GP to each gene <span class="citation" data-cites="Kalaitzis:simple11">Kalaitzis and Lawrence (2011)</span>.</li>
</ul>
<div class="figure">
<div id="a-simple-approach-to-ranking-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/health/1471-2105-12-180_1.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="a-simple-approach-to-ranking-magnify" class="magnify" onclick="magnifyFigure(&#39;a-simple-approach-to-ranking&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="a-simple-approach-to-ranking-caption" class="caption-frame">
<p>Figure: The example is taken from the paper “A Simple Approach to Ranking Differentially Expressed Gene Expression Time Courses through Gaussian Process Regression.” <span class="citation" data-cites="Kalaitzis:simple11">Kalaitzis and Lawrence (2011)</span>.</p>
</div>
</div>
<center>
<a href="http://www.biomedcentral.com/1471-2105/12/180" class="uri">http://www.biomedcentral.com/1471-2105/12/180</a>
</center>
<p>Our first objective will be to perform a Gaussian process fit to the data, we’ll do this using the <a href="https://github.com/SheffieldML/GPy">GPy software</a>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="im">import</span> GPy</a></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb28-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">m_full.kern.lengthscale<span class="op">=</span><span class="dv">50</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<p>Initialize the length scale parameter (which here actually represents a <em>time scale</em> of the covariance function) to a reasonable value. Default would be 1, but here we set it to 50 minutes, given points are arriving across zero to 250 minutes.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb29-1" data-line-number="1">xt <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">20</span>,<span class="dv">260</span>,<span class="dv">200</span>)[:,np.newaxis]</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">yt_mean, yt_var <span class="op">=</span> m_full.predict(xt)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">yt_sd<span class="op">=</span>np.sqrt(yt_var)</a></code></pre></div>
<p>Now we plot the results using the helper function in <code>teaching_plots</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb31-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">plot.model_output(m_full, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time/min&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;expression&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb31-3" data-line-number="3">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">ax.set_title(<span class="st">&#39;log likelihood: </span><span class="sc">{ll:.3}</span><span class="st">&#39;</span>.<span class="bu">format</span>(ll<span class="op">=</span>m_full.log_likelihood()), fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/della-gatta-gene-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb31-8" data-line-number="8">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="della-gatta-gene-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/della-gatta-gene-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="della-gatta-gene-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-gp-caption" class="caption-frame">
<p>Figure: Result of the fit of the Gaussian process model with the time scale parameter initialized to 50 minutes.</p>
</div>
</div>
<p>Now we try a model initialized with a longer length scale.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb32-1" data-line-number="1">m_full2 <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2">m_full2.kern.lengthscale<span class="op">=</span><span class="dv">2000</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">_ <span class="op">=</span> m_full2.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb34-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb34-2" data-line-number="2">plot.model_output(m_full2, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time/min&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;expression&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb34-5" data-line-number="5">ax.set_title(<span class="st">&#39;log likelihood: </span><span class="sc">{ll:.3}</span><span class="st">&#39;</span>.<span class="bu">format</span>(ll<span class="op">=</span>m_full2.log_likelihood()), fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb34-7" data-line-number="7">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/della-gatta-gene-gp2.svg&#39;</span>, </a>
<a class="sourceLine" id="cb34-8" data-line-number="8">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="della-gatta-gene-gp2-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/della-gatta-gene-gp2.svg" width="80%" style=" ">
</object>
</div>
<div id="della-gatta-gene-gp2-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-gp2&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-gp2-caption" class="caption-frame">
<p>Figure: Result of the fit of the Gaussian process model with the time scale parameter initialized to 2000 minutes.</p>
</div>
</div>
<p>Now we try a model initialized with a lower noise.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb35-1" data-line-number="1">m_full3 <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb35-2" data-line-number="2">m_full3.kern.lengthscale<span class="op">=</span><span class="dv">20</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3">m_full3.likelihood.variance<span class="op">=</span><span class="fl">0.001</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">_ <span class="op">=</span> m_full3.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="sourceCode" id="cb37"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb37-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb37-2" data-line-number="2">plot.model_output(m_full3, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time/min&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;expression&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">ax.set_title(<span class="st">&#39;log likelihood: </span><span class="sc">{ll:.3}</span><span class="st">&#39;</span>.<span class="bu">format</span>(ll<span class="op">=</span>m_full3.log_likelihood()), fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb37-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/della-gatta-gene-gp3.svg&#39;</span>, </a>
<a class="sourceLine" id="cb37-8" data-line-number="8">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="della-gatta-gene-gp3-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/della-gatta-gene-gp3.svg" width="80%" style=" ">
</object>
</div>
<div id="della-gatta-gene-gp3-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-gp3&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-gp3-caption" class="caption-frame">
<p>Figure: Result of the fit of the Gaussian process model with the noise initialized low (standard deviation 0.1) and the time scale parameter initialized to 20 minutes.</p>
</div>
</div>
<div class="figure">
<div id="gp-multiple-optima000-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/multiple-optima000.svg" width="50%" style=" ">
</object>
</div>
<div id="gp-multiple-optima000-magnify" class="magnify" onclick="magnifyFigure(&#39;gp-multiple-optima000&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gp-multiple-optima000-caption" class="caption-frame">
<p>Figure:</p>
</div>
</div>
<!--

<object class="svgplot " data="../slides/diagrams/gp/multiple-optima001.svg" width="" style=" "></object>-->
<h2 id="example-prediction-of-malaria-incidence-in-uganda-edit">Example: Prediction of Malaria Incidence in Uganda <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_health/includes/malaria-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_health/includes/malaria-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p><span style="text-align:right"><img class="" src="../slides/diagrams/people/2013_03_28_180606.JPG" width="1.5cm" style="background:none; border:none; box-shadow:none; position:absolute; clip:rect(2662px,1780px,1110px,600px);vertical-align:middle"></span></p>
<p>As an example of using Gaussian process models within the full pipeline from data to decsion, we’ll consider the prediction of Malaria incidence in Uganda. For the purposes of this study malaria reports come in two forms, HMIS reports from health centres and Sentinel data, which is curated by the WHO. There are limited sentinel sites and many HMIS sites.</p>
<p>The work is from Ricardo Andrade Pacheco’s PhD thesis, completed in collaboration with John Quinn and Martin Mubangizi <span class="citation" data-cites="Andrade:consistent14 Mubangizi:malaria14">(Andrade-Pacheco et al. 2014; Mubangizi et al. 2014)</span>. John and Martin were initally from the AI-DEV group from the University of Makerere in Kampala and more latterly they were based at UN Global Pulse in Kampala.</p>
<p>Malaria data is spatial data. Uganda is split into districts, and health reports can be found for each district. This suggests that models such as conditional random fields could be used for spatial modelling, but there are two complexities with this. First of all, occasionally districts split into two. Secondly, sentinel sites are a specific location within a district, such as Nagongera which is a sentinel site based in the Tororo district.</p>
<div class="figure">
<div id="uganda-districts-2006-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/health/uganda-districts-2006.png" width="50%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="uganda-districts-2006-magnify" class="magnify" onclick="magnifyFigure(&#39;uganda-districts-2006&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="uganda-districts-2006-caption" class="caption-frame">
<p>Figure: Ugandan districs. Data SRTM/NASA from <a href="https://dds.cr.usgs.gov/srtm/version2_1" class="uri">https://dds.cr.usgs.gov/srtm/version2_1</a>.</p>
</div>
</div>
<p><span style="text-align:right"><span class="citation" data-cites="Andrade:consistent14 Mubangizi:malaria14">(Andrade-Pacheco et al. 2014; Mubangizi et al. 2014)</span></span></p>
<div class="figure">
<div id="kapchorwa-district-in-uganda-figure" class="figure-frame">
<object class width="50%" data="../slides/diagrams/health/Kapchorwa_District_in_Uganda.svg">
</object>
</div>
<div id="kapchorwa-district-in-uganda-magnify" class="magnify" onclick="magnifyFigure(&#39;kapchorwa-district-in-uganda&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="kapchorwa-district-in-uganda-caption" class="caption-frame">
<p>Figure: The Kapchorwa District, home district of Stephen Kiprotich.</p>
</div>
</div>
<p>Stephen Kiprotich, the 2012 gold medal winner from the London Olympics, comes from Kapchorwa district, in eastern Uganda, near the border with Kenya.</p>
<p>The common standard for collecting health data on the African continent is from the Health management information systems (HMIS). However, this data suffers from missing values <span class="citation" data-cites="Gething:hmis06">(Gething et al. 2006)</span> and diagnosis of diseases like typhoid and malaria may be confounded.</p>
<div class="figure">
<div id="tororo-district-in-uganda-figure" class="figure-frame">
<object class width="50%" data="../slides/diagrams/health/Tororo_District_in_Uganda.svg">
</object>
</div>
<div id="tororo-district-in-uganda-magnify" class="magnify" onclick="magnifyFigure(&#39;tororo-district-in-uganda&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="tororo-district-in-uganda-caption" class="caption-frame">
<p>Figure: The Tororo district, where the sentinel site, Nagongera, is located.</p>
</div>
</div>
<p><a href="https://www.who.int/immunization/monitoring_surveillance/burden/vpd/surveillance_type/sentinel/en/">World Health Organization Sentinel Surveillance systems</a> are set up “when high-quality data are needed about a particular disease that cannot be obtained through a passive system”. Several sentinel sites give accurate assessment of malaria disease levels in Uganda, including a site in Nagongera.</p>
<div class="figure">
<div id="sentinel-nagongera-figure" class="figure-frame">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/health/sentinel_nagongera.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="sentinel-nagongera-magnify" class="magnify" onclick="magnifyFigure(&#39;sentinel-nagongera&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sentinel-nagongera-caption" class="caption-frame">
<p>Figure: Sentinel and HMIS data along with rainfall and temperature for the Nagongera sentinel station in the Tororo district.</p>
</div>
</div>
<p>In collaboration with the AI Research Group at Makerere we chose to investigate whether Gaussian process models could be used to assimilate information from these two different sources of disease informaton. Further, we were interested in whether local information on rainfall and temperature could be used to improve malaria estimates.</p>
<p>The aim of the project was to use WHO Sentinel sites, alongside rainfall and temperature, to improve predictions from HMIS data of levels of malaria.</p>
<div class="figure">
<div id="mubende-district-in-uganda-figure" class="figure-frame">
<object class width="50%" data="../slides/diagrams/health/Mubende_District_in_Uganda.svg">
</object>
</div>
<div id="mubende-district-in-uganda-magnify" class="magnify" onclick="magnifyFigure(&#39;mubende-district-in-uganda&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mubende-district-in-uganda-caption" class="caption-frame">
<p>Figure: The Mubende District.</p>
</div>
</div>
<div class="figure">
<div id="malaria-prediction-mubende-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/health/mubende.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="malaria-prediction-mubende-magnify" class="magnify" onclick="magnifyFigure(&#39;malaria-prediction-mubende&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="malaria-prediction-mubende-caption" class="caption-frame">
<p>Figure: Prediction of malaria incidence in Mubende.</p>
</div>
</div>
<div class="figure">
<div id="-figure" class="figure-frame">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/gpss/1157497_513423392066576_1845599035_n.jpg" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="-magnify" class="magnify" onclick="magnifyFigure(&#39;&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="-caption" class="caption-frame">
<p>Figure: The project arose out of the Gaussian process summer school held at Makerere in Kampala in 2013. The school led, in turn, to the Data Science Africa initiative.</p>
</div>
</div>
<h2 id="early-warning-systems">Early Warning Systems</h2>
<div class="figure">
<div id="kabarole-district-in-uganda-figure" class="figure-frame">
<object class width="50%" data="../slides/diagrams/health/Kabarole_District_in_Uganda.svg">
</object>
</div>
<div id="kabarole-district-in-uganda-magnify" class="magnify" onclick="magnifyFigure(&#39;kabarole-district-in-uganda&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="kabarole-district-in-uganda-caption" class="caption-frame">
<p>Figure: The Kabarole district in Uganda.</p>
</div>
</div>
<div class="figure">
<div id="kabarole-disease-over-time-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/health/kabarole.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="kabarole-disease-over-time-magnify" class="magnify" onclick="magnifyFigure(&#39;kabarole-disease-over-time&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="kabarole-disease-over-time-caption" class="caption-frame">
<p>Figure: Estimate of the current disease situation in the Kabarole district over time. Estimate is constructed with a Gaussian process with an additive covariance funciton.</p>
</div>
</div>
<p>Health monitoring system for the Kabarole district. Here we have fitted the reports with a Gaussian process with an additive covariance function. It has two components, one is a long time scale component (in red above) the other is a short time scale component (in blue).</p>
<p>Monitoring proceeds by considering two aspects of the curve. Is the blue line (the short term report signal) above the red (which represents the long term trend? If so we have higher than expected reports. If this is the case <em>and</em> the gradient is still positive (i.e. reports are going up) we encode this with a <em>red</em> color. If it is the case and the gradient of the blue line is negative (i.e. reports are going down) we encode this with an <em>amber</em> color. Conversely, if the blue line is below the red <em>and</em> decreasing, we color <em>green</em>. On the other hand if it is below red but increasing, we color <em>yellow</em>.</p>
<p>This gives us an early warning system for disease. Red is a bad situation getting worse, amber is bad, but improving. Green is good and getting better and yellow good but degrading.</p>
<p>Finally, there is a gray region which represents when the scale of the effect is small.</p>
<div class="figure">
<div id="early-warning-system-map-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/health/monitor.gif" width="50%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="early-warning-system-map-magnify" class="magnify" onclick="magnifyFigure(&#39;early-warning-system-map&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="early-warning-system-map-caption" class="caption-frame">
<p>Figure: The map of Ugandan districts with an overview of the Malaria situation in each district.</p>
</div>
</div>
<p>These colors can now be observed directly on a spatial map of the districts to give an immediate impression of the current status of the disease across the country.</p>
<h2 id="additive-covariance-edit">Additive Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/add-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/add-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>An additive covariance function is derived from considering the result of summing two Gaussian processes together. If the first Gaussian process is <span class="math inline"><em>g</em>( ⋅ )</span>, governed by covariance <span class="math inline">$\kernelScalar_g(\cdot, \cdot)$</span> and the second process is <span class="math inline"><em>h</em>( ⋅ )</span>, governed by covariance <span class="math inline">$\kernelScalar_h(\cdot, \cdot)$</span> then the combined process <span class="math inline"><em>f</em>( ⋅ ) = <em>g</em>( ⋅ ) + <em>h</em>( ⋅ )</span> is govererned by a covariance function, <br /><span class="math display">$$
\kernelScalar_f(\inputVector, \inputVector^\prime) = \kernelScalar_g(\inputVector, \inputVector^\prime) + \kernelScalar_h(\inputVector, \inputVector^\prime)
$$</span><br /></p>
<center>
<br /><span class="math display">$$\kernelScalar_f(\inputVector, \inputVector^\prime) = \kernelScalar_g(\inputVector, \inputVector^\prime) + \kernelScalar_h(\inputVector, \inputVector^\prime)$$</span><br />
</center>
<div class="figure">
<div id="add-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/add_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/add_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="add-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;add-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="add-covariance-plot-caption" class="caption-frame">
<p>Figure: An additive covariance function formed by combining two exponentiated quadratic covariance functions.</p>
</div>
</div>
<h2 id="analysis-of-us-birth-rates-edit">Analysis of US Birth Rates <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/bda-forecasting.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/bda-forecasting.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="bialik-friday-the-13th-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/ml/bialik-fridaythe13th-1.png" width="70%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="bialik-friday-the-13th-magnify" class="magnify" onclick="magnifyFigure(&#39;bialik-friday-the-13th&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="bialik-friday-the-13th-caption" class="caption-frame">
<p>Figure: This is a retrospective analysis of US births by Aki Vehtari. The challenges of forecasting. Even with seasonal and weekly effects removed there are significant effects on holidays, weekends, etc.</p>
</div>
</div>
<p>There’s a nice analysis of US birth rates by Gaussian processes with additive covariances in <span class="citation" data-cites="Gelman:bayesian13">Gelman et al. (2013)</span>. A combination of covariance functions are used to take account of weekly and yearly trends. The analysis is summarized on the cover of the book.</p>
<div class="figure">
<div id="bayesian-data-analysis-figure" class="figure-frame">
<table>
<tr>
<td width="50%">
<div class="centered" style="">
<img class="" src="../slides/diagrams/ml/bda_cover_1.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
<td width="50%">
<div class="centered" style="">
<img class="" src="../slides/diagrams/ml/bda_cover.png" width="80%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="bayesian-data-analysis-magnify" class="magnify" onclick="magnifyFigure(&#39;bayesian-data-analysis&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="bayesian-data-analysis-caption" class="caption-frame">
<p>Figure: Two different editions of Bayesian Data Analysis <span class="citation" data-cites="Gelman:bayesian13">(Gelman et al. 2013)</span>.</p>
</div>
</div>
<h2 id="basis-function-covariance-edit">Basis Function Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/basis-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/basis-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The fixed basis function covariance just comes from the properties of a multivariate Gaussian, if we decide <br /><span class="math display">$$
\mappingFunctionVector=\basisMatrix\mappingVector
$$</span><br /> and then we assume <br /><span class="math display">$$
\mappingVector \sim \gaussianSamp{\zerosVector}{\alpha\eye}
$$</span><br /> then it follows from the properties of a multivariate Gaussian that <br /><span class="math display">$$
\mappingFunctionVector \sim \gaussianSamp{\zerosVector}{\alpha\basisMatrix\basisMatrix^\top}
$$</span><br /> meaning that the vector of observations from the function is jointly distributed as a Gaussian process and the covariance matrix is <span class="math inline">$\kernelMatrix = \alpha\basisMatrix \basisMatrix^\top$</span>, each element of the covariance matrix can then be found as the inner product between two rows of the basis funciton matrix.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s basis_cov mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s radial mlai.py</a></code></pre></div>
<center>
<br /><span class="math display">$$\kernel(\inputVector, \inputVector^\prime) = \basisVector(\inputVector)^\top \basisVector(\inputVector^\prime)$$</span><br />
</center>
<div class="figure">
<div id="basis-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/basis_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/basis_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="basis-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;basis-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="basis-covariance-plot-caption" class="caption-frame">
<p>Figure: A covariance function based on a non-linear basis given by <span class="math inline">$\basisVector(\inputVector)$</span>.</p>
</div>
</div>
<h2 id="brownian-covariance-edit">Brownian Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/brownian-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/brownian-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb40"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s brownian_cov mlai.py</a></code></pre></div>
<p>Brownian motion is also a Gaussian process. It follows a Gaussian random walk, with diffusion occuring at each time point driven by a Gaussian input. This implies it is both Markov and Gaussian. The covariance function for Brownian motion has the form <br /><span class="math display">$$
\kernelScalar(t, t^\prime)=\alpha \min(t, t^\prime)
$$</span><br /></p>
<center>
<br /><span class="math display">$$\kernelScalar(t, t^\prime)=\alpha \min(t, t^\prime)$$</span><br />
</center>
<div class="figure">
<div id="brownian-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/brownian_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/brownian_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="brownian-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;brownian-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="brownian-covariance-plot-caption" class="caption-frame">
<p>Figure: Brownian motion covariance function.</p>
</div>
</div>
<h2 id="mlp-covariance-edit">MLP Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/mlp-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/mlp-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb41"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s mlp_cov mlai.py</a></code></pre></div>
<p>The multi-layer perceptron (MLP) covariance, also known as the neural network covariance or the arcsin covariance, is derived by considering the infinite limit of a neural network.</p>
<center>
<br /><span class="math display">$$\kernelScalar(\inputVector, \inputVector^\prime) = \alpha \arcsin\left(\frac{w \inputVector^\top \inputVector^\prime + b}{\sqrt{\left(w \inputVector^\top \inputVector + b + 1\right)\left(w \left.\inputVector^\prime\right.^\top \inputVector^\prime + b + 1\right)}}\right)$$</span><br />
</center>
<div class="figure">
<div id="mlp-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/mlp_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/mlp_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="mlp-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;mlp-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mlp-covariance-plot-caption" class="caption-frame">
<p>Figure: The multi-layer perceptron covariance function. This is derived by considering the infinite limit of a neural network with probit activation functions.</p>
</div>
</div>
<h2 id="relu-covariance-edit">RELU Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/relu-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/relu-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb42"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s relu_cov mlai.py</a></code></pre></div>
<center>
<br /><span class="math display">$$\kernelScalar(\inputVector, \inputVector^\prime) = 
\alpha \arcsin\left(\frac{w \inputVector^\top \inputVector^\prime + b}
{\sqrt{\left(w \inputVector^\top \inputVector + b + 1\right)
\left(w \left.\inputVector^\prime\right.^\top \inputVector^\prime + b + 1\right)}}\right)$$</span><br />
</center>
<div class="figure">
<div id="relu-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/relu_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/relu_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="relu-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;relu-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="relu-covariance-plot-caption" class="caption-frame">
<p>Figure: Rectified linear unit covariance function.</p>
</div>
</div>
<h2 id="sinc-covariance-edit">Sinc Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/sinc-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/sinc-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Another approach to developing covariance function exploits Bochner’s theorem <span class="citation" data-cites="Bochner:book59">Bochner (1959)</span>. Bochner’s theorem tells us that any positve filter in Fourier space implies has an associated Gaussian process with a stationary covariance function. The covariance function is the <em>inverse Fourier transform</em> of the filter applied in Fourier space.</p>
<p>For example, in signal processing, <em>band limitations</em> are commonly applied as an assumption. For example, we may believe that no frequency above <span class="math inline"><em>w</em> = 2</span> exists in the signal. This is equivalent to a rectangle function being applied as a the filter in Fourier space.</p>
<p>The inverse Fourier transform of the rectangle function is the <span class="math inline">sinc( ⋅ )</span> function. So the sinc is a valid covariance function, and it represents <em>band limited</em> signals.</p>
<p>Note that other covariance functions we’ve introduced can also be interpreted in this way. For example, the exponentiated quadratic covariance function can be Fourier transformed to see what the implied filter in Fourier space is. The Fourier transform of the exponentiated quadratic is an exponentiated quadratic, so the standard EQ-covariance implies a EQ filter in Fourier space.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s sinc_cov mlai.py</a></code></pre></div>

<h2 id="polynomial-covariance-edit">Polynomial Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/poly-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/poly-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<center>
<br /><span class="math display">$$\kernelScalar(\inputVector, \inputVector^\prime) = \alpha(w \inputVector^\top\inputVector^\prime + b)^d$$</span><br />
</center>
<div class="figure">
<div id="polynomial-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/polynomial_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/polynomial_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="polynomial-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;polynomial-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="polynomial-covariance-plot-caption" class="caption-frame">
<p>Figure: Polynomial covariance function.</p>
</div>
</div>
<h2 id="periodic-covariance-edit">Periodic Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/periodic-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/periodic-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<center>
<br /><span class="math display">$$\kernelScalar(\inputVector, \inputVector^\prime) = \alpha\exp\left(\frac{-2\sin(\pi rw)^2}{\lengthScale^2}\right)$$</span><br />
</center>
<div class="figure">
<div id="periodic-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/periodic_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/periodic_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="periodic-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;periodic-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="periodic-covariance-plot-caption" class="caption-frame">
<p>Figure: Periodic covariance function.</p>
</div>
</div>
<h2 id="linear-model-of-coregionalization-covariance-edit">Linear Model of Coregionalization Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/lmc-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/lmc-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb44"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s lmc_cov mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</a></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb46-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb47-1" data-line-number="1">plot.save_animation(anim, </a>
<a class="sourceLine" id="cb47-2" data-line-number="2">                    diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/kern&#39;</span>, </a>
<a class="sourceLine" id="cb47-3" data-line-number="3">                    filename<span class="op">=</span><span class="st">&#39;lmc_covariance.html&#39;</span>)</a></code></pre></div>
<center>
<br /><span class="math display">$$\kernelScalar(i, j, \inputVector, \inputVector^\prime) = b_{i,j} \kernelScalar(\inputVector, \inputVector^\prime)$$</span><br />
</center>
<div class="figure">
<div id="lmc-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/lmc_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/lmc_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="lmc-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;lmc-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="lmc-covariance-plot-caption" class="caption-frame">
<p>Figure: Linear model of coregionalization covariance function.</p>
</div>
</div>
<h2 id="intrinsic-coregionalization-model-covariance-edit">Intrinsic Coregionalization Model Covariance <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/icm-covariance.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_kern/includes/icm-covariance.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb48"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="op">%</span>load <span class="op">-</span>s icm_cov mlai.py</a></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</a></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb50-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb51-1" data-line-number="1">plot.save_animation(anim, </a>
<a class="sourceLine" id="cb51-2" data-line-number="2">                    diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/kern&#39;</span>, </a>
<a class="sourceLine" id="cb51-3" data-line-number="3">                    filename<span class="op">=</span><span class="st">&#39;icm_covariance.html&#39;</span>)</a></code></pre></div>
<center>
<br /><span class="math display">$$\kernelScalar(i, j, \inputVector, \inputVector^\prime) = b_{i,j} \kernelScalar(\inputVector, \inputVector^\prime)$$</span><br />
</center>
<div class="figure">
<div id="icm-covariance-plot-figure" class="figure-frame">
<table>
<tr>
<td width="45%">
<object class width="100%" data="../slides/diagrams/kern/icm_covariance.svg">
</object>
</td>
<td width="45%">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/kern/icm_covariance.gif" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</td>
</tr>
</table>
</div>
<div id="icm-covariance-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;icm-covariance-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="icm-covariance-plot-caption" class="caption-frame">
<p>Figure: Intrinsic coregionalization model covariance function.</p>
</div>
</div>
<h2 id="deep-gaussian-processes">Deep Gaussian Processes</h2>
<h2 id="low-rank-gaussian-processes-edit">Low Rank Gaussian Processes <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/approximate-gps-short.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/approximate-gps-short.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="sparse-gp-comic-figure" class="figure-frame">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/sparse-gps.jpg" width="45%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="sparse-gp-comic-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-gp-comic&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-gp-comic-caption" class="caption-frame">
<p>Figure: In recent years, approximations for Gaussian process models haven’t been the most fashionable approach to machine learning. Image credit: Kai Arulkumaran</p>
</div>
</div>
<p>Inference in a Gaussian process has computational complexity of <span class="math inline">$\bigO(\numData^3)$</span> and storage demands of <span class="math inline">$\bigO(\numData^2)$</span>. This is too large for many modern data sets.</p>
<p>Low rank approximations allow us to work with Gaussian processes with computational complexity of <span class="math inline">$\bigO(\numData\numInducing^2)$</span> and storage demands of <span class="math inline">$\bigO(\numData\numInducing)$</span>, where <span class="math inline">$\numInducing$</span> is a user chosen parameter.</p>
<p>In machine learning, low rank approximations date back to <span class="citation" data-cites="Smola:sparsegp00">Smola and Bartlett (n.d.)</span>, <span class="citation" data-cites="Williams:nystrom00">Williams and Seeger (n.d.)</span>, who considered the Nyström approximation and <span class="citation" data-cites="Csato:sparse02">Csató and Opper (2002)</span>;<span class="citation" data-cites="Csato:thesis02">Csató (2002)</span> who considered low rank approximations in the context of on-line learning. Selection of active points for the approximation was considered by <span class="citation" data-cites="Seeger:fast03">Seeger, Williams, and Lawrence (n.d.)</span> and <span class="citation" data-cites="Snelson:pseudo05">Snelson and Ghahramani (n.d.)</span> first proposed that the active set could be optimized directly. Those approaches were reviewed by <span class="citation" data-cites="Quinonero:unifying05">Quiñonero Candela and Rasmussen (2005)</span> under a unifying likelihood approximation perspective. General rules for deriving the maximum likelihood for these sparse approximations were given in <span class="citation" data-cites="Lawrence:larger07">Lawrence (n.d.)</span>.</p>
<p>Modern variational interpretations of these low rank approaches were first explored in <span class="citation" data-cites="Titsias:variational09">Titsias (n.d.)</span>. A more modern summary which considers each of these approximations as an <span class="math inline"><em>α</em></span>-divergence is given by <span class="citation" data-cites="Thang:unifying17">Bui, Yan, and Turner (2017)</span>.</p>
<h2 id="variational-compression-edit">Variational Compression <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gp-variational-complexity.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gp-variational-complexity.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Inducing variables are a compression of the real observations. The basic idea is can I create a new data set that summarizes all the information in the original data set. If this data set is smaller, I’ve compressed the information in the original data set.</p>
<p>Inducing variables can be thought of as pseudo-data, indeed in <span class="citation" data-cites="Snelson:pseudo05">Snelson and Ghahramani (n.d.)</span> they were referred to as <em>pseudo-points</em>.</p>
<p>The only requirement for inducing variables is that they are jointly distributed as a Gaussian process with the original data. This means that they can be from the space <span class="math inline">$\mappingFunctionVector$</span> or a space that is related through a linear operator (see e.g. <span class="citation" data-cites="Alvarez:efficient10">Álvarez et al. (2010)</span>). For example we could choose to store the gradient of the function at particular points or a value from the frequency spectrum of the function <span class="citation" data-cites="Lazaro:spectrum10">(Lázaro-Gredilla, Quiñonero-Candela, and Rasmussen 2010)</span>.</p>
<h2 id="variational-compression-ii">Variational Compression II</h2>
<p>Inducing variables don’t only allow for the compression of the non-parameteric information into a reduced data aset but they also allow for computational scaling of the algorithms through, for example stochastic variational approaches <span class="citation" data-cites="Hensman:bigdata13">Hensman, Fusi, and Lawrence (n.d.)</span> or parallelization <span class="citation" data-cites="Gal:distributed14">Gal, Wilk, and Rasmussen (n.d.)</span>,<span class="citation" data-cites="Dai:gpu14">Dai et al. (2014)</span>, <span class="citation" data-cites="Seeger:auto17">Seeger et al. (2017)</span>.</p>
<!--include{_gp/includes/larger-factorize.md}-->
<p>We’ve seen how we go from parametric to non-parametric. The limit implies infinite dimensional <span class="math inline">$\mappingVector$</span>. Gaussian processes are generally non-parametric: combine data with covariance function to get model. This representation <em>cannot</em> be summarized by a parameter vector of a fixed size.</p>
<p>Parametric models have a representation that does not respond to increasing training set size. Bayesian posterior distributions over parameters contain the information about the training data, for example if we use use Bayes’ rule from training data, <br /><span class="math display">$$
p\left(\mappingVector|\dataVector, \inputMatrix\right),
$$</span><br /> to make predictions on test data <br /><span class="math display">$$
p\left(\dataScalar_*|\inputMatrix_*, \dataVector, \inputMatrix\right) = \int
              p\left(\dataScalar_*|\mappingVector,\inputMatrix_*\right)p\left(\mappingVector|\dataVector,
                \inputMatrix)\text{d}\mappingVector\right)
$$</span><br /> then <span class="math inline">$\mappingVector$</span> becomes a bottleneck for information about the training set to pass to the test set. The solution is to increase <span class="math inline">$\numBasisFunc$</span> so that the bottleneck is so large that it no longer presents a problem. How big is big enough for <span class="math inline">$\numBasisFunc$</span>? Non-parametrics says <span class="math inline">$\numBasisFunc \rightarrow \infty$</span>.</p>
<p>Now no longer possible to manipulate the model through the standard parametric form. However, it <em>is</em> possible to express <em>parametric</em> as GPs: <br /><span class="math display">$$
\kernelScalar\left(\inputVector_i,\inputVector_j\right)=\basisFunction_:\left(\inputVector_i\right)^\top\basisFunction_:\left(\inputVector_j\right).
$$</span><br /> These are known as degenerate covariance matrices. Their rank is at most <span class="math inline">$\numBasisFunc$</span>, non-parametric models have full rank covariance matrices. Most well known is the “linear kernel”, <br /><span class="math display">$$
\kernelScalar(\inputVector_i, \inputVector_j) = \inputVector_i^\top\inputVector_j.
$$</span><br /> For non-parametrics prediction at a new point, <span class="math inline">$\mappingFunctionVector_*$</span>, is made by conditioning on <span class="math inline">$\mappingFunctionVector$</span> in the joint distribution. In GPs this involves combining the training data with the covariance function and the mean function. Parametric is a special case when conditional prediction can be summarized in a <em>fixed</em> number of parameters. Complexity of parametric model remains fixed regardless of the size of our training data set. For a non-parametric model the required number of parameters grows with the size of the training data.</p>
<h2 id="augment-variable-space-edit">Augment Variable Space <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/approximate-gps-short.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/approximate-gps-short.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>In inducing variable approximations, we augment the variable space with a set of inducing points, <span class="math inline">$\inducingVector$</span>. These inducing points are jointly Gaussian distributed with the points from our function, <span class="math inline">$\mappingFunctionVector$</span>. So we have a joint Gaussian process with covariance, <br /><span class="math display">$$
\begin{bmatrix}
\mappingFunctionVector\\
\inducingVector
\end{bmatrix} \sim \gaussianSamp{\zerosVector}{\kernelMatrix}
$$</span><br /> where the kernel matrix itself can be decomposed into <br /><span class="math display">$$
\kernelMatrix =
\begin{bmatrix}
\Kff &amp; \Kfu \\
\Kuf &amp; \Kuu
\end{bmatrix}
$$</span><br /></p>
<p>This defines a joint density between the original function points, <span class="math inline">$\mappingFunctionVector$</span> and our inducing points, <span class="math inline">$\inducingVector$</span>. This can be decomposed through the product rule to give. <br /><span class="math display">$$
p(\mappingFunctionVector, \inducingVector) = p(\mappingFunctionVector| \inducingVector) p(\inducingVector)
$$</span><br /> The Gaussian process is (typically) given by a noise corrupted form of <span class="math inline">$\mappingFunctionVector$</span>, i.e., <br /><span class="math display">$$
\dataScalar(\inputVector) = \mappingFunction(\inputVector) + \noiseScalar,
$$</span><br /> which can be written probabilisticlly as, <br /><span class="math display">$$
p(\dataVector) = \int p(\dataVector|\mappingFunctionVector) p(\mappingFunctionVector) \text{d}\mappingFunctionVector,
$$</span><br /> where for the independent case we have <span class="math inline">$p(\dataVector | \mappingFunctionVector) = \prod_{i=1}^\numData p(\dataScalar_i|\mappingFunction_i)$</span>.</p>
<p>Inducing variables are like auxilliary variables in Monte Carlo algorithms. We introduce the inducing variables by augmenting this integral with an additional integral over <span class="math inline">$\inducingVector$</span>, <br /><span class="math display">$$
p(\dataVector) = \int p(\dataVector|\mappingFunctionVector) p(\mappingFunctionVector|\inducingVector)  p(\inducingVector)  \text{d}\inducingVector \text{d}\mappingFunctionVector.
$$</span><br /> Now, conceptually speaking we are going to integrate out <span class="math inline">$\mappingFunctionVector$</span>, initially leaving <span class="math inline">$\inducingVector$</span> in place. This gives, <br /><span class="math display">$$
p(\dataVector) = \int p(\dataVector|\inducingVector)   p(\inducingVector)  \text{d}\inducingVector.
$$</span><br /></p>
<p>Note the similarity between this form and our standard <em>parametric</em> form. If we had defined our model through standard basis functions we would have, <br /><span class="math display">$$
\dataScalar(\inputVector) = \weightVector^\top\basisVector(\inputVector) + \noiseScalar
$$</span><br /> and the resulting probabilistic representation would be <br /><span class="math display">$$
p(\dataVector) = \int p(\dataVector|\weightVector) p(\weightVector) \text{d} \weightVector
$$</span><br /> allowing us to predict <br /><span class="math display">$$
p(\dataVector^*|\dataVector) = \int p(\dataVector^*|\weightVector) p(\weightVector|\dataVector) \text{d} \weightVector
$$</span><br /></p>
<p>The new prediction algorithm involves <br /><span class="math display">$$
p(\dataVector^*|\dataVector) = \int p(\dataVector^*|\inducingVector) p(\inducingVector|\dataVector) \text{d} \inducingVector
$$</span><br /> but <em>importantly</em> the length of <span class="math inline">$\inducingVector$</span> is not fixed at <em>design</em> time like the number of parameters were. We can vary the number of inducing variables we use to give us the model capacity we require.</p>
<p>Unfortunately, computation of <span class="math inline">$p(\dataVector|\inducingVector)$</span> turns out to be intractable. As a result, we need to turn to approximations to make progress.</p>
<h2 id="variational-bound-on-pdatavector-inducingvector-edit">Variational Bound on <span class="math inline">$p(\dataVector |\inducingVector)$</span> <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/larger-variational.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/larger-variational.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The conditional density of the data given the inducing points can be <em>lower</em> bounded variationally <br /><span class="math display">$$
\begin{aligned}
    \log p(\dataVector|\inducingVector) &amp; = \log \int p(\dataVector|\mappingFunctionVector) p(\mappingFunctionVector|\inducingVector) \text{d}\mappingFunctionVector\\ &amp; = \int q(\mappingFunctionVector) \log \frac{p(\dataVector|\mappingFunctionVector) p(\mappingFunctionVector|\inducingVector)}{q(\mappingFunctionVector)}\text{d}\mappingFunctionVector + \KL{q(\mappingFunctionVector)}{p(\mappingFunctionVector|\dataVector, \inducingVector)}.
\end{aligned}
$$</span><br /></p>
<p>The key innovation from <span class="citation" data-cites="Titsias:variational09">Titsias (n.d.)</span> was to then make a particular choice for <span class="math inline">$q(\mappingFunctionVector)$</span>. If we set <span class="math inline">$q(\mappingFunctionVector)=p(\mappingFunctionVector|\inducingVector)$</span>, <br /><span class="math display">$$
  \log p(\dataVector|\inducingVector) \geq \int p(\mappingFunctionVector|\inducingVector) \log p(\dataVector|\mappingFunctionVector)\text{d}\mappingFunctionVector.
  $$</span><br /> <br /><span class="math display">$$
  p(\dataVector|\inducingVector) \geq \exp \int p(\mappingFunctionVector|\inducingVector) \log p(\dataVector|\mappingFunctionVector)\text{d}\mappingFunctionVector.
  $$</span><br /></p>
<h2 id="optimal-compression-in-inducing-variables">Optimal Compression in Inducing Variables</h2>
<p>Maximizing the lower bound minimizes the Kullback-Leibler divergence (or <em>information gain</em>) between our approximating density, <span class="math inline">$p(\mappingFunctionVector|\inducingVector)$</span> and the true posterior density, <span class="math inline">$p(\mappingFunctionVector|\dataVector, \inducingVector)$</span>.</p>
<p><br /><span class="math display">$$
  \KL{p(\mappingFunctionVector|\inducingVector)}{p(\mappingFunctionVector|\dataVector, \inducingVector)} = \int p(\mappingFunctionVector|\inducingVector) \log \frac{p(\mappingFunctionVector|\inducingVector)}{p(\mappingFunctionVector|\dataVector, \inducingVector)}\text{d}\inducingVector
  $$</span><br /></p>
<p>This bound is minimized when the information stored about <span class="math inline">$\dataVector$</span> is already stored in <span class="math inline">$\inducingVector$</span>. In other words, maximizing the bound seeks an <em>optimal compression</em> from the <em>information gain</em> perspective.</p>
<p>For the case where <span class="math inline">$\inducingVector = \mappingFunctionVector$</span> the bound is exact (<span class="math inline">$\mappingFunctionVector$</span> <span class="math inline"><em>d</em></span>-separates <span class="math inline">$\dataVector$</span> from <span class="math inline">$\inducingVector$</span>).</p>
<h2 id="choice-of-inducing-variables">Choice of Inducing Variables</h2>
<p>The quality of the resulting bound is determined by the choice of the inducing variables. You are free to choose whichever heuristics you like for the inducing variables, as long as they are drawn jointly from a valid Gaussian process, i.e. such that <br /><span class="math display">$$
\begin{bmatrix}
\mappingFunctionVector\\
\inducingVector
\end{bmatrix} \sim \gaussianSamp{\zerosVector}{\kernelMatrix}
$$</span><br /> where the kernel matrix itself can be decomposed into <br /><span class="math display">$$
\kernelMatrix =
\begin{bmatrix}
\Kff &amp; \Kfu \\
\Kuf &amp; \Kuu
\end{bmatrix}
$$</span><br /> Choosing the inducing variables amounts to specifying <span class="math inline">$\Kfu$</span> and <span class="math inline">$\Kuu$</span> such that <span class="math inline">$\kernelMatrix$</span> remains positive definite. The typical choice is to choose <span class="math inline">$\inducingVector$</span> in the same domain as <span class="math inline">$\mappingFunctionVector$</span>, associating each inducing output, <span class="math inline">$\inducingScalar_i$</span> with a corresponding input location <span class="math inline">$\inducingInputVector$</span>. However, more imaginative choices are absolutely possible. In particular, if <span class="math inline">$\inducingVector$</span> is related to <span class="math inline">$\mappingFunctionVector$</span> through a linear operator (see e.g. <span class="citation" data-cites="Alvarez:efficient10">Álvarez et al. (2010)</span>), then valid <span class="math inline">$\Kuu$</span> and <span class="math inline">$\Kuf$</span> can be constructed. For example we could choose to store the gradient of the function at particular points or a value from the frequency spectrum of the function <span class="citation" data-cites="Lazaro:spectrum10">(Lázaro-Gredilla, Quiñonero-Candela, and Rasmussen 2010)</span>.</p>
<h2 id="variational-compression-ii-1">Variational Compression II</h2>
<p>Inducing variables don’t only allow for the compression of the non-parameteric information into a reduced data set but they also allow for computational scaling of the algorithms through, for example stochastic variational approaches<span class="citation" data-cites="Hoffman:stochastic12 Hensman:bigdata13">(Hoffman et al. 2012; Hensman, Fusi, and Lawrence, n.d.)</span> or parallelization <span class="citation" data-cites="Gal:distributed14 Dai:gpu14 Seeger:auto17">(Gal, Wilk, and Rasmussen, n.d.; Dai et al. 2014; Seeger et al. 2017)</span>.</p>
<!--include{_gp/includes/larger-graph-intro.md}-->
<h2 id="a-simple-regression-problem-edit">A Simple Regression Problem <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/inducing-variables-demo.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/inducing-variables-demo.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Here we set up a simple one dimensional regression problem. The input locations, <span class="math inline">$\inputMatrix$</span>, are in two separate clusters. The response variable, <span class="math inline">$\dataVector$</span>, is sampled from a Gaussian process with an exponentiated quadratic covariance.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="im">import</span> GPy</a></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb53-1" data-line-number="1">np.random.seed(<span class="dv">101</span>)</a></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb54-1" data-line-number="1">N <span class="op">=</span> <span class="dv">50</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">noise_var <span class="op">=</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">X <span class="op">=</span> np.zeros((<span class="dv">50</span>, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb54-4" data-line-number="4">X[:<span class="dv">25</span>, :] <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">25</span>)[:,<span class="va">None</span>] <span class="co"># First cluster of inputs/covariates</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">X[<span class="dv">25</span>:, :] <span class="op">=</span> np.linspace(<span class="dv">7</span>,<span class="dv">10</span>,<span class="dv">25</span>)[:,<span class="va">None</span>] <span class="co"># Second cluster of inputs/covariates</span></a>
<a class="sourceLine" id="cb54-6" data-line-number="6"></a>
<a class="sourceLine" id="cb54-7" data-line-number="7"><span class="co"># Sample response variables from a Gaussian process with exponentiated quadratic covariance.</span></a>
<a class="sourceLine" id="cb54-8" data-line-number="8">k <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb54-9" data-line-number="9">y <span class="op">=</span> np.random.multivariate_normal(np.zeros(N),k.K(X)<span class="op">+</span>np.eye(N)<span class="op">*</span>np.sqrt(noise_var)).reshape(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)</a></code></pre></div>
<p>First we perform a full Gaussian process regression on the data. We create a GP model, <code>m_full</code>, and fit it to the data, plotting the resulting fit.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb55-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(X,y)</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">_ <span class="op">=</span> m_full.optimize(messages<span class="op">=</span><span class="va">True</span>) <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<div class="sourceCode" id="cb56"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb56-2" data-line-number="2"><span class="im">import</span> mlai</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="im">import</span> teaching_plots <span class="im">as</span> plot </a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="im">from</span> gp_tutorial <span class="im">import</span> gpplot</a></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb57-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb57-2" data-line-number="2">plot.model_output(m_full, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;$x$&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>)</a>
<a class="sourceLine" id="cb57-3" data-line-number="3">xlim <span class="op">=</span> ax.get_xlim()</a>
<a class="sourceLine" id="cb57-4" data-line-number="4">ylim <span class="op">=</span> ax.get_ylim()</a>
<a class="sourceLine" id="cb57-5" data-line-number="5">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb57-6" data-line-number="6">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/sparse-demo-full-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb57-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="sparse-demo-full-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-full-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="sparse-demo-full-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-demo-full-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-demo-full-gp-caption" class="caption-frame">
<p>Figure: Full Gaussian process fitted to the data set.</p>
</div>
</div>
<p>Now we set up the inducing variables, <span class="math inline"><strong>u</strong></span>. Each inducing variable has its own associated input index, <span class="math inline"><strong>Z</strong></span>, which lives in the same space as <span class="math inline">$\inputMatrix$</span>. Here we are using the true covariance function parameters to generate the fit.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb58-1" data-line-number="1">kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb58-2" data-line-number="2">Z <span class="op">=</span> np.hstack(</a>
<a class="sourceLine" id="cb58-3" data-line-number="3">        (np.linspace(<span class="fl">2.5</span>,<span class="fl">4.</span>,<span class="dv">3</span>),</a>
<a class="sourceLine" id="cb58-4" data-line-number="4">        np.linspace(<span class="dv">7</span>,<span class="fl">8.5</span>,<span class="dv">3</span>)))[:,<span class="va">None</span>]</a>
<a class="sourceLine" id="cb58-5" data-line-number="5">m <span class="op">=</span> GPy.models.SparseGPRegression(X,y,kernel<span class="op">=</span>kern,Z<span class="op">=</span>Z)</a>
<a class="sourceLine" id="cb58-6" data-line-number="6">m.noise_var <span class="op">=</span> noise_var</a>
<a class="sourceLine" id="cb58-7" data-line-number="7">m.inducing_inputs.constrain_fixed()</a>
<a class="sourceLine" id="cb58-8" data-line-number="8">display(m)</a></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb59-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb59-2" data-line-number="2">plot.model_output(m, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;$x$&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim)</a>
<a class="sourceLine" id="cb59-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb59-4" data-line-number="4">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/sparse-demo-constrained-inducing-6-unlearned-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb59-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="sparse-demo-constrained-inducing-6-unlearned-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-constrained-inducing-6-unlearned-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="sparse-demo-constrained-inducing-6-unlearned-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-demo-constrained-inducing-6-unlearned-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-demo-constrained-inducing-6-unlearned-gp-caption" class="caption-frame">
<p>Figure: Sparse Gaussian process fitted with six inducing variables, no optimization of parameters or inducing variables.</p>
</div>
</div>
<div class="sourceCode" id="cb60"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb60-1" data-line-number="1">_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb60-2" data-line-number="2">display(m)</a></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb61-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb61-2" data-line-number="2">plot.model_output(m, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;$x$&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim)</a>
<a class="sourceLine" id="cb61-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb61-4" data-line-number="4">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/sparse-demo-constrained-inducing-6-learned-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb61-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="sparse-demo-constrained-inducing-6-learned-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-constrained-inducing-6-learned-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="sparse-demo-constrained-inducing-6-learned-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-demo-constrained-inducing-6-learned-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-demo-constrained-inducing-6-learned-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fitted with inducing variables fixed and parameters optimized</p>
</div>
</div>
<div class="sourceCode" id="cb62"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb62-1" data-line-number="1">m.randomize()</a>
<a class="sourceLine" id="cb62-2" data-line-number="2">m.inducing_inputs.unconstrain()</a>
<a class="sourceLine" id="cb62-3" data-line-number="3">_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb63-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb63-2" data-line-number="2">plot.model_output(m, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;$x$&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>,xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim)</a>
<a class="sourceLine" id="cb63-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb63-4" data-line-number="4">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/sparse-demo-unconstrained-inducing-6-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb63-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="sparse-demo-unconstrained-inducing-6-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-unconstrained-inducing-6-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="sparse-demo-unconstrained-inducing-6-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-demo-unconstrained-inducing-6-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-demo-unconstrained-inducing-6-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fitted with location of inducing variables and parameters both optimized</p>
</div>
</div>
<p>Now we will vary the number of inducing points used to form the approximation.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb64-1" data-line-number="1">m.num_inducing<span class="op">=</span><span class="dv">8</span></a>
<a class="sourceLine" id="cb64-2" data-line-number="2">m.randomize()</a>
<a class="sourceLine" id="cb64-3" data-line-number="3">M <span class="op">=</span> <span class="dv">8</span></a>
<a class="sourceLine" id="cb64-4" data-line-number="4">m.set_Z(np.random.rand(M,<span class="dv">1</span>)<span class="op">*</span><span class="dv">12</span>)</a>
<a class="sourceLine" id="cb64-5" data-line-number="5"></a>
<a class="sourceLine" id="cb64-6" data-line-number="6">_ <span class="op">=</span> m.optimize(messages<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb65-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb65-2" data-line-number="2">plot.model_output(m, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;$x$&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.2</span>, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim)</a>
<a class="sourceLine" id="cb65-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig,</a>
<a class="sourceLine" id="cb65-4" data-line-number="4">                  filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/sparse-demo-sparse-inducing-8-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb65-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="sparse-demo-sparse-inducing-8-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-sparse-inducing-8-gp.svg" width="80%" style=" ">
</object>
<object class="svgplot " data="../slides/diagrams/gp/sparse-demo-full-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="sparse-demo-sparse-inducing-8-magnify" class="magnify" onclick="magnifyFigure(&#39;sparse-demo-sparse-inducing-8&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="sparse-demo-sparse-inducing-8-caption" class="caption-frame">
<p>Figure: Comparison of the full Gaussian process fit with a sparse Gaussian process using eight inducing varibles. Both inducing variables and parameters are optimized.</p>
</div>
</div>
<p>And we can compare the probability of the result to the full model.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="bu">print</span>(m.log_likelihood(), m_full.log_likelihood())</a></code></pre></div>
<h2 id="modern-review">Modern Review</h2>
<ul>
<li><p><em>A Unifying Framework for Gaussian Process Pseudo-Point Approximations using Power Expectation Propagation</em> <span class="citation" data-cites="Thang:unifying17">Bui, Yan, and Turner (2017)</span></p></li>
<li><p><em>Deep Gaussian Processes and Variational Propagation of Uncertainty</em> <span class="citation" data-cites="Damianou:thesis2015">Damianou (2015)</span></p></li>
</ul>
<p>Even in the early days of Gaussian processes in machine learning, it was understood that we were throwing something fundamental away. This is perhaps captured best by David MacKay in his 1997 NeurIPS tutorial on Gaussian processes, where he asked “Have we thrown out the baby with the bathwater?”. The quote below is from his summarization paper.</p>
<blockquote>
<p>According to the hype of 1987, neural networks were meant to be intelligent models which discovered features and patterns in data. Gaussian processes in contrast are simply smoothing devices. How can Gaussian processes possibly repalce neural networks? What is going on?</p>
<p><span class="citation" data-cites="MacKay:gpintroduction98">MacKay (n.d.)</span></p>
</blockquote>
<div class="sourceCode" id="cb67"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb67-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="figure">
<div id="deep-neural-network-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/deep-nn2.svg" width="70%" style=" ">
</object>
</div>
<div id="deep-neural-network-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-neural-network&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-neural-network-caption" class="caption-frame">
<p>Figure: A deep neural network. Input nodes are shown at the bottom. Each hidden layer is the result of applying an affine transformation to the previous layer and placing through an activation function.</p>
</div>
</div>
<p>Mathematically, each layer of a neural network is given through computing the activation function, <span class="math inline">$\basisFunction(\cdot)$</span>, contingent on the previous layer, or the inputs. In this way the activation functions, are composed to generate more complex interactions than would be possible with any single layer. <br /><span class="math display">$$
\begin{align}
    \hiddenVector_{1} &amp;= \basisFunction\left(\mappingMatrix_1 \inputVector\right)\\
    \hiddenVector_{2} &amp;=  \basisFunction\left(\mappingMatrix_2\hiddenVector_{1}\right)\\
    \hiddenVector_{3} &amp;= \basisFunction\left(\mappingMatrix_3 \hiddenVector_{2}\right)\\
    \dataVector &amp;= \mappingVector_4 ^\top\hiddenVector_{3}
\end{align}
$$</span><br /></p>
<h2 id="overfitting-edit">Overfitting <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/overfitting-low-rank.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/overfitting-low-rank.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>One potential problem is that as the number of nodes in two adjacent layers increases, the number of parameters in the affine transformation between layers, <span class="math inline">$\mappingMatrix$</span>, increases. If there are <span class="math inline"><em>k</em><sub><em>i</em> − 1</sub></span> nodes in one layer, and <span class="math inline"><em>k</em><sub><em>i</em></sub></span> nodes in the following, then that matrix contains <span class="math inline"><em>k</em><sub><em>i</em></sub><em>k</em><sub><em>i</em> − 1</sub></span> parameters, when we have layer widths in the 1000s that leads to millions of parameters.</p>
<p>One proposed solution is known as <em>dropout</em> where only a sub-set of the neural network is trained at each iteration. An alternative solution would be to reparameterize <span class="math inline">$\mappingMatrix$</span> with its <em>singular value decomposition</em>. <br /><span class="math display">$$
  \mappingMatrix = \eigenvectorMatrix\eigenvalueMatrix\eigenvectwoMatrix^\top
  $$</span><br /> or <br /><span class="math display">$$
  \mappingMatrix = \eigenvectorMatrix\eigenvectwoMatrix^\top
  $$</span><br /> where if <span class="math inline">$\mappingMatrix \in \Re^{k_1\times k_2}$</span> then <span class="math inline">$\eigenvectorMatrix\in \Re^{k_1\times q}$</span> and <span class="math inline">$\eigenvectwoMatrix \in \Re^{k_2\times q}$</span>, i.e. we have a low rank matrix factorization for the weights.</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb68-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="figure">
<div id="low-rank-mapping-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/wisuvt.svg" width="80%" style=" ">
</object>
</div>
<div id="low-rank-mapping-magnify" class="magnify" onclick="magnifyFigure(&#39;low-rank-mapping&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="low-rank-mapping-caption" class="caption-frame">
<p>Figure: Pictorial representation of the low rank form of the matrix <span class="math inline">$\mappingMatrix$</span>.</p>
</div>
</div>
<h2 id="bottleneck-layers-in-deep-neural-networks-edit">Bottleneck Layers in Deep Neural Networks <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb69"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb69-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a></code></pre></div>
<div class="figure">
<div id="deep-nn-bottleneck-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/deep-nn-bottleneck2.svg" width="70%" style=" ">
</object>
</div>
<div id="deep-nn-bottleneck-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-nn-bottleneck&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-nn-bottleneck-caption" class="caption-frame">
<p>Figure: Inserting the bottleneck layers introduces a new set of variables.</p>
</div>
</div>
<p>Including the low rank decomposition of <span class="math inline">$\mappingMatrix$</span> in the neural network, we obtain a new mathematical form. Effectively, we are adding additional <em>latent</em> layers, <span class="math inline">$\latentVector$</span>, in between each of the existing hidden layers. In a neural network these are sometimes known as <em>bottleneck</em> layers. The network can now be written mathematically as <br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \eigenvectwoMatrix^\top_1 \inputVector\\
  \hiddenVector_{1} &amp;= \basisFunction\left(\eigenvectorMatrix_1 \latentVector_{1}\right)\\
  \latentVector_{2} &amp;= \eigenvectwoMatrix^\top_2 \hiddenVector_{1}\\
  \hiddenVector_{2} &amp;= \basisFunction\left(\eigenvectorMatrix_2 \latentVector_{2}\right)\\
  \latentVector_{3} &amp;= \eigenvectwoMatrix^\top_3 \hiddenVector_{2}\\
  \hiddenVector_{3} &amp;= \basisFunction\left(\eigenvectorMatrix_3 \latentVector_{3}\right)\\
  \dataVector &amp;= \mappingVector_4^\top\hiddenVector_{3}.
\end{align}
$$</span><br /></p>
<p><br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \eigenvectwoMatrix^\top_1 \inputVector\\
  \latentVector_{2} &amp;= \eigenvectwoMatrix^\top_2 \basisFunction\left(\eigenvectorMatrix_1 \latentVector_{1}\right)\\
  \latentVector_{3} &amp;= \eigenvectwoMatrix^\top_3 \basisFunction\left(\eigenvectorMatrix_2 \latentVector_{2}\right)\\
  \dataVector &amp;= \mappingVector_4 ^\top \latentVector_{3}
\end{align}
$$</span><br /></p>
<h2 id="cascade-of-gaussian-processes-edit">Cascade of Gaussian Processes <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/cascade-of-gps.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/cascade-of-gps.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Now if we replace each of these neural networks with a Gaussian process. This is equivalent to taking the limit as the width of each layer goes to infinity, while appropriately scaling down the outputs.</p>
<p><br /><span class="math display">$$
\begin{align}
  \latentVector_{1} &amp;= \mappingFunctionVector_1\left(\inputVector\right)\\
  \latentVector_{2} &amp;= \mappingFunctionVector_2\left(\latentVector_{1}\right)\\
  \latentVector_{3} &amp;= \mappingFunctionVector_3\left(\latentVector_{2}\right)\\
  \dataVector &amp;= \mappingFunctionVector_4\left(\latentVector_{3}\right)
\end{align}
$$</span><br /></p>
<h1 id="deep-learning-edit">Deep Learning <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-learning-overview.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-learning-overview.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h1>
<!-- No slide titles in this context -->
<h3 id="deepface-edit">DeepFace <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-face.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-face.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h3>
<div class="figure">
<div id="deep-face-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/deepface_neg.png" width="100%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="deep-face-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-face&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-face-caption" class="caption-frame">
<p>Figure: The DeepFace architecture <span class="citation" data-cites="Taigman:deepface14">(Taigman et al. 2014)</span>, visualized through colors to represent the functional mappings at each layer. There are 120 million parameters in the model.</p>
</div>
</div>
<p>The DeepFace architecture <span class="citation" data-cites="Taigman:deepface14">(Taigman et al. 2014)</span> consists of layers that deal with <em>translation</em> and <em>rotational</em> invariances. These layers are followed by three locally-connected layers and two fully-connected layers. Color illustrates feature maps produced at each layer. The neural network includes more than 120 million parameters, where more than 95% come from the local and fully connected layers.</p>
<h3 id="deep-learning-as-pinball-edit">Deep Learning as Pinball <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-learning-as-pinball.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/deep-learning-as-pinball.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h3>
<div class="figure">
<div id="early-pinball-figure" class="figure-frame">
<div class="centered centered" style="">
<img class="" src="../slides/diagrams/576px-Early_Pinball.jpg" width="50%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="early-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;early-pinball&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="early-pinball-caption" class="caption-frame">
<p>Figure: Deep learning models are composition of simple functions. We can think of a pinball machine as an analogy. Each layer of pins corresponds to one of the layers of functions in the model. Input data is represented by the location of the ball from left to right when it is dropped in from the top. Output class comes from the position of the ball as it leaves the pins at the bottom.</p>
</div>
</div>
<p>Sometimes deep learning models are described as being like the brain, or too complex to understand, but one analogy I find useful to help the gist of these models is to think of them as being similar to early pin ball machines.</p>
<p>In a deep neural network, we input a number (or numbers), whereas in pinball, we input a ball.</p>
<p>Think of the location of the ball on the left-right axis as a single number. Our simple pinball machine can only take one number at a time. As the ball falls through the machine, each layer of pins can be thought of as a different layer of ‘neurons’. Each layer acts to move the ball from left to right.</p>
<p>In a pinball machine, when the ball gets to the bottom it might fall into a hole defining a score, in a neural network, that is equivalent to the decision: a classification of the input object.</p>
<p>An image has more than one number associated with it, so it is like playing pinball in a <em>hyper-space</em>.</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb70-1" data-line-number="1"><span class="im">import</span> pods</a>
<a class="sourceLine" id="cb70-2" data-line-number="2"><span class="im">from</span> ipywidgets <span class="im">import</span> IntSlider</a></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb71-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;pinball</span><span class="sc">{sample:0&gt;3}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb71-2" data-line-number="2">                            <span class="st">&#39;../slides/diagrams&#39;</span>,</a>
<a class="sourceLine" id="cb71-3" data-line-number="3">                            sample<span class="op">=</span>IntSlider(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>))</a></code></pre></div>
<div class="figure">
<div id="pinball-initialization-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/pinball001.svg" width="80%" style=" ">
</object>
</div>
<div id="pinball-initialization-magnify" class="magnify" onclick="magnifyFigure(&#39;pinball-initialization&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="pinball-initialization-caption" class="caption-frame">
<p>Figure: At initialization, the pins, which represent the parameters of the function, aren’t in the right place to bring the balls to the correct decisions.</p>
</div>
</div>
<div class="figure">
<div id="pinball-trained-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/pinball002.svg" width="80%" style=" ">
</object>
</div>
<div id="pinball-trained-magnify" class="magnify" onclick="magnifyFigure(&#39;pinball-trained&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="pinball-trained-caption" class="caption-frame">
<p>Figure: After learning the pins are now in the right place to bring the balls to the correct decisions.</p>
</div>
</div>
<p>Learning involves moving all the pins to be in the correct position, so that the ball ends up in the right place when it’s fallen through the machine. But moving all these pins in hyperspace can be difficult.</p>
<p>In a hyper-space you have to put a lot of data through the machine for to explore the positions of all the pins. Even when you feed many millions of data points through the machine, there are likely to be regions in the hyper-space where no ball has passed. When future test data passes through the machine in a new route unusual things can happen.</p>
<p><em>Adversarial examples</em> exploit this high dimensional space. If you have access to the pinball machine, you can use gradient methods to find a position for the ball in the hyper space where the image looks like one thing, but will be classified as another.</p>
<p>Probabilistic methods explore more of the space by considering a range of possible paths for the ball through the machine. This helps to make them more data efficient and gives some robustness to adversarial examples.</p>
<p>Mathematically, a deep Gaussian process can be seen as a composite <em>multivariate</em> function, <br /><span class="math display">$$
  \mathbf{g}(\inputVector)=\mappingFunctionVector_5(\mappingFunctionVector_4(\mappingFunctionVector_3(\mappingFunctionVector_2(\mappingFunctionVector_1(\inputVector))))).
  $$</span><br /> Or if we view it from the probabilistic perspective we can see that a deep Gaussian process is specifying a factorization of the joint density, the standard deep model takes the form of a Markov chain.</p>
<p><br /><span class="math display">$$
  p(\dataVector|\inputVector)= p(\dataVector|\mappingFunctionVector_5)p(\mappingFunctionVector_5|\mappingFunctionVector_4)p(\mappingFunctionVector_4|\mappingFunctionVector_3)p(\mappingFunctionVector_3|\mappingFunctionVector_2)p(\mappingFunctionVector_2|\mappingFunctionVector_1)p(\mappingFunctionVector_1|\inputVector)
  $$</span><br /></p>
<div class="figure">
<div id="deep-markov-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/deep-markov.svg" width="80%" style=" ">
</object>
</div>
<div id="deep-markov-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-markov-caption" class="caption-frame">
<p>Figure: Probabilistically the deep Gaussian process can be represented as a Markov chain.</p>
</div>
</div>
<div class="figure">
<div id="deep-markov-vertical-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/deep-markov-vertical.svg" width="7%" style=" ">
</object>
</div>
<div id="deep-markov-vertical-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov-vertical&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-markov-vertical-caption" class="caption-frame">
<p>Figure: More usually deep probabilistic models are written vertically rather than horizontally as in the Markov chain.</p>
</div>
</div>
<h2 id="why-deep-edit">Why Deep? <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/process-composition.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/process-composition.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>If the result of composing many functions together is simply another function, then why do we bother? The key point is that we can change the class of functions we are modeling by composing in this manner. A Gaussian process is specifying a prior over functions, and one with a number of elegant properties. For example, the derivative process (if it exists) of a Gaussian process is also Gaussian distributed. That makes it easy to assimilate, for example, derivative observations. But that also might raise some alarm bells. That implies that the <em>marginal derivative distribution</em> is also Gaussian distributed. If that’s the case, then it means that functions which occasionally exhibit very large derivatives are hard to model with a Gaussian process. For example, a function with jumps in.</p>
<p>A one off discontinuity is easy to model with a Gaussian process, or even multiple discontinuities. They can be introduced in the mean function, or independence can be forced between two covariance functions that apply in different areas of the input space. But in these cases we will need to specify the number of discontinuities and where they occur. In otherwords we need to <em>parameterise</em> the discontinuities. If we do not know the number of discontinuities and don’t wish to specify where they occur, i.e. if we want a non-parametric representation of discontinuities, then the standard Gaussian process doesn’t help.</p>
<h2 id="stochastic-process-composition">Stochastic Process Composition</h2>
<p>The deep Gaussian process leads to <em>non-Gaussian</em> models, and non-Gaussian characteristics in the covariance function. In effect, what we are proposing is that we change the properties of the functions we are considering by <em>composing stochastic processes</em>. This is an approach to creating new stochastic processes from well known processes.</p>
<p>Additionally, we are not constrained to the formalism of the chain. For example, we can easily add single nodes emerging from some point in the depth of the chain. This allows us to combine the benefits of the graphical modelling formalism, but with a powerful framework for relating one set of variables to another, that of Gaussian processes</p>
<div class="figure">
<div id="deep-markov-vertical-side-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/deep-markov-vertical-side.svg" width="15%" style=" ">
</object>
</div>
<div id="deep-markov-vertical-side-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-markov-vertical-side&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-markov-vertical-side-caption" class="caption-frame">
<p>Figure: More generally we aren’t constrained by the Markov chain. We can design structures that respect our belief about the underlying conditional dependencies. Here we are adding a side note from the chain.</p>
</div>
</div>
<h2 id="difficulty-for-probabilistic-approaches-edit">Difficulty for Probabilistic Approaches <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_dimred/includes/non-linear-difficulty.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_dimred/includes/non-linear-difficulty.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The challenge for composition of probabilistic models is that you need to propagate a probability densities through non linear mappings. This allows you to create broader classes of probability density. Unfortunately it renders the resulting densities <em>intractable</em>.</p>
<div class="figure">
<div id="nonlinear-mapping-3d-plot-figure" class="figure-frame">
<object class="svgplot 80%" data="../slides/diagrams/dimred/nonlinear-mapping-3d-plot.svg" width="center" style=" ">
</object>
</div>
<div id="nonlinear-mapping-3d-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;nonlinear-mapping-3d-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="nonlinear-mapping-3d-plot-caption" class="caption-frame">
<p>Figure: A two dimensional grid mapped into three dimensions to form a two dimensional manifold.</p>
</div>
</div>
<div class="figure">
<div id="non-linear-mapping-2d-plot-figure" class="figure-frame">
<object class="svgplot 80%" data="../slides/diagrams/dimred/nonlinear-mapping-2d-plot.svg" width="center" style=" ">
</object>
</div>
<div id="non-linear-mapping-2d-plot-magnify" class="magnify" onclick="magnifyFigure(&#39;non-linear-mapping-2d-plot&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="non-linear-mapping-2d-plot-caption" class="caption-frame">
<p>Figure: A one dimensional line mapped into two dimensions by two separate independent functions. Each point can be mapped exactly through the mappings.</p>
</div>
</div>
<div class="figure">
<div id="gaussian-through-nonlinear-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/dimred/gaussian-through-nonlinear.svg" width="80%" style=" ">
</object>
</div>
<div id="gaussian-through-nonlinear-magnify" class="magnify" onclick="magnifyFigure(&#39;gaussian-through-nonlinear&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gaussian-through-nonlinear-caption" class="caption-frame">
<p>Figure: A Gaussian density over the input of a non linear function leads to a very non Gaussian output. Here the output is multimodal.</p>
</div>
</div>
<h2 id="standard-variational-approach-fails-edit">Standard Variational Approach Fails <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gplvm/includes/variational-bayes-gplvm-long.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gplvm/includes/variational-bayes-gplvm-long.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<ul>
<li>Standard variational bound has the form: <br /><span class="math display">$$
\likelihoodBound = \expDist{\log p(\dataVector|\latentMatrix)}{q(\latentMatrix)} + \KL{q(\latentMatrix)}{p(\latentMatrix)}
$$</span><br /></li>
</ul>
<p>The standard variational approach would require the expectation of <span class="math inline">$\log p(\dataVector|\latentMatrix)$</span> under <span class="math inline">$q(\latentMatrix)$</span>. <br /><span class="math display">$$
  \begin{align}
  \log p(\dataVector|\latentMatrix) = &amp; -\frac{1}{2}\dataVector^\top\left(\kernelMatrix_{\mappingFunctionVector, \mappingFunctionVector}+\dataStd^2\eye\right)^{-1}\dataVector \\ &amp; -\frac{1}{2}\log \det{\kernelMatrix_{\mappingFunctionVector, \mappingFunctionVector}+\dataStd^2 \eye} -\frac{\numData}{2}\log 2\pi
  \end{align}
  $$</span><br /> But this is extremely difficult to compute because <span class="math inline">$\kernelMatrix_{\mappingFunctionVector, \mappingFunctionVector}$</span> is dependent on <span class="math inline">$\latentMatrix$</span> and it appears in the inverse.</p>
<h2 id="variational-bayesian-gp-lvm">Variational Bayesian GP-LVM</h2>
<p>The alternative approach is to consider the collapsed variational bound (used for low rank (sparse is a misnomer) Gaussian process approximations. <br /><span class="math display">$$
    p(\dataVector)\geq \prod_{i=1}^\numData c_i \int \gaussianDist{\dataVector}{\expSamp{\mappingFunctionVector}}{\dataStd^2\eye}p(\inducingVector) \text{d}\inducingVector
  $$</span><br /> <br /><span class="math display">$$
    p(\dataVector|\latentMatrix )\geq \prod_{i=1}^\numData c_i \int \gaussianDist{\dataVector}{\expDist{\mappingFunctionVector}{p(\mappingFunctionVector|\inducingVector, \latentMatrix)}}{\dataStd^2\eye}p(\inducingVector) \text{d}\inducingVector
  $$</span><br /> <br /><span class="math display">$$
      \int p(\dataVector|\latentMatrix)p(\latentMatrix) \text{d}\latentMatrix \geq \int \prod_{i=1}^\numData c_i \gaussianDist{\dataVector}{\expDist{\mappingFunctionVector}{p(\mappingFunctionVector|\inducingVector, \latentMatrix)}}{\dataStd^2\eye} p(\latentMatrix)\text{d}\latentMatrix p(\inducingVector) \text{d}\inducingVector
  $$</span><br /></p>
<p>To integrate across <span class="math inline">$\latentMatrix$</span> we apply the lower bound to the inner integral. <br /><span class="math display">$$
    \begin{align}
    \int \prod_{i=1}^\numData c_i \gaussianDist{\dataVector}{\expDist{\mappingFunctionVector}{p(\mappingFunctionVector|\inducingVector, \latentMatrix)}}{\dataStd^2\eye} p(\latentMatrix)\text{d}\latentMatrix \geq &amp; \expDist{\sum_{i=1}^\numData\log  c_i}{q(\latentMatrix)}\\ &amp; +\expDist{\log\gaussianDist{\dataVector}{\expDist{\mappingFunctionVector}{p(\mappingFunctionVector|\inducingVector, \latentMatrix)}}{\dataStd^2\eye}}{q(\latentMatrix)}\\&amp; + \KL{q(\latentMatrix)}{p(\latentMatrix)}    
    \end{align}
  $$</span><br /> * Which is analytically tractable for Gaussian <span class="math inline">$q(\latentMatrix)$</span> and some covariance functions.</p>
<ul>
<li><p>Need expectations under <span class="math inline">$q(\latentMatrix)$</span> of: <br /><span class="math display">$$
\log c_i = \frac{1}{2\dataStd^2} \left[\kernelScalar_{i, i} - \kernelVector_{i, \inducingVector}^\top \kernelMatrix_{\inducingVector, \inducingVector}^{-1} \kernelVector_{i, \inducingVector}\right]
$$</span><br /> and <br /><span class="math display">$$
\log \gaussianDist{\dataVector}{\expDist{\mappingFunctionVector}{p(\mappingFunctionVector|\inducingVector,\dataMatrix)}}{\dataStd^2\eye} = -\frac{1}{2}\log 2\pi\dataStd^2 - \frac{1}{2\dataStd^2}\left(\dataScalar_i - \kernelMatrix_{\mappingFunctionVector, \inducingVector}\kernelMatrix_{\inducingVector,\inducingVector}^{-1}\inducingVector\right)^2
$$</span><br /></p></li>
<li><p>This requires the expectations <br /><span class="math display">$$
\expDist{\kernelMatrix_{\mappingFunctionVector,\inducingVector}}{q(\latentMatrix)}
$$</span><br /> and <br /><span class="math display">$$
\expDist{\kernelMatrix_{\mappingFunctionVector,\inducingVector}\kernelMatrix_{\inducingVector,\inducingVector}^{-1}\kernelMatrix_{\inducingVector,\mappingFunctionVector}}{q(\latentMatrix)}
$$</span><br /> which can be computed analytically for some covariance functions <span class="citation" data-cites="Damianou:variational15">(Damianou, Titsias, and Lawrence 2016)</span> or through sampling <span class="citation" data-cites="Damianou:thesis2015 Salimbeni:doubly2017">(Damianou 2015; Salimbeni and Deisenroth 2017)</span>.</p></li>
</ul>
<p>Variational approximations aren’t the only approach to approximate inference. The original work on deep Gaussian processes made use of MAP approximations <span class="citation" data-cites="Lawrence:hgplvm07">(Lawrence and Moore 2007)</span>, which couldn’t propagate the uncertainty through the model at the data points but sustain uncertainty elsewhere. Since the variational approximation was proposed researchers have also considered sampling approaches <span class="citation" data-cites="Havasi:deepgp18">(Havasi, Hernández-Lobato, and Murillo-Fuentes 2018)</span> and expectation propagation <span class="citation" data-cites="Bui:deep16">(Bui et al. 2016)</span>.</p>
<div class="figure">
<div id="neural-network-uncertainty-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/deepgp/neural-network-uncertainty.png" width="90%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="neural-network-uncertainty-magnify" class="magnify" onclick="magnifyFigure(&#39;neural-network-uncertainty&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="neural-network-uncertainty-caption" class="caption-frame">
<p>Figure: Even the latest work on Bayesian neural networks has severe problems handling uncertainty. In this example, <span class="citation" data-cites="Izmailov:subspace19">(Izmailov et al. 2019)</span>, methods even fail to interpolate through the data correctly or provide well calibrated error bars in regions where data is observed.</p>
</div>
</div>
<p>The argument in the deep learning revolution is that deep architectures allow us to develop an abstraction of the feature set through model composition. Composing Gaussian processes is analytically intractable. To form deep Gaussian processes we use a variational approach to stack the models.</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb72-1" data-line-number="1"><span class="im">import</span> pods</a></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb73-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;stack-gp-sample-Linear-</span><span class="sc">{sample:0&gt;1}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb73-2" data-line-number="2">                            directory<span class="op">=</span><span class="st">&#39;../../slides/diagrams/deepgp&#39;</span>, sample<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">4</span>))</a></code></pre></div>
<h2 id="stacked-pca-edit">Stacked PCA <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stacked-pca.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stacked-pca.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="stack-pca-sample-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/stack-pca-sample-4.svg" width="20%" style=" ">
</object>
</div>
<div id="stack-pca-sample-magnify" class="magnify" onclick="magnifyFigure(&#39;stack-pca-sample&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="stack-pca-sample-caption" class="caption-frame">
<p>Figure: Composition of linear functions just leads to a new linear function. Here you see the result of multiple affine transformations applied to a square in two dimensions.</p>
</div>
</div>
<p>Stacking a series of linear functions simply leads to a new linear function. The use of multiple linear function merely changes the covariance of the resulting Gaussian. If <br /><span class="math display">$$
\latentMatrix \sim \gaussianSamp{\zerosVector}{\eye}
$$</span><br /> and the <span class="math inline"><em>i</em></span>th hidden layer is a multivariate linear transformation defined by <span class="math inline">$\weightMatrix_i$</span>, <br /><span class="math display">$$
\dataMatrix = \latentMatrix\weightMatrix_1 \weightMatrix_2 \dots \weightMatrix_\numLayers
$$</span><br /> then the rules of multivariate Gaussians tell us that <br /><span class="math display">$$
\dataMatrix \sim \gaussianSamp{\zerosVector}{\weightMatrix_\numLayers \dots \weightMatrix_1 \weightMatrix^\top_1 \dots \weightMatrix^\top_\numLayers}.
$$</span><br /> So the model can be replaced by one where we set <span class="math inline">$\vMatrix = \weightMatrix_\numLayers \dots \weightMatrix_2 \weightMatrix_1$</span>. So is such a model trivial? The answer is that it depends. There are two cases in which such a model remaisn interesting. Firstly, if we make intermediate observations stemming from the chain. So, for example, if we decide that, <br /><span class="math display">$$
\latentMatrix_i = \weightMatrix_i \latentMatrix_{i-1}
$$</span><br /> and set <span class="math inline">$\latentMatrix_{0} = \inputMatrix \sim \gaussianSamp{\zerosVector}{\eye}$</span>, then the matrices <span class="math inline">$\weightMatrix$</span> inter-relate a series of jointly Gaussian observations in an interesting way, stacking the full data matrix to give <br /><span class="math display">$$
\latentMatrix = \begin{bmatrix}
\latentMatrix_0 \\
\latentMatrix_1 \\
\vdots \\
\latentMatrix_\numLayers
\end{bmatrix}
$$</span><br /> we can obtain <br /><span class="math display">$$\latentMatrix \sim \gaussianSamp{\zerosVector}{\begin{bmatrix}
\eye &amp; \weightMatrix^\top_1 &amp; \weightMatrix_1^\top\weightMatrix_2^\top &amp; \dots &amp; \vMatrix^\top \\
\weightMatrix_1 &amp; \weightMatrix_1 \weightMatrix_1^\top &amp; \weightMatrix_1 \weightMatrix_1^\top \weightMatrix_2^\top &amp; \dots &amp; \weightMatrix_1 \vMatrix^\top \\
\weightMatrix_2 \weightMatrix_1 &amp; \weightMatrix_2 \weightMatrix_1 \weightMatrix_1^\top &amp; \weightMatrix_2 \weightMatrix_1 \weightMatrix_1^\top \weightMatrix_2^\top &amp; \dots &amp; \weightMatrix_2 \weightMatrix_1 \vMatrix^\top \\
\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
\vMatrix &amp; \vMatrix   \weightMatrix_1^\top  &amp; \vMatrix \weightMatrix_1^\top \weightMatrix_2^\top&amp; \dots &amp; \vMatrix\vMatrix^\top
\end{bmatrix}}$$</span><br /> which is a highly structured Gaussian covariance with hierarchical dependencies between the variables <span class="math inline">$\latentMatrix_i$</span>.</p>
<h2 id="stacked-gp-edit">Stacked GP <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stacked-gp.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/stacked-gp.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="sourceCode" id="cb74"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb74-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;stack-gp-sample-RBF-</span><span class="sc">{sample:0&gt;1}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb74-2" data-line-number="2">                            directory<span class="op">=</span><span class="st">&#39;../../slides/diagrams/deepgp&#39;</span>, sample<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">4</span>))</a></code></pre></div>
<div class="figure">
<div id="stack-gp-sample-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/stack-gp-sample-4.svg" width="20%" style=" ">
</object>
</div>
<div id="stack-gp-sample-magnify" class="magnify" onclick="magnifyFigure(&#39;stack-gp-sample&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="stack-gp-sample-caption" class="caption-frame">
<p>Figure: Stacking Gaussian process models leads to non linear mappings at each stage. Here we are mapping from two dimensions to two dimensions in each layer.</p>
</div>
</div>
<p>Note that once the box has folded over on itself, it cannot be unfolded. So a feature that is generated near the top of the model cannot be removed further down the model.</p>
<p>This folding over effect happens in low dimensions. In higher dimensions it is less common.</p>
<p>Observation of this effect at a talk in Cambridge was one of the things that caused David Duvenaud (and collaborators) to consider the behavior of deeper Gaussian process models <span class="citation" data-cites="Duvenaud:pathologies14">(Duvenaud et al. 2014)</span>.</p>
<p>Such folding over in the latent spaces necessarily forces the density to be non-Gaussian. Indeed, since folding-over is avoided as we increase the dimensionality of the latent spaces, such processes become more Gaussian. If we take the limit of the latent space dimensionality as it tends to infinity, the entire deep Gaussian process returns to a standard Gaussian process, with a covariance function given as a deep kernel (such as those described by <span class="citation" data-cites="Cho:deep09">Cho and Saul (2009)</span>).</p>
<p>Further analysis of these deep networks has been conducted by <span class="citation" data-cites="Dunlop:deep2017">Dunlop et al. (n.d.)</span>, who use analysis of the deep network’s stationary density (treating it as a Markov chain across layers), to explore the nature of the implied process prior for a deep GP.</p>
<p>Both of these works, however, make constraining assumptions on the form of the Gaussian process prior at each layer (e.g. same covariance at each layer). In practice, the form of this covariance can be learnt and the densities described by the deep GP are more general than those mentioned in either of these papers.</p>
<h2 id="stacked-gps-video-by-david-duvenaud-edit">Stacked GPs (video by David Duvenaud) <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-pathologies.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-pathologies.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="visualization-deep-gp-figure" class="figure-frame">
<iframe width="800" height="600" src="https://www.youtube.com/embed/XhIvygQYFFQ?start=" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen>
</iframe>
</div>
<div id="visualization-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;visualization-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="visualization-deep-gp-caption" class="caption-frame">
<p>Figure: Visualization of mapping of a two dimensional space through a deep Gaussian process.</p>
</div>
</div>
<p>David Duvenaud also created a YouTube video to help visualize what happens as you drop through the layers of a deep GP.</p>
<h2 id="gpy-a-gaussian-process-framework-in-python-edit">GPy: A Gaussian Process Framework in Python <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpy-software.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_gp/includes/gpy-software.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="gpy-software-figure" class="figure-frame">
<div class="centered" style="">
<img class="" src="../slides/diagrams/gp/gpy.png" width="70%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="gpy-software-magnify" class="magnify" onclick="magnifyFigure(&#39;gpy-software&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="gpy-software-caption" class="caption-frame">
<p>Figure: GPy is a BSD licensed software code base for implementing Gaussian process models in Python. It is designed for teaching and modelling. We welcome contributions which can be made through the Github repository <a href="https://github.com/SheffieldML/GPy" class="uri">https://github.com/SheffieldML/GPy</a></p>
</div>
</div>
<p>GPy is a BSD licensed software code base for implementing Gaussian process models in python. This allows GPs to be combined with a wide variety of software libraries.</p>
<p>The software itself is available on <a href="https://github.com/SheffieldML/GPy">GitHub</a> and the team welcomes contributions.</p>
<p>The aim for GPy is to be a probabilistic-style programming language, i.e. you specify the model rather than the algorithm. As well as a large range of covariance functions the software allows for non-Gaussian likelihoods, multivariate outputs, dimensionality reduction and approximations for larger data sets.</p>
<p>The GPy library can be installed via pip:</p>
<pre><code>pip install GPy</code></pre>
<p>This notebook depends on PyDeepGP. These libraries can be installed via pip:</p>
<pre><code>pip install git+https://github.com/SheffieldML/PyDeepGP.git</code></pre>
<h2 id="deep-gp-fit-edit">Deep GP Fit <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-olympic.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-olympic.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Let’s see if a deep Gaussian process can help here. We will construct a deep Gaussian process with one hidden layer (i.e. one Gaussian process feeding into another).</p>
<p>Build a Deep GP with an additional hidden layer (one dimensional) to fit the model.</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb77-1" data-line-number="1"><span class="im">import</span> GPy</a>
<a class="sourceLine" id="cb77-2" data-line-number="2"><span class="im">import</span> deepgp</a></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb78-1" data-line-number="1">hidden <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb78-2" data-line-number="2">m <span class="op">=</span> deepgp.DeepGP([y.shape[<span class="dv">1</span>],hidden,x.shape[<span class="dv">1</span>]],Y<span class="op">=</span>yhat, X<span class="op">=</span>x, inits<span class="op">=</span>[<span class="st">&#39;PCA&#39;</span>,<span class="st">&#39;PCA&#39;</span>], </a>
<a class="sourceLine" id="cb78-3" data-line-number="3">                  kernels<span class="op">=</span>[GPy.kern.RBF(hidden,ARD<span class="op">=</span><span class="va">True</span>),</a>
<a class="sourceLine" id="cb78-4" data-line-number="4">                           GPy.kern.RBF(x.shape[<span class="dv">1</span>],ARD<span class="op">=</span><span class="va">True</span>)], <span class="co"># the kernels for each layer</span></a>
<a class="sourceLine" id="cb78-5" data-line-number="5">                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</a></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb79-1" data-line-number="1"><span class="im">import</span> deepgp</a></code></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb80-1" data-line-number="1"><span class="co"># Call the initalization</span></a>
<a class="sourceLine" id="cb80-2" data-line-number="2">m.initialize()</a></code></pre></div>
<p>Now optimize the model.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb81-1" data-line-number="1"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:</a>
<a class="sourceLine" id="cb81-2" data-line-number="2">    layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb81-3" data-line-number="3">m.optimize(messages<span class="op">=</span><span class="va">True</span>,max_iters<span class="op">=</span><span class="dv">10000</span>)</a></code></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb82-1" data-line-number="1">m.staged_optimize(messages<span class="op">=</span>(<span class="va">True</span>,<span class="va">True</span>,<span class="va">True</span>))</a></code></pre></div>
<h2 id="olympic-marathon-data-deep-gp">Olympic Marathon Data Deep GP</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/olympic-marathon-deep-gp.svg" width="100%" style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-deep-gp-caption" class="caption-frame">
<p>Figure: Deep GP fit to the Olympic marathon data. Error bars now change as the prediction evolves.</p>
</div>
</div>
<div class="sourceCode" id="cb83"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb83-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb83-2" data-line-number="2">plot.model_sample(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, samps<span class="op">=</span><span class="dv">10</span>, ax<span class="op">=</span>ax, </a>
<a class="sourceLine" id="cb83-3" data-line-number="3">                  xlabel<span class="op">=</span><span class="st">&#39;year&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;pace min/km&#39;</span>, portion <span class="op">=</span> <span class="fl">0.225</span>)</a>
<a class="sourceLine" id="cb83-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb83-5" data-line-number="5">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb83-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/olympic-marathon-deep-gp-samples.svg&#39;</span>, </a>
<a class="sourceLine" id="cb83-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="olympic-marathon-data-deep-gp-1">Olympic Marathon Data Deep GP</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-samples-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-samples.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-samples&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-deep-gp-samples-caption" class="caption-frame">
<p>Figure: Point samples run through the deep Gaussian process show the distribution of output locations.</p>
</div>
</div>
<h2 id="fitted-gp-for-each-layer">Fitted GP for each layer</h2>
<p>Now we explore the GPs the model has used to fit each layer. First of all, we look at the hidden layer.</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb84-1" data-line-number="1">m.visualize(scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, xlabel<span class="op">=</span><span class="st">&#39;year&#39;</span>,</a>
<a class="sourceLine" id="cb84-2" data-line-number="2">            ylabel<span class="op">=</span><span class="st">&#39;pace min/km&#39;</span>,xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim,</a>
<a class="sourceLine" id="cb84-3" data-line-number="3">            dataset<span class="op">=</span><span class="st">&#39;olympic-marathon&#39;</span>,</a>
<a class="sourceLine" id="cb84-4" data-line-number="4">            diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb85"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb85-1" data-line-number="1"><span class="im">import</span> pods</a></code></pre></div>
<div class="sourceCode" id="cb86"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb86-1" data-line-number="1">pods.notebook.display_plots(<span class="st">&#39;olympic-marathon-deep-gp-layer-</span><span class="sc">{sample:0&gt;1}</span><span class="st">.svg&#39;</span>, </a>
<a class="sourceLine" id="cb86-2" data-line-number="2">                            <span class="st">&#39;../slides/diagrams/deepgp&#39;</span>, sample<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>))</a></code></pre></div>
<div class="figure">
<div id="olympic-marathon-deep-gp-layer-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-layer-0.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-layer-0-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-layer-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-deep-gp-layer-0-caption" class="caption-frame">
<p>Figure: The mapping from input to the latent layer is broadly, with some flattening as time goes on. Variance is high across the input range.</p>
</div>
</div>
<div class="figure">
<div id="olympic-marathon-deep-gp-layer-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-layer-1.svg" width style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-layer-1-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-layer-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-deep-gp-layer-1-caption" class="caption-frame">
<p>Figure: The mapping from the latent layer to the output layer.</p>
</div>
</div>
<div class="sourceCode" id="cb87"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb87-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb87-2" data-line-number="2">m.visualize_pinball(ax<span class="op">=</span>ax, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, points<span class="op">=</span><span class="dv">30</span>, portion<span class="op">=</span><span class="fl">0.1</span>,</a>
<a class="sourceLine" id="cb87-3" data-line-number="3">                    xlabel<span class="op">=</span><span class="st">&#39;year&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;pace km/min&#39;</span>, vertical<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb87-4" data-line-number="4">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/olympic-marathon-deep-gp-pinball.svg&#39;</span>, </a>
<a class="sourceLine" id="cb87-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="olympic-marathon-pinball-plot">Olympic Marathon Pinball Plot</h2>
<div class="figure">
<div id="olympic-marathon-deep-gp-pinball-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/olympic-marathon-deep-gp-pinball.svg" width="80%" style=" ">
</object>
</div>
<div id="olympic-marathon-deep-gp-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;olympic-marathon-deep-gp-pinball&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="olympic-marathon-deep-gp-pinball-caption" class="caption-frame">
<p>Figure: A pinball plot shows the movement of the ‘ball’ as it passes through each layer of the Gaussian processes. Mean directions of movement are shown by lines. Shading gives one standard deviation of movement position. At each layer, the uncertainty is reset. The overal uncertainty is the cumulative uncertainty from all the layers. There is some grouping of later points towards the right in the first layer, which also injects a large amount of uncertainty. Due to flattening of the curve in the second layer towards the right the uncertainty is reduced in final output.</p>
</div>
</div>
<p>The pinball plot shows the flow of any input ball through the deep Gaussian process. In a pinball plot a series of vertical parallel lines would indicate a purely linear function. For the olypmic marathon data we can see the first layer begins to shift from input towards the right. Note it also does so with some uncertainty (indicated by the shaded backgrounds). The second layer has less uncertainty, but bunches the inputs more strongly to the right. This input layer of uncertainty, followed by a layer that pushes inputs to the right is what gives the heteroschedastic noise.</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb88-1" data-line-number="1">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">1</span>,x.shape[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb88-2" data-line-number="2">inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb88-3" data-line-number="3">kernels <span class="op">=</span> []</a>
<a class="sourceLine" id="cb88-4" data-line-number="4"><span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:</a>
<a class="sourceLine" id="cb88-5" data-line-number="5">    kernels <span class="op">+=</span> [GPy.kern.RBF(i)]</a>
<a class="sourceLine" id="cb88-6" data-line-number="6">m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>yhat, X<span class="op">=</span>x, </a>
<a class="sourceLine" id="cb88-7" data-line-number="7">                  inits<span class="op">=</span>inits, </a>
<a class="sourceLine" id="cb88-8" data-line-number="8">                  kernels<span class="op">=</span>kernels, <span class="co"># the kernels for each layer</span></a>
<a class="sourceLine" id="cb88-9" data-line-number="9">                  num_inducing<span class="op">=</span><span class="dv">20</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</a></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb89-1" data-line-number="1">m.initialize()</a>
<a class="sourceLine" id="cb89-2" data-line-number="2">m.staged_optimize()</a></code></pre></div>
<div class="sourceCode" id="cb90"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb90-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb90-2" data-line-number="2">plot.model_output(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb90-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb90-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb90-5" data-line-number="5">mlai.write_figure(filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/della-gatta-gene-deep-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb90-6" data-line-number="6">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="della-gatta-gene-data-deep-gp-edit">Della Gatta Gene Data Deep GP <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-della-gatta.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-della-gatta.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="della-gatta-gene-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/della-gatta-gene-deep-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="della-gatta-gene-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-deep-gp-caption" class="caption-frame">
<p>Figure: Deep Gaussian process fit to the Della Gatta gene expression data.</p>
</div>
</div>
<div class="sourceCode" id="cb91"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb91-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb91-2" data-line-number="2">plot.model_sample(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, samps<span class="op">=</span><span class="dv">10</span>, ax<span class="op">=</span>ax, portion <span class="op">=</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb91-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb91-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb91-5" data-line-number="5">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/della-gatta-gene-deep-gp-samples.svg&#39;</span>, </a>
<a class="sourceLine" id="cb91-6" data-line-number="6">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="della-gatta-gene-data-deep-gp">Della Gatta Gene Data Deep GP</h2>
<div class="figure">
<div id="della-gatta-gene-deep-gp-samples-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/della-gatta-gene-deep-gp-samples.svg" width style=" ">
</object>
</div>
<div id="della-gatta-gene-deep-gp-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-deep-gp-samples&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-deep-gp-samples-caption" class="caption-frame">
<p>Figure: Deep Gaussian process samples fitted to the Della Gatta gene expression data.</p>
</div>
</div>
<div class="sourceCode" id="cb92"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb92-1" data-line-number="1">m.visualize(offset<span class="op">=</span>offset, scale<span class="op">=</span>scale, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim,</a>
<a class="sourceLine" id="cb92-2" data-line-number="2">            dataset<span class="op">=</span><span class="st">&#39;della-gatta-gene&#39;</span>,</a>
<a class="sourceLine" id="cb92-3" data-line-number="3">            diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp&#39;</span>)</a></code></pre></div>
<h2 id="della-gatta-gene-data-latent-1">Della Gatta Gene Data Latent 1</h2>
<div class="figure">
<div id="della-gatta-gene-deep-gp-layer-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/della-gatta-gene-deep-gp-layer-0.svg" width="50%" style=" ">
</object>
</div>
<div id="della-gatta-gene-deep-gp-layer-0-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-deep-gp-layer-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-deep-gp-layer-0-caption" class="caption-frame">
<p>Figure: Gaussian process mapping from input to latent layer for the della Gatta gene expression data.</p>
</div>
</div>
<h2 id="della-gatta-gene-data-latent-2">Della Gatta Gene Data Latent 2</h2>
<div class="figure">
<div id="della-gatta-gene-deep-gp-layer-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/della-gatta-gene-deep-gp-layer-1.svg" width="50%" style=" ">
</object>
</div>
<div id="della-gatta-gene-deep-gp-layer-1-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-deep-gp-layer-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-deep-gp-layer-1-caption" class="caption-frame">
<p>Figure: Gaussian process mapping from latent to output layer for the della Gatta gene expression data.</p>
</div>
</div>
<div class="sourceCode" id="cb93"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb93-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb93-2" data-line-number="2">m.visualize_pinball(offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, scale<span class="op">=</span>scale, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim, portion<span class="op">=</span><span class="fl">0.1</span>, points<span class="op">=</span><span class="dv">50</span>)</a>
<a class="sourceLine" id="cb93-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/della-gatta-gene-deep-gp-pinball.svg&#39;</span>, </a>
<a class="sourceLine" id="cb93-4" data-line-number="4">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax)</a></code></pre></div>
<h2 id="tp53-gene-pinball-plot">TP53 Gene Pinball Plot</h2>
<div class="figure">
<div id="della-gatta-gene-deep-gp-pinball-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/della-gatta-gene-deep-gp-pinball.svg" width="60%" style=" ">
</object>
</div>
<div id="della-gatta-gene-deep-gp-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;della-gatta-gene-deep-gp-pinball&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="della-gatta-gene-deep-gp-pinball-caption" class="caption-frame">
<p>Figure: A pinball plot shows the movement of the ‘ball’ as it passes through each layer of the Gaussian processes. Mean directions of movement are shown by lines. Shading gives one standard deviation of movement position. At each layer, the uncertainty is reset. The overal uncertainty is the cumulative uncertainty from all the layers. Pinball plot of the della Gatta gene expression data.</p>
</div>
</div>
<h2 id="step-function-edit">Step Function <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/step-function-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/step-function-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>Next we consider a simple step function data set.</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb94-1" data-line-number="1">num_low<span class="op">=</span><span class="dv">25</span></a>
<a class="sourceLine" id="cb94-2" data-line-number="2">num_high<span class="op">=</span><span class="dv">25</span></a>
<a class="sourceLine" id="cb94-3" data-line-number="3">gap <span class="op">=</span> <span class="fl">-.1</span></a>
<a class="sourceLine" id="cb94-4" data-line-number="4">noise<span class="op">=</span><span class="fl">0.0001</span></a>
<a class="sourceLine" id="cb94-5" data-line-number="5">x <span class="op">=</span> np.vstack((np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span>gap<span class="op">/</span><span class="fl">2.0</span>, num_low)[:, np.newaxis],</a>
<a class="sourceLine" id="cb94-6" data-line-number="6">              np.linspace(gap<span class="op">/</span><span class="fl">2.0</span>, <span class="dv">1</span>, num_high)[:, np.newaxis]))</a>
<a class="sourceLine" id="cb94-7" data-line-number="7">y <span class="op">=</span> np.vstack((np.zeros((num_low, <span class="dv">1</span>)), np.ones((num_high,<span class="dv">1</span>))))</a>
<a class="sourceLine" id="cb94-8" data-line-number="8">scale <span class="op">=</span> np.sqrt(y.var())</a>
<a class="sourceLine" id="cb94-9" data-line-number="9">offset <span class="op">=</span> y.mean()</a>
<a class="sourceLine" id="cb94-10" data-line-number="10">yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</a></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb95-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb95-2" data-line-number="2">_ <span class="op">=</span> ax.plot(x, y, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb95-3" data-line-number="3">_ <span class="op">=</span> ax.set_xlabel(<span class="st">&#39;$x$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb95-4" data-line-number="4">_ <span class="op">=</span> ax.set_ylabel(<span class="st">&#39;$y$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb95-5" data-line-number="5">xlim <span class="op">=</span> (<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb95-6" data-line-number="6">ylim <span class="op">=</span> (<span class="op">-</span><span class="fl">0.6</span>, <span class="fl">1.6</span>)</a>
<a class="sourceLine" id="cb95-7" data-line-number="7">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb95-8" data-line-number="8">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb95-9" data-line-number="9">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../../slides/diagrams/datasets/step-function.svg&#39;</span>, </a>
<a class="sourceLine" id="cb95-10" data-line-number="10">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="step-function-data">Step Function Data</h2>
<div class="figure">
<div id="step-function-data-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/step-function.svg" width="80%" style=" ">
</object>
</div>
<div id="step-function-data-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-data&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-data-caption" class="caption-frame">
<p>Figure: Simulation study of step function data artificially generated. Here there is a small overlap between the two lines.</p>
</div>
</div>
<h2 id="step-function-data-gp">Step Function Data GP</h2>
<p>We can fit a Gaussian process to the step function data using <code>GPy</code> as follows.</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb96-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb96-2" data-line-number="2">_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<p>Where <code>GPy.models.GPRegression()</code> gives us a standard GP regression model with exponentiated quadratic covariance function.</p>
<p>The model is optimized using <code>m_full.optimize()</code> which calls an L-BGFS gradient based solver in python.</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb97-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb97-2" data-line-number="2">plot.model_output(m_full, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb97-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb97-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb97-5" data-line-number="5"></a>
<a class="sourceLine" id="cb97-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig,filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/step-function-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb97-7" data-line-number="7">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="step-function-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/step-function-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="step-function-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the step function data. Note the large error bars and the over-smoothing of the discontinuity. Error bars are shown at two standard deviations.</p>
</div>
</div>
<p>The resulting fit to the step function data shows some challenges. In particular, the over smoothing at the discontinuity. If we know how many discontinuities there are, we can parameterize them in the step function. But by doing this, we form a semi-parametric model. The parameters indicate how many discontinuities are, and where they are. They can be optimized as part of the model fit. But if new, unforeseen, discontinuities arise when the model is being deployed in practice, these won’t be accounted for in the predictions.</p>
<h2 id="step-function-data-deep-gp">Step Function Data Deep GP</h2>
<p>First we initialize a deep Gaussian process with three latent layers (four layers total). Within each layer we create a GP with an exponentiated quadratic covariance (<code>GPy.kern.RBF</code>).</p>
<p>At each layer we use 20 inducing points for the variational approximation.</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb98-1" data-line-number="1">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,x.shape[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb98-2" data-line-number="2">inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb98-3" data-line-number="3">kernels <span class="op">=</span> []</a>
<a class="sourceLine" id="cb98-4" data-line-number="4"><span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:</a>
<a class="sourceLine" id="cb98-5" data-line-number="5">    kernels <span class="op">+=</span> [GPy.kern.RBF(i)]</a>
<a class="sourceLine" id="cb98-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb98-7" data-line-number="7">m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>yhat, X<span class="op">=</span>x, </a>
<a class="sourceLine" id="cb98-8" data-line-number="8">                  inits<span class="op">=</span>inits, </a>
<a class="sourceLine" id="cb98-9" data-line-number="9">                  kernels<span class="op">=</span>kernels, <span class="co"># the kernels for each layer</span></a>
<a class="sourceLine" id="cb98-10" data-line-number="10">                  num_inducing<span class="op">=</span><span class="dv">20</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</a></code></pre></div>
<p>Once the model is constructed we initialize the parameters, and perform the staged optimization which starts by optimizing variational parameters with a low noise and proceeds to optimize the whole model.</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb99-1" data-line-number="1">m.initialize()</a>
<a class="sourceLine" id="cb99-2" data-line-number="2">m.staged_optimize()</a></code></pre></div>
<p>We plot the output of the deep Gaussian process fitted to the stpe data as follows.</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb100-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb100-2" data-line-number="2">plot.model_output(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb100-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb100-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb100-5" data-line-number="5">mlai.write_figure(filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/step-function-deep-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb100-6" data-line-number="6">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>The deep Gaussian process does a much better job of fitting the data. It handles the discontinuity easily, and error bars drop to smaller values in the regions of data.</p>
<div class="figure">
<div id="step-function-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="step-function-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-deep-gp-caption" class="caption-frame">
<p>Figure: Deep Gaussian process fit to the step function data.</p>
</div>
</div>
<h2 id="step-function-data-deep-gp-1">Step Function Data Deep GP</h2>
<p>The samples of the model can be plotted with the helper function from <code>teaching_plots.py</code>, <code>model_sample</code></p>
<div class="sourceCode" id="cb101"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb101-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb101-2" data-line-number="2"></a>
<a class="sourceLine" id="cb101-3" data-line-number="3">plot.model_sample(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, samps<span class="op">=</span><span class="dv">10</span>, ax<span class="op">=</span>ax, portion <span class="op">=</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb101-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb101-5" data-line-number="5">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb101-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/step-function-deep-gp-samples.svg&#39;</span>, </a>
<a class="sourceLine" id="cb101-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>The samples from the model show that the error bars, which are informative for Gaussian outputs, are less informative for this model. They make clear that the data points lie, in output mainly at 0 or 1, or occasionally in between.</p>
<div class="figure">
<div id="step-function-deep-gp-samples-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-samples.svg" width="80%" style=" ">
</object>
</div>
<div id="step-function-deep-gp-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-deep-gp-samples&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-deep-gp-samples-caption" class="caption-frame">
<p>Figure: Samples from the deep Gaussian process model for the step function fit.</p>
</div>
</div>
<p>The visualize code allows us to inspect the intermediate layers in the deep GP model to understand how it has reconstructed the step function.</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb102-1" data-line-number="1">m.visualize(offset<span class="op">=</span>offset, scale<span class="op">=</span>scale, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim,</a>
<a class="sourceLine" id="cb102-2" data-line-number="2">            dataset<span class="op">=</span><span class="st">&#39;step-function&#39;</span>,</a>
<a class="sourceLine" id="cb102-3" data-line-number="3">            diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp&#39;</span>)</a></code></pre></div>
<div class="figure">
<div id="step-function-deep-gp-mappings-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-layer-0.svg" width="60%" style=" ">
</object>
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-layer-1.svg" width="60%" style=" ">
</object>
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-layer-2.svg" width="60%" style=" ">
</object>
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-layer-3.svg" width="60%" style=" ">
</object>
</div>
<div id="step-function-deep-gp-mappings-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-deep-gp-mappings&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-deep-gp-mappings-caption" class="caption-frame">
<p>Figure: From top to bottom, the Gaussian process mapping function that makes up each layer of the resulting deep Gaussian process.</p>
</div>
</div>
<p>A pinball plot can be created for the resulting model to understand how the input is being translated to the output across the different layers.</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb103-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb103-2" data-line-number="2">m.visualize_pinball(offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, scale<span class="op">=</span>scale, xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim, portion<span class="op">=</span><span class="fl">0.1</span>, points<span class="op">=</span><span class="dv">50</span>)</a>
<a class="sourceLine" id="cb103-3" data-line-number="3">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/step-function-deep-gp-pinball.svg&#39;</span>, </a>
<a class="sourceLine" id="cb103-4" data-line-number="4">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>, ax<span class="op">=</span>ax)</a></code></pre></div>
<div class="figure">
<div id="step-function-deep-gp-pinball-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/step-function-deep-gp-pinball.svg" width="60%" style=" ">
</object>
</div>
<div id="step-function-deep-gp-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;step-function-deep-gp-pinball&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="step-function-deep-gp-pinball-caption" class="caption-frame">
<p>Figure: Pinball plot of the deep GP fitted to the step function data. Each layer of the model pushes the ‘ball’ towards the left or right, saturating at 1 and 0. This causes the final density to be be peaked at 0 and 1. Transitions occur driven by the uncertainty of the mapping in each layer.</p>
</div>
</div>
<div class="sourceCode" id="cb104"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb104-1" data-line-number="1"><span class="im">import</span> pods</a></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb105-1" data-line-number="1">data <span class="op">=</span> pods.datasets.mcycle()</a>
<a class="sourceLine" id="cb105-2" data-line-number="2">x <span class="op">=</span> data[<span class="st">&#39;X&#39;</span>]</a>
<a class="sourceLine" id="cb105-3" data-line-number="3">y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</a>
<a class="sourceLine" id="cb105-4" data-line-number="4">scale<span class="op">=</span>np.sqrt(y.var())</a>
<a class="sourceLine" id="cb105-5" data-line-number="5">offset<span class="op">=</span>y.mean()</a>
<a class="sourceLine" id="cb105-6" data-line-number="6">yhat <span class="op">=</span> (y <span class="op">-</span> offset)<span class="op">/</span>scale</a></code></pre></div>
<div class="sourceCode" id="cb106"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb106-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb106-2" data-line-number="2">_ <span class="op">=</span> ax.plot(x, y, <span class="st">&#39;r.&#39;</span>,markersize<span class="op">=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb106-3" data-line-number="3">_ <span class="op">=</span> ax.set_xlabel(<span class="st">&#39;time&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb106-4" data-line-number="4">_ <span class="op">=</span> ax.set_ylabel(<span class="st">&#39;acceleration&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb106-5" data-line-number="5">xlim <span class="op">=</span> (<span class="op">-</span><span class="dv">20</span>, <span class="dv">80</span>)</a>
<a class="sourceLine" id="cb106-6" data-line-number="6">ylim <span class="op">=</span> (<span class="op">-</span><span class="dv">175</span>, <span class="dv">125</span>)</a>
<a class="sourceLine" id="cb106-7" data-line-number="7">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb106-8" data-line-number="8">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb106-9" data-line-number="9">mlai.write_figure(filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/datasets/motorcycle-helmet.svg&#39;</span>, </a>
<a class="sourceLine" id="cb106-10" data-line-number="10">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="motorcycle-helmet-data-edit">Motorcycle Helmet Data <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/motorcycle-helmet-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/motorcycle-helmet-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="motorcycle-helment-data-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/motorcycle-helmet.svg" width="80%" style=" ">
</object>
</div>
<div id="motorcycle-helment-data-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helment-data&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helment-data-caption" class="caption-frame">
<p>Figure: Motorcycle helmet data. The data consists of acceleration readings on a motorcycle helmet undergoing a collision. The data exhibits heteroschedastic (time varying) noise levles and non-stationarity.</p>
</div>
</div>
<div class="sourceCode" id="cb107"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb107-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb107-2" data-line-number="2">_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<h2 id="motorcycle-helmet-data-gp">Motorcycle Helmet Data GP</h2>
<div class="figure">
<div id="motorcycle-helmet-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/motorcycle-helmet-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-gp-caption" class="caption-frame">
<p>Figure: Gaussian process fit to the motorcycle helmet accelerometer data.</p>
</div>
</div>
<div class="sourceCode" id="cb108"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb108-1" data-line-number="1"><span class="im">import</span> deepgp</a></code></pre></div>
<div class="sourceCode" id="cb109"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb109-1" data-line-number="1">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">1</span>, x.shape[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb109-2" data-line-number="2">inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb109-3" data-line-number="3">kernels <span class="op">=</span> []</a>
<a class="sourceLine" id="cb109-4" data-line-number="4"><span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:</a>
<a class="sourceLine" id="cb109-5" data-line-number="5">    kernels <span class="op">+=</span> [GPy.kern.RBF(i)]</a>
<a class="sourceLine" id="cb109-6" data-line-number="6">m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>yhat, X<span class="op">=</span>x, </a>
<a class="sourceLine" id="cb109-7" data-line-number="7">                  inits<span class="op">=</span>inits, </a>
<a class="sourceLine" id="cb109-8" data-line-number="8">                  kernels<span class="op">=</span>kernels, <span class="co"># the kernels for each layer</span></a>
<a class="sourceLine" id="cb109-9" data-line-number="9">                  num_inducing<span class="op">=</span><span class="dv">20</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb109-10" data-line-number="10"></a>
<a class="sourceLine" id="cb109-11" data-line-number="11"></a>
<a class="sourceLine" id="cb109-12" data-line-number="12"></a>
<a class="sourceLine" id="cb109-13" data-line-number="13">m.initialize()</a></code></pre></div>
<div class="sourceCode" id="cb110"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb110-1" data-line-number="1">m.staged_optimize(iters<span class="op">=</span>(<span class="dv">1000</span>,<span class="dv">1000</span>,<span class="dv">10000</span>), messages<span class="op">=</span>(<span class="va">True</span>, <span class="va">True</span>, <span class="va">True</span>))</a></code></pre></div>
<div class="sourceCode" id="cb111"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb111-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a>
<a class="sourceLine" id="cb111-2" data-line-number="2"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb112"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb112-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb112-2" data-line-number="2">plot.model_output(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;acceleration/$g$&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb112-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb112-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb112-5" data-line-number="5">mlai.write_figure(filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/motorcycle-helmet-deep-gp.svg&#39;</span>, </a>
<a class="sourceLine" id="cb112-6" data-line-number="6">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="motorcycle-helmet-data-deep-gp">Motorcycle Helmet Data Deep GP</h2>
<div class="figure">
<div id="motorcycle-helmet-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-deep-gp-caption" class="caption-frame">
<p>Figure: Deep Gaussian process fit to the motorcycle helmet accelerometer data.</p>
</div>
</div>
<div class="sourceCode" id="cb113"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb113-1" data-line-number="1"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a>
<a class="sourceLine" id="cb113-2" data-line-number="2"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb114"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb114-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb114-2" data-line-number="2">plot.model_sample(m, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, samps<span class="op">=</span><span class="dv">10</span>, ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;acceleration/$g$&#39;</span>, portion <span class="op">=</span> <span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb114-3" data-line-number="3">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb114-4" data-line-number="4">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb114-5" data-line-number="5"></a>
<a class="sourceLine" id="cb114-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-samples.svg&#39;</span>, </a>
<a class="sourceLine" id="cb114-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="motorcycle-helmet-data-deep-gp-1">Motorcycle Helmet Data Deep GP</h2>
<div class="figure">
<div id="motorcycle-helmet-deep-gp-samples-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-samples.svg" width="80%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-deep-gp-samples-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-deep-gp-samples&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-deep-gp-samples-caption" class="caption-frame">
<p>Figure: Samples from the deep Gaussian process as fitted to the motorcycle helmet accelerometer data.</p>
</div>
</div>
<div class="sourceCode" id="cb115"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb115-1" data-line-number="1">m.visualize(xlim<span class="op">=</span>xlim, ylim<span class="op">=</span>ylim, scale<span class="op">=</span>scale,offset<span class="op">=</span>offset, </a>
<a class="sourceLine" id="cb115-2" data-line-number="2">            xlabel<span class="op">=</span><span class="st">&quot;time&quot;</span>, ylabel<span class="op">=</span><span class="st">&quot;acceleration/$g$&quot;</span>, portion<span class="op">=</span><span class="fl">0.5</span>,</a>
<a class="sourceLine" id="cb115-3" data-line-number="3">            dataset<span class="op">=</span><span class="st">&#39;motorcycle-helmet&#39;</span>,</a>
<a class="sourceLine" id="cb115-4" data-line-number="4">            diagrams<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp&#39;</span>)</a></code></pre></div>
<h2 id="motorcycle-helmet-data-latent-1">Motorcycle Helmet Data Latent 1</h2>
<div class="figure">
<div id="motorcycle-helmet-deep-gp-layer-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-layer-0.svg" width="60%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-deep-gp-layer-0-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-deep-gp-layer-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-deep-gp-layer-0-caption" class="caption-frame">
<p>Figure: Mappings from the input to the latent layer for the motorcycle helmet accelerometer data.</p>
</div>
</div>
<h2 id="motorcycle-helmet-data-latent-2">Motorcycle Helmet Data Latent 2</h2>
<div class="figure">
<div id="motorcycle-helmet-deep-gp-layer-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-layer-1.svg" width="60%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-deep-gp-layer-1-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-deep-gp-layer-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-deep-gp-layer-1-caption" class="caption-frame">
<p>Figure: Mappings from the latent layer to the output layer for the motorcycle helmet accelerometer data.</p>
</div>
</div>
<div class="sourceCode" id="cb116"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb116-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb116-2" data-line-number="2">m.visualize_pinball(ax<span class="op">=</span>ax, xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;acceleration/g&#39;</span>, </a>
<a class="sourceLine" id="cb116-3" data-line-number="3">                    points<span class="op">=</span><span class="dv">50</span>, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, portion<span class="op">=</span><span class="fl">0.1</span>)</a>
<a class="sourceLine" id="cb116-4" data-line-number="4">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-pinball.svg&#39;</span>, </a>
<a class="sourceLine" id="cb116-5" data-line-number="5">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="motorcycle-helmet-pinball-plot">Motorcycle Helmet Pinball Plot</h2>
<div class="figure">
<div id="motorcycle-helmet-deep-gp-pinball-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/motorcycle-helmet-deep-gp-pinball.svg" width="60%" style=" ">
</object>
</div>
<div id="motorcycle-helmet-deep-gp-pinball-magnify" class="magnify" onclick="magnifyFigure(&#39;motorcycle-helmet-deep-gp-pinball&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="motorcycle-helmet-deep-gp-pinball-caption" class="caption-frame">
<p>Figure: Pinball plot for the mapping from input to output layer for the motorcycle helmet accelerometer data.</p>
</div>
</div>
<h2 id="robot-wireless-data-edit">Robot Wireless Data <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/robot-wireless-data.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_ml/includes/robot-wireless-data.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>The robot wireless data is taken from an experiment run by Brian Ferris at University of Washington. It consists of the measurements of WiFi access point signal strengths as Brian walked in a loop.</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb117-1" data-line-number="1">data<span class="op">=</span>pods.datasets.robot_wireless()</a>
<a class="sourceLine" id="cb117-2" data-line-number="2"></a>
<a class="sourceLine" id="cb117-3" data-line-number="3">x <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">215</span>)[:, np.newaxis]</a>
<a class="sourceLine" id="cb117-4" data-line-number="4">y <span class="op">=</span> data[<span class="st">&#39;Y&#39;</span>]</a>
<a class="sourceLine" id="cb117-5" data-line-number="5">offset <span class="op">=</span> y.mean()</a>
<a class="sourceLine" id="cb117-6" data-line-number="6">scale <span class="op">=</span> np.sqrt(y.var())</a>
<a class="sourceLine" id="cb117-7" data-line-number="7">yhat <span class="op">=</span> (y<span class="op">-</span>offset)<span class="op">/</span>scale</a></code></pre></div>
<p>The ground truth is recorded in the data, the actual loop is given in the plot below.</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb118-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_figsize)</a>
<a class="sourceLine" id="cb118-2" data-line-number="2">plt.plot(data[<span class="st">&#39;X&#39;</span>][:, <span class="dv">1</span>], data[<span class="st">&#39;X&#39;</span>][:, <span class="dv">2</span>], <span class="st">&#39;r.&#39;</span>, markersize<span class="op">=</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb118-3" data-line-number="3">ax.set_xlabel(<span class="st">&#39;x position&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb118-4" data-line-number="4">ax.set_ylabel(<span class="st">&#39;y position&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb118-5" data-line-number="5">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../../slides/diagrams/datasets/robot-wireless-ground-truth.svg&#39;</span>, transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="robot-wireless-ground-truth">Robot Wireless Ground Truth</h2>
<div class="figure">
<div id="robot-wireless-ground-truth-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/robot-wireless-ground-truth.svg" width="60%" style=" ">
</object>
</div>
<div id="robot-wireless-ground-truth-magnify" class="magnify" onclick="magnifyFigure(&#39;robot-wireless-ground-truth&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="robot-wireless-ground-truth-caption" class="caption-frame">
<p>Figure: Ground truth movement for the position taken while recording the multivariate time-course of wireless access point signal strengths.</p>
</div>
</div>
<p>We will ignore this ground truth in making our predictions, but see if the model can recover something similar in one of the latent layers.</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb119-1" data-line-number="1">output_dim<span class="op">=</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb119-2" data-line-number="2">xlim <span class="op">=</span> (<span class="op">-</span><span class="fl">0.3</span>, <span class="fl">1.3</span>)</a>
<a class="sourceLine" id="cb119-3" data-line-number="3">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb119-4" data-line-number="4">_ <span class="op">=</span> ax.plot(x.flatten(), y[:, output_dim], </a>
<a class="sourceLine" id="cb119-5" data-line-number="5">            <span class="st">&#39;r.&#39;</span>, markersize<span class="op">=</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb119-6" data-line-number="6"></a>
<a class="sourceLine" id="cb119-7" data-line-number="7">ax.set_xlabel(<span class="st">&#39;time&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb119-8" data-line-number="8">ax.set_ylabel(<span class="st">&#39;signal strength&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb119-9" data-line-number="9">xlim <span class="op">=</span> (<span class="op">-</span><span class="fl">0.2</span>, <span class="fl">1.2</span>)</a>
<a class="sourceLine" id="cb119-10" data-line-number="10">ylim <span class="op">=</span> (<span class="op">-</span><span class="fl">0.6</span>, <span class="fl">2.0</span>)</a>
<a class="sourceLine" id="cb119-11" data-line-number="11">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb119-12" data-line-number="12">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb119-13" data-line-number="13"></a>
<a class="sourceLine" id="cb119-14" data-line-number="14">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/datasets/robot-wireless-dim-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(output_dim) <span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, </a>
<a class="sourceLine" id="cb119-15" data-line-number="15">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="robot-wifi-data">Robot WiFi Data</h2>
<div class="figure">
<div id="robot-wireless-data-dim-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/datasets/robot-wireless-dim-1.svg" width="60%" style=" ">
</object>
</div>
<div id="robot-wireless-data-dim-1-magnify" class="magnify" onclick="magnifyFigure(&#39;robot-wireless-data-dim-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="robot-wireless-data-dim-1-caption" class="caption-frame">
<p>Figure: Output dimension 1 from the robot wireless data. This plot shows signal strength changing over time.</p>
</div>
</div>
<p>Perform a Gaussian process fit on the data using GPy.</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb120-1" data-line-number="1">m_full <span class="op">=</span> GPy.models.GPRegression(x,yhat)</a>
<a class="sourceLine" id="cb120-2" data-line-number="2">_ <span class="op">=</span> m_full.optimize() <span class="co"># Optimize parameters of covariance function</span></a></code></pre></div>
<div class="sourceCode" id="cb121"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb121-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb121-2" data-line-number="2">plot.model_output(m_full, output_dim<span class="op">=</span>output_dim, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, </a>
<a class="sourceLine" id="cb121-3" data-line-number="3">                  xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;signal strength&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb121-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb121-5" data-line-number="5">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb121-6" data-line-number="6">mlai.write_figure(filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/gp/robot-wireless-gp-dim-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(output_dim)<span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, </a>
<a class="sourceLine" id="cb121-7" data-line-number="7">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="robot-wifi-data-gp">Robot WiFi Data GP</h2>
<div class="figure">
<div id="-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/gp/robot-wireless-gp-dim-1.svg" width="80%" style=" ">
</object>
</div>
<div id="-magnify" class="magnify" onclick="magnifyFigure(&#39;&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="-caption" class="caption-frame">
<p>Figure:</p>
</div>
</div>
<p>}{Gaussian process fit to the Robot Wireless dimension 1.}{robot-wireless-gp-dim-1}</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb122-1" data-line-number="1">layers <span class="op">=</span> [y.shape[<span class="dv">1</span>], <span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">2</span>, x.shape[<span class="dv">1</span>]]</a>
<a class="sourceLine" id="cb122-2" data-line-number="2">inits <span class="op">=</span> [<span class="st">&#39;PCA&#39;</span>]<span class="op">*</span>(<span class="bu">len</span>(layers)<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb122-3" data-line-number="3">kernels <span class="op">=</span> []</a>
<a class="sourceLine" id="cb122-4" data-line-number="4"><span class="cf">for</span> i <span class="kw">in</span> layers[<span class="dv">1</span>:]:</a>
<a class="sourceLine" id="cb122-5" data-line-number="5">    kernels <span class="op">+=</span> [GPy.kern.RBF(i, ARD<span class="op">=</span><span class="va">True</span>)]</a></code></pre></div>
<div class="sourceCode" id="cb123"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb123-1" data-line-number="1">m <span class="op">=</span> deepgp.DeepGP(layers,Y<span class="op">=</span>y, X<span class="op">=</span>x, inits<span class="op">=</span>inits, </a>
<a class="sourceLine" id="cb123-2" data-line-number="2">                  kernels<span class="op">=</span>kernels,</a>
<a class="sourceLine" id="cb123-3" data-line-number="3">                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb123-4" data-line-number="4">m.initialize()</a></code></pre></div>
<div class="sourceCode" id="cb124"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb124-1" data-line-number="1">m.staged_optimize(messages<span class="op">=</span>(<span class="va">True</span>,<span class="va">True</span>,<span class="va">True</span>))</a></code></pre></div>
<div class="sourceCode" id="cb125"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb125-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb125-2" data-line-number="2">plot.model_output(m, output_dim<span class="op">=</span>output_dim, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, ax<span class="op">=</span>ax, </a>
<a class="sourceLine" id="cb125-3" data-line-number="3">                  xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;signal strength&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb125-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb125-5" data-line-number="5">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb125-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/robot-wireless-deep-gp-dim-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(output_dim)<span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, </a>
<a class="sourceLine" id="cb125-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="robot-wifi-data-deep-gp">Robot WiFi Data Deep GP</h2>
<div class="figure">
<div id="robot-wireless-deep-gp-dim-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/robot-wireless-deep-gp-dim-1.svg" width="80%" style=" ">
</object>
</div>
<div id="robot-wireless-deep-gp-dim-1-magnify" class="magnify" onclick="magnifyFigure(&#39;robot-wireless-deep-gp-dim-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="robot-wireless-deep-gp-dim-1-caption" class="caption-frame">
<p>Figure: Fit of the deep Gaussian process to dimension 1 of the robot wireless data.</p>
</div>
</div>
<div class="sourceCode" id="cb126"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb126-1" data-line-number="1">fig, ax<span class="op">=</span>plt.subplots(figsize<span class="op">=</span>plot.big_wide_figsize)</a>
<a class="sourceLine" id="cb126-2" data-line-number="2">plot.model_sample(m, output_dim<span class="op">=</span>output_dim, scale<span class="op">=</span>scale, offset<span class="op">=</span>offset, samps<span class="op">=</span><span class="dv">10</span>, ax<span class="op">=</span>ax,</a>
<a class="sourceLine" id="cb126-3" data-line-number="3">                  xlabel<span class="op">=</span><span class="st">&#39;time&#39;</span>, ylabel<span class="op">=</span><span class="st">&#39;signal strength&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>, portion<span class="op">=</span><span class="fl">0.5</span>)</a>
<a class="sourceLine" id="cb126-4" data-line-number="4">ax.set_ylim(ylim)</a>
<a class="sourceLine" id="cb126-5" data-line-number="5">ax.set_xlim(xlim)</a>
<a class="sourceLine" id="cb126-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/robot-wireless-deep-gp-samples-dim-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(output_dim)<span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, </a>
<a class="sourceLine" id="cb126-7" data-line-number="7">                  transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<h2 id="robot-wifi-data-deep-gp-1">Robot WiFi Data Deep GP</h2>
<div class="figure">
<div id="robot-wireless-deep-gp-samples-dim-1-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/robot-wireless-deep-gp-samples-dim-1.svg" width="80%" style=" ">
</object>
</div>
<div id="robot-wireless-deep-gp-samples-dim-1-magnify" class="magnify" onclick="magnifyFigure(&#39;robot-wireless-deep-gp-samples-dim-1&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="robot-wireless-deep-gp-samples-dim-1-caption" class="caption-frame">
<p>Figure: Samples from the deep Gaussian process fit to dimension 1 of the robot wireless data.</p>
</div>
</div>
<h2 id="robot-wifi-data-latent-space">Robot WiFi Data Latent Space</h2>
<p>}</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb127-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_figsize)</a>
<a class="sourceLine" id="cb127-2" data-line-number="2">ax.plot(m.layers[<span class="op">-</span><span class="dv">2</span>].latent_space.mean[:, <span class="dv">0</span>], </a>
<a class="sourceLine" id="cb127-3" data-line-number="3">        m.layers[<span class="op">-</span><span class="dv">2</span>].latent_space.mean[:, <span class="dv">1</span>], </a>
<a class="sourceLine" id="cb127-4" data-line-number="4">        <span class="st">&#39;r.-&#39;</span>, markersize<span class="op">=</span><span class="dv">5</span>)</a>
<a class="sourceLine" id="cb127-5" data-line-number="5"></a>
<a class="sourceLine" id="cb127-6" data-line-number="6">ax.set_xlabel(<span class="st">&#39;latent dimension 1&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb127-7" data-line-number="7">ax.set_ylabel(<span class="st">&#39;latent dimension 2&#39;</span>, fontsize<span class="op">=</span><span class="dv">20</span>)</a>
<a class="sourceLine" id="cb127-8" data-line-number="8"></a>
<a class="sourceLine" id="cb127-9" data-line-number="9">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&#39;../slides/diagrams/deepgp/robot-wireless-latent-space.svg&#39;</span>, </a>
<a class="sourceLine" id="cb127-10" data-line-number="10">            transparent<span class="op">=</span><span class="va">True</span>, frameon<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="robot-wireless-latent-space-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deepgp/robot-wireless-latent-space.svg" width="60%" style=" ">
</object>
</div>
<div id="robot-wireless-latent-space-magnify" class="magnify" onclick="magnifyFigure(&#39;robot-wireless-latent-space&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="robot-wireless-latent-space-caption" class="caption-frame">
<p>Figure: Inferred two dimensional latent space of the model for the robot wireless data.</p>
</div>
</div>
<h2 id="motion-capture-edit">Motion Capture <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-high-five.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-high-five.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<ul>
<li>‘High five’ data.</li>
<li>Model learns structure between two interacting subjects.</li>
</ul>
<h2 id="shared-lvm">Shared LVM</h2>
<div class="figure">
<div id="shared-latent-variable-model-graph-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/shared.svg" width="60%" style=" ">
</object>
</div>
<div id="shared-latent-variable-model-graph-magnify" class="magnify" onclick="magnifyFigure(&#39;shared-latent-variable-model-graph&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="shared-latent-variable-model-graph-caption" class="caption-frame">
<p>Figure: Shared latent variable model structure. Here two related data sets are brought together with a set of latent variables that are partially shared and partially specific to one of the data sets.</p>
</div>
</div>
<div class="figure">
<div id="deep-gp-high-five-figure" class="figure-frame">
<p><img class="" src="../slides/diagrams/deep-gp-high-five2.png" width="80%" height="auto" align="" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle"></p>
</div>
<div id="deep-gp-high-five-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-gp-high-five&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-gp-high-five-caption" class="caption-frame">
<p>Figure: Latent spaces of the ‘high five’ data. The structure of the model is automatically learnt. One of the latent spaces is coordinating how the two figures walk together, the other latent spaces contain latent variables that are specific to each of the figures separately.</p>
</div>
</div>
<h2 id="fitting-a-gp-to-the-usps-digits-data-edit">Fitting a GP to the USPS Digits Data <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-usps-digits.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_deepgp/includes/deep-usps-digits.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p><small><span style="text-align:right">Thanks to: Zhenwen Dai and Neil D. Lawrence</span></small></p>
<p>We now look at the deep Gaussian processes’ capacity to perform unsupervised learning.</p>
<p>We will look at a sub-sample of the MNIST digit data set.</p>
<p>First load in the MNIST data set from scikit learn. This can take a little while because it’s large to download.</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb128-1" data-line-number="1"><span class="im">from</span> sklearn.datasets <span class="im">import</span> fetch_mldata</a></code></pre></div>
<div class="sourceCode" id="cb129"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb129-1" data-line-number="1">mnist <span class="op">=</span> fetch_mldata(<span class="st">&#39;MNIST original&#39;</span>)</a></code></pre></div>
<p>Sub-sample the dataset to make the training faster.</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb130-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a></code></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb131-1" data-line-number="1">np.random.seed(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb131-2" data-line-number="2">digits <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb131-3" data-line-number="3">N_per_digit <span class="op">=</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb131-4" data-line-number="4">Y <span class="op">=</span> []</a>
<a class="sourceLine" id="cb131-5" data-line-number="5">labels <span class="op">=</span> []</a>
<a class="sourceLine" id="cb131-6" data-line-number="6"><span class="cf">for</span> d <span class="kw">in</span> digits:</a>
<a class="sourceLine" id="cb131-7" data-line-number="7">    imgs <span class="op">=</span> mnist[<span class="st">&#39;data&#39;</span>][mnist[<span class="st">&#39;target&#39;</span>]<span class="op">==</span>d]</a>
<a class="sourceLine" id="cb131-8" data-line-number="8">    Y.append(imgs[np.random.permutation(imgs.shape[<span class="dv">0</span>])][:N_per_digit])</a>
<a class="sourceLine" id="cb131-9" data-line-number="9">    labels.append(np.ones(N_per_digit)<span class="op">*</span>d)</a>
<a class="sourceLine" id="cb131-10" data-line-number="10">Y <span class="op">=</span> np.vstack(Y).astype(np.float64)</a>
<a class="sourceLine" id="cb131-11" data-line-number="11">labels <span class="op">=</span> np.hstack(labels)</a>
<a class="sourceLine" id="cb131-12" data-line-number="12">Y <span class="op">/=</span> <span class="fl">255.</span></a></code></pre></div>
<h2 id="fit-a-deep-gp">Fit a Deep GP</h2>
<p>We’re going to fit a Deep Gaussian process model to the MNIST data with two hidden layers. Each of the two Gaussian processes (one from the first hidden layer to the second, one from the second hidden layer to the data) has an exponentiated quadratic covariance.</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb132-1" data-line-number="1"><span class="im">import</span> deepgp</a>
<a class="sourceLine" id="cb132-2" data-line-number="2"><span class="im">import</span> GPy</a></code></pre></div>
<div class="sourceCode" id="cb133"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb133-1" data-line-number="1">num_latent <span class="op">=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb133-2" data-line-number="2">num_hidden_2 <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb133-3" data-line-number="3">m <span class="op">=</span> deepgp.DeepGP([Y.shape[<span class="dv">1</span>],num_hidden_2,num_latent],</a>
<a class="sourceLine" id="cb133-4" data-line-number="4">                  Y,</a>
<a class="sourceLine" id="cb133-5" data-line-number="5">                  kernels<span class="op">=</span>[GPy.kern.RBF(num_hidden_2,ARD<span class="op">=</span><span class="va">True</span>), </a>
<a class="sourceLine" id="cb133-6" data-line-number="6">                           GPy.kern.RBF(num_latent,ARD<span class="op">=</span><span class="va">False</span>)], </a>
<a class="sourceLine" id="cb133-7" data-line-number="7">                  num_inducing<span class="op">=</span><span class="dv">50</span>, back_constraint<span class="op">=</span><span class="va">False</span>, </a>
<a class="sourceLine" id="cb133-8" data-line-number="8">                  encoder_dims<span class="op">=</span>[[<span class="dv">200</span>],[<span class="dv">200</span>]])</a></code></pre></div>
<h2 id="initialization">Initialization</h2>
<p>Just like deep neural networks, there are some tricks to intitializing these models. The tricks we use here include some early training of the model with model parameters constrained. This gives the variational inducing parameters some scope to tighten the bound for the case where the noise variance is small and the variances of the Gaussian processes are around 1.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb134-1" data-line-number="1">m.obslayer.likelihood.variance[:] <span class="op">=</span> Y.var()<span class="op">*</span><span class="fl">0.01</span></a>
<a class="sourceLine" id="cb134-2" data-line-number="2"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:</a>
<a class="sourceLine" id="cb134-3" data-line-number="3">    layer.kern.variance.fix(warning<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb134-4" data-line-number="4">    layer.likelihood.variance.fix(warning<span class="op">=</span><span class="va">False</span>)</a></code></pre></div>
<p>We now we optimize for a hundred iterations with the constrained model.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb135-1" data-line-number="1">m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</a></code></pre></div>
<p>Now we remove the fixed constraint on the kernel variance parameters, but keep the noise output constrained, and run for a further 100 iterations.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb136-1" data-line-number="1"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:</a>
<a class="sourceLine" id="cb136-2" data-line-number="2">    layer.kern.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb136-3" data-line-number="3">m.optimize(messages<span class="op">=</span><span class="va">False</span>,max_iters<span class="op">=</span><span class="dv">100</span>)</a></code></pre></div>
<p>Finally we unconstrain the layer likelihoods and allow the full model to be trained for 1000 iterations.</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb137-1" data-line-number="1"><span class="cf">for</span> layer <span class="kw">in</span> m.layers:</a>
<a class="sourceLine" id="cb137-2" data-line-number="2">    layer.likelihood.variance.constrain_positive(warning<span class="op">=</span><span class="va">False</span>)</a>
<a class="sourceLine" id="cb137-3" data-line-number="3">m.optimize(messages<span class="op">=</span><span class="va">True</span>,max_iters<span class="op">=</span><span class="dv">10000</span>)</a></code></pre></div>
<h2 id="visualize-the-latent-space-of-the-top-layer">Visualize the latent space of the top layer</h2>
<p>Now the model is trained, let’s plot the mean of the posterior distributions in the top latent layer of the model.</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb138-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb138-2" data-line-number="2"><span class="im">from</span> matplotlib <span class="im">import</span> rc</a>
<a class="sourceLine" id="cb138-3" data-line-number="3"><span class="im">import</span> teaching_plots <span class="im">as</span> plot</a>
<a class="sourceLine" id="cb138-4" data-line-number="4"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb139"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb139-1" data-line-number="1">rc(<span class="st">&quot;font&quot;</span>, <span class="op">**</span>{<span class="st">&#39;family&#39;</span>:<span class="st">&#39;sans-serif&#39;</span>,<span class="st">&#39;sans-serif&#39;</span>:[<span class="st">&#39;Helvetica&#39;</span>],<span class="st">&#39;size&#39;</span>:<span class="dv">20</span>})</a>
<a class="sourceLine" id="cb139-2" data-line-number="2">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_figsize)</a>
<a class="sourceLine" id="cb139-3" data-line-number="3"><span class="cf">for</span> d <span class="kw">in</span> digits:</a>
<a class="sourceLine" id="cb139-4" data-line-number="4">    ax.plot(m.layer_1.X.mean[labels<span class="op">==</span>d,<span class="dv">0</span>],m.layer_1.X.mean[labels<span class="op">==</span>d,<span class="dv">1</span>],<span class="st">&#39;.&#39;</span>,label<span class="op">=</span><span class="bu">str</span>(d))</a>
<a class="sourceLine" id="cb139-5" data-line-number="5">_ <span class="op">=</span> plt.legend()</a>
<a class="sourceLine" id="cb139-6" data-line-number="6">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&quot;../slides/diagrams/deepgp/usps-digits-latent.svg&quot;</span>, transparent<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="usps-digits-latent-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/usps-digits-latent.svg" width="60%" style=" ">
</object>
</div>
<div id="usps-digits-latent-magnify" class="magnify" onclick="magnifyFigure(&#39;usps-digits-latent&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="usps-digits-latent-caption" class="caption-frame">
<p>Figure: Latent space for the deep Gaussian process learned through unsupervised learning and fitted to a subset of the USPS digit data.</p>
</div>
</div>
<h2 id="visualize-the-latent-space-of-the-intermediate-layer">Visualize the latent space of the intermediate layer</h2>
<p>We can also visualize dimensions of the intermediate layer. First the lengthscale of those dimensions is given by</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb140-1" data-line-number="1">m.obslayer.kern.lengthscale</a></code></pre></div>
<div class="sourceCode" id="cb141"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb141-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb141-2" data-line-number="2"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb142"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb142-1" data-line-number="1">fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>plot.big_figsize)</a>
<a class="sourceLine" id="cb142-2" data-line-number="2"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>):</a>
<a class="sourceLine" id="cb142-3" data-line-number="3">    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</a>
<a class="sourceLine" id="cb142-4" data-line-number="4">        dims<span class="op">=</span>[i, j]</a>
<a class="sourceLine" id="cb142-5" data-line-number="5">        ax.cla()</a>
<a class="sourceLine" id="cb142-6" data-line-number="6">        <span class="cf">for</span> d <span class="kw">in</span> digits:</a>
<a class="sourceLine" id="cb142-7" data-line-number="7">            ax.plot(m.obslayer.X.mean[labels<span class="op">==</span>d,dims[<span class="dv">0</span>]],</a>
<a class="sourceLine" id="cb142-8" data-line-number="8">                 m.obslayer.X.mean[labels<span class="op">==</span>d,dims[<span class="dv">1</span>]],</a>
<a class="sourceLine" id="cb142-9" data-line-number="9">                 <span class="st">&#39;.&#39;</span>, label<span class="op">=</span><span class="bu">str</span>(d))</a>
<a class="sourceLine" id="cb142-10" data-line-number="10">        plt.legend()</a>
<a class="sourceLine" id="cb142-11" data-line-number="11">        plt.xlabel(<span class="st">&#39;dimension &#39;</span> <span class="op">+</span> <span class="bu">str</span>(dims[<span class="dv">0</span>]))</a>
<a class="sourceLine" id="cb142-12" data-line-number="12">        plt.ylabel(<span class="st">&#39;dimension &#39;</span> <span class="op">+</span> <span class="bu">str</span>(dims[<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb142-13" data-line-number="13">        mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&quot;../slides/diagrams/deepgp/usps-digits-hidden-&quot;</span> <span class="op">+</span> <span class="bu">str</span>(dims[<span class="dv">0</span>]) <span class="op">+</span> <span class="st">&#39;-&#39;</span> <span class="op">+</span> <span class="bu">str</span>(dims[<span class="dv">1</span>]) <span class="op">+</span> <span class="st">&#39;.svg&#39;</span>, transparent<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="usps-digits-hidden-1-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/usps-digits-hidden-1-0.svg" width="60%" style=" ">
</object>
</div>
<div id="usps-digits-hidden-1-0-magnify" class="magnify" onclick="magnifyFigure(&#39;usps-digits-hidden-1-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="usps-digits-hidden-1-0-caption" class="caption-frame">
<p>Figure: Visualisation of the intermediate layer, plot of dimension 1 vs dimension 0.</p>
</div>
</div>
<div class="figure">
<div id="usps-digits-hidden-1-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/usps-digits-hidden-2-0.svg" width="60%" style=" ">
</object>
</div>
<div id="usps-digits-hidden-1-0-magnify" class="magnify" onclick="magnifyFigure(&#39;usps-digits-hidden-1-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="usps-digits-hidden-1-0-caption" class="caption-frame">
<p>Figure: Visualisation of the intermediate layer, plot of dimension 1 vs dimension 0.</p>
</div>
</div>
<div class="figure">
<div id="usps-digits-hidden-1-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/usps-digits-hidden-3-0.svg" width="60%" style=" ">
</object>
</div>
<div id="usps-digits-hidden-1-0-magnify" class="magnify" onclick="magnifyFigure(&#39;usps-digits-hidden-1-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="usps-digits-hidden-1-0-caption" class="caption-frame">
<p>Figure: Visualisation of the intermediate layer, plot of dimension 1 vs dimension 0.</p>
</div>
</div>
<div class="figure">
<div id="usps-digits-hidden-1-0-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/usps-digits-hidden-4-0.svg" width="60%" style=" ">
</object>
</div>
<div id="usps-digits-hidden-1-0-magnify" class="magnify" onclick="magnifyFigure(&#39;usps-digits-hidden-1-0&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="usps-digits-hidden-1-0-caption" class="caption-frame">
<p>Figure: Visualisation of the intermediate layer, plot of dimension 1 vs dimension 0.</p>
</div>
</div>
<h2 id="generate-from-model">Generate From Model</h2>
<p>Now we can take a look at a sample from the model, by drawing a Gaussian random sample in the latent space and propagating it through the model.</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb143-1" data-line-number="1"></a>
<a class="sourceLine" id="cb143-2" data-line-number="2">rows <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb143-3" data-line-number="3">cols <span class="op">=</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb143-4" data-line-number="4">t<span class="op">=</span>np.linspace(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, rows<span class="op">*</span>cols)[:, <span class="va">None</span>]</a>
<a class="sourceLine" id="cb143-5" data-line-number="5">kern <span class="op">=</span> GPy.kern.RBF(<span class="dv">1</span>,lengthscale<span class="op">=</span><span class="fl">0.05</span>)</a>
<a class="sourceLine" id="cb143-6" data-line-number="6">cov <span class="op">=</span> kern.K(t, t)</a>
<a class="sourceLine" id="cb143-7" data-line-number="7">x <span class="op">=</span> np.random.multivariate_normal(np.zeros(rows<span class="op">*</span>cols), cov, num_latent).T</a></code></pre></div>
<div class="sourceCode" id="cb144"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb144-1" data-line-number="1"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb144-2" data-line-number="2"><span class="im">import</span> mlai</a></code></pre></div>
<div class="sourceCode" id="cb145"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb145-1" data-line-number="1">yt <span class="op">=</span> m.predict(x)</a>
<a class="sourceLine" id="cb145-2" data-line-number="2">fig, axs <span class="op">=</span> plt.subplots(rows,cols,figsize<span class="op">=</span>(<span class="dv">10</span>,<span class="dv">6</span>))</a>
<a class="sourceLine" id="cb145-3" data-line-number="3"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows):</a>
<a class="sourceLine" id="cb145-4" data-line-number="4">    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols):</a>
<a class="sourceLine" id="cb145-5" data-line-number="5">        <span class="co">#v = np.random.normal(loc=yt[0][i*cols+j, :], scale=np.sqrt(yt[1][i*cols+j, :]))</span></a>
<a class="sourceLine" id="cb145-6" data-line-number="6">        v <span class="op">=</span> yt[<span class="dv">0</span>][i<span class="op">*</span>cols<span class="op">+</span>j, :]</a>
<a class="sourceLine" id="cb145-7" data-line-number="7">        axs[i,j].imshow(v.reshape(<span class="dv">28</span>,<span class="dv">28</span>), </a>
<a class="sourceLine" id="cb145-8" data-line-number="8">                        cmap<span class="op">=</span><span class="st">&#39;gray&#39;</span>, interpolation<span class="op">=</span><span class="st">&#39;none&#39;</span>,</a>
<a class="sourceLine" id="cb145-9" data-line-number="9">                        aspect<span class="op">=</span><span class="st">&#39;equal&#39;</span>)</a>
<a class="sourceLine" id="cb145-10" data-line-number="10">        axs[i,j].set_axis_off()</a>
<a class="sourceLine" id="cb145-11" data-line-number="11">mlai.write_figure(figure<span class="op">=</span>fig, filename<span class="op">=</span><span class="st">&quot;../slides/diagrams/deepgp/digit-samples-deep-gp.svg&quot;</span>, transparent<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<div class="figure">
<div id="digit-samples-deep-gp-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/digit-samples-deep-gp.svg" width="80%" style=" ">
</object>
</div>
<div id="digit-samples-deep-gp-magnify" class="magnify" onclick="magnifyFigure(&#39;digit-samples-deep-gp&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="digit-samples-deep-gp-caption" class="caption-frame">
<p>Figure: These digits are produced by taking a tour of the two dimensional latent space (as described by a Gaussian process sample) and mapping the tour into the data space. We visualize the mean of the mapping in the images.</p>
</div>
</div>
<h2 id="deep-health-edit">Deep Health <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_health/includes/deep-health-model.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_health/includes/deep-health-model.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<div class="figure">
<div id="deep-health-model-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/deep-health.svg" width="70%" style=" ">
</object>
</div>
<div id="deep-health-model-magnify" class="magnify" onclick="magnifyFigure(&#39;deep-health-model&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="deep-health-model-caption" class="caption-frame">
<p>Figure: The deep health model uses different layers of abstraction in the deep Gaussian process to represent information about diagnostics and treatment to model interelationships between a patients different data modalities.</p>
</div>
</div>
<p>From a machine learning perspective, we’d like to be able to interrelate all the different modalities that are informative about the state of the disease. For deep health, the notion is that the state of the disease is appearing at the more abstract levels, as we descend the model, we express relationships between the more abstract concept, that sits within the physician’s mind, and the data we can measure.</p>
<h2 id="at-this-years-nips">At this Year’s NIPS</h2>
<ul>
<li><em>Gaussian process based nonlinear latent structure discovery in multivariate spike train data</em> <span class="citation" data-cites="Anqi:gpspike2017">Wu et al. (2017)</span></li>
<li><em>Doubly Stochastic Variational Inference for Deep Gaussian Processes</em> <span class="citation" data-cites="Salimbeni:doubly2017">Salimbeni and Deisenroth (2017)</span></li>
<li><em>Deep Multi-task Gaussian Processes for Survival Analysis with Competing Risks</em> <span class="citation" data-cites="Alaa:deep2017">Alaa and van der Schaar (2017)</span></li>
<li><em>Counterfactual Gaussian Processes for Reliable Decision-making and What-if Reasoning</em> <span class="citation" data-cites="Schulam:counterfactual17">Schulam and Saria (2017)</span></li>
</ul>
<h2 id="some-other-works">Some Other Works</h2>
<ul>
<li><em>Deep Survival Analysis</em> <span class="citation" data-cites="Ranganath-survival16">Ranganath et al. (2016)</span></li>
<li><em>Recurrent Gaussian Processes</em> <span class="citation" data-cites="Mattos:recurrent15">Mattos et al. (2015)</span></li>
<li><em>Gaussian Process Based Approaches for Survival Analysis</em> <span class="citation" data-cites="Saul:thesis2016">Saul (2016)</span></li>
</ul>
<h2 id="uncertainty-quantification-edit">Uncertainty Quantification <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/uq-intro.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/uq-intro.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<blockquote>
<p>Uncertainty quantification (UQ) is the science of quantitative characterization and reduction of uncertainties in both computational and real world applications. It tries to determine how likely certain outcomes are if some aspects of the system are not exactly known.</p>
</blockquote>
<p>We will to illustrate different concepts of <a href="https://en.wikipedia.org/wiki/Uncertainty_quantification">Uncertainty Quantification</a> (UQ) and the role that Gaussian processes play in this field. Based on a simple simulator of a car moving between a valley and a mountain, we are going to illustrate the following concepts:</p>
<ul>
<li><p><strong>Systems emulation</strong>. Many real world decisions are based on simulations that can be computationally very demanding. We will show how simulators can be replaced by <em>emulators</em>: Gaussian process models fitted on a few simulations that can be used to replace the <em>simulator</em>. Emulators are cheap to compute, fast to run, and always provide ways to quantify the uncertainty of how precise they are compared the original simulator.</p></li>
<li><p><strong>Emulators in optimization problems</strong>. We will show how emulators can be used to optimize black-box functions that are expensive to evaluate. This field is also called Bayesian Optimization and has gained an increasing relevance in machine learning as emulators can be used to optimize computer simulations (and machine learning algorithms) quite efficiently.</p></li>
<li><p><strong>Multi-fidelity emulation methods</strong>. In many scenarios we have simulators of different quality about the same measure of interest. In these cases the goal is to merge all sources of information under the same model so the final emulator is cheaper and more accurate than an emulator fitted only using data from the most accurate and expensive simulator.</p></li>
</ul>
<h2 id="mountain-car-simulator-edit">Mountain Car Simulator <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-simulation.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-simulation.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>To illustrate the above mentioned concepts we we use the <a href="https://github.com/openai/gym/wiki/MountainCarContinuous-v0">mountain car simulator</a>. This simulator is widely used in machine learning to test reinforcement learning algorithms. The goal is to define a control policy on a car whose objective is to climb a mountain. Graphically, the problem looks as follows:</p>
<div class="figure">
<div id="mountain-car-figure" class="figure-frame">
<div class="centered" style="">
<img class="negate" src="../slides/diagrams/uq/mountaincar.png" width="60%" height="auto" align="center" style="background:none; border:none; box-shadow:none; display:block; margin-left:auto; margin-right:auto;vertical-align:middle">
</div>
</div>
<div id="mountain-car-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mountain-car-caption" class="caption-frame">
<p>Figure: The mountain car simulation from the Open AI gym.</p>
</div>
</div>
<p>The goal is to define a sequence of actions (push the car right or left with certain intensity) to make the car reach the flag after a number <span class="math inline"><em>T</em></span> of time steps.</p>
<p>At each time step <span class="math inline"><em>t</em></span>, the car is characterized by a vector <span class="math inline">$\inputVector_{t} = (p_t,v_t)$</span> of states which are respectively the the position and velocity of the car at time <span class="math inline"><em>t</em></span>. For a sequence of states (an episode), the dynamics of the car is given by</p>
<p><br /><span class="math display">$$\inputVector_{t+1} = \mappingFunction(\inputVector_{t},\textbf{u}_{t})$$</span><br /></p>
<p>where <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span> is the value of an action force, which in this example corresponds to push car to the left (negative value) or to the right (positive value). The actions across a full episode are represented in a policy <span class="math inline">$\textbf{u}_{t} = \pi(\inputVector_{t},\theta)$</span> that acts according to the current state of the car and some parameters <span class="math inline"><em>θ</em></span>. In the following examples we will assume that the policy is linear which allows us to write <span class="math inline">$\pi(\inputVector_{t},\theta)$</span> as</p>
<p><br /><span class="math display">$$\pi(\inputVector,\theta)= \theta_0 + \theta_p p + \theta_vv.$$</span><br /></p>
<p>For <span class="math inline"><em>t</em> = 1, …, <em>T</em></span> now given some initial state <span class="math inline">$\inputVector_{0}$</span> and some some values of each <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span>, we can <strong>simulate</strong> the full dynamics of the car for a full episode using <a href="https://gym.openai.com/envs/">Gym</a>. The values of <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span> are fully determined by the parameters of the linear controller.</p>
<p>After each episode of length <span class="math inline"><em>T</em></span> is complete, a reward function <span class="math inline"><em>R</em><sub><em>T</em></sub>(<em>θ</em>)</span> is computed. In the mountain car example the reward is computed as 100 for reaching the target of the hill on the right hand side, minus the squared sum of actions (a real negative to push to the left and a real positive to push to the right) from start to goal. Note that our reward depend on <span class="math inline"><em>θ</em></span> as we make it dependent on the parameters of the linear controller.</p>
<h2 id="emulate-the-mountain-car">Emulate the Mountain Car</h2>
<div class="sourceCode" id="cb146"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb146-1" data-line-number="1"><span class="im">import</span> gym</a></code></pre></div>
<div class="sourceCode" id="cb147"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb147-1" data-line-number="1">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</a></code></pre></div>
<p>Our goal in this section is to find the parameters <span class="math inline"><em>θ</em></span> of the linear controller such that</p>
<p><br /><span class="math display"><em>θ</em><sup>*</sup> = <em>a</em><em>r</em><em>g</em>max<sub><em>θ</em></sub><em>R</em><sub><em>T</em></sub>(<em>θ</em>).</span><br /></p>
<p>In this section, we directly use Bayesian optimization to solve this problem. We will use <a href="https://sheffieldml.github.io/GPyOpt/">GPyOpt</a> so we first define the objective function:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb148-1" data-line-number="1"><span class="im">import</span> mountain_car <span class="im">as</span> mc</a>
<a class="sourceLine" id="cb148-2" data-line-number="2"><span class="im">import</span> GPyOpt</a></code></pre></div>
<div class="sourceCode" id="cb149"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb149-1" data-line-number="1">obj_func <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_simulation(env, x)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb149-2" data-line-number="2">objective <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func)</a></code></pre></div>
<p>For each set of parameter values of the linear controller we can run an episode of the simulator (that we fix to have a horizon of <span class="math inline"><em>T</em> = 500</span>) to generate the reward. Using as input the parameters of the controller and as outputs the rewards we can build a Gaussian process emulator of the reward.</p>
<p>We start defining the input space, which is three-dimensional:</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb150-1" data-line-number="1"><span class="co">## --- We define the input space of the emulator</span></a>
<a class="sourceLine" id="cb150-2" data-line-number="2"></a>
<a class="sourceLine" id="cb150-3" data-line-number="3">space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;postion_parameter&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},</a>
<a class="sourceLine" id="cb150-4" data-line-number="4">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity_parameter&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},</a>
<a class="sourceLine" id="cb150-5" data-line-number="5">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]</a>
<a class="sourceLine" id="cb150-6" data-line-number="6"></a>
<a class="sourceLine" id="cb150-7" data-line-number="7">design_space <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)</a></code></pre></div>
<p>Now we initizialize a Gaussian process emulator.</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb151-1" data-line-number="1">model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>In Bayesian optimization an acquisition function is used to balance exploration and exploitation to evaluate new locations close to the optimum of the objective. In this notebook we select the expected improvement (EI). For further details have a look to the review paper of <a href="http://www.cs.ox.ac.uk/people/nando.defreitas/publications/BayesOptLoop.pdf">Shahriari et al (2015)</a>.</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb152-1" data-line-number="1">aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)</a>
<a class="sourceLine" id="cb152-2" data-line-number="2">acquisition <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)</a>
<a class="sourceLine" id="cb152-3" data-line-number="3">evaluator <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition) <span class="co"># Collect points sequentially, no parallelization.</span></a></code></pre></div>
<p>To initalize the model we start sampling some initial points (25) for the linear controler randomly.</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb153-1" data-line-number="1"><span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign</a></code></pre></div>
<div class="sourceCode" id="cb154"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb154-1" data-line-number="1">n_initial_points <span class="op">=</span> <span class="dv">25</span></a>
<a class="sourceLine" id="cb154-2" data-line-number="2">random_design <span class="op">=</span> RandomDesign(design_space)</a>
<a class="sourceLine" id="cb154-3" data-line-number="3">initial_design <span class="op">=</span> random_design.get_samples(n_initial_points)</a></code></pre></div>
<p>Before we start any optimization, lets have a look to the behavior of the car with the first of these initial points that we have selected randomly.</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb155-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a></code></pre></div>
<div class="sourceCode" id="cb156"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb156-1" data-line-number="1">random_controller <span class="op">=</span> initial_design[<span class="dv">0</span>,:]</a>
<a class="sourceLine" id="cb156-2" data-line-number="2">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(random_controller), render<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb156-3" data-line-number="3">anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Random linear controller&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb157"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb157-1" data-line-number="1"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</a></code></pre></div>
<div class="sourceCode" id="cb158"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb158-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<div class="figure">
<div id="mountain-car-random-figure" class="figure-frame">
<iframe src="../slides/diagrams/uq/mountain_car_random.html" width="800px" height="600px" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-random-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-random&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mountain-car-random-caption" class="caption-frame">
<p>Figure: Random linear controller for the Mountain car. It fails to move the car to the top of the mountain.</p>
</div>
</div>
<p>As we can see the random linear controller does not manage to push the car to the top of the mountain. Now, let’s optimize the regret using Bayesian optimization and the emulator for the reward. We try 50 new parameters chosen by the EI.</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb159-1" data-line-number="1">max_iter <span class="op">=</span> <span class="dv">50</span></a>
<a class="sourceLine" id="cb159-2" data-line-number="2">bo <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective, acquisition, evaluator, initial_design)</a>
<a class="sourceLine" id="cb159-3" data-line-number="3">bo.run_optimization(max_iter <span class="op">=</span> max_iter )</a></code></pre></div>
<p>Now we visualize the result for the best controller that we have found with Bayesian optimization.</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb160-1" data-line-number="1">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo.x_opt), render<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb160-2" data-line-number="2">anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller after 50 iterations of Bayesian optimization&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb161"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb161-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<div class="figure">
<div id="mountain-car-similated-bayes-opt-figure" class="figure-frame">
<iframe src="../slides/diagrams/uq/mountain_car_simulated.html" width="800px" height="600px" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-similated-bayes-opt-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-similated-bayes-opt&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mountain-car-similated-bayes-opt-caption" class="caption-frame">
<p>Figure: Mountain car simulator trained using Bayesian optimization and the simulator of the dynamics. Fifty iterations of Bayesian optimization are used to optimize the controler.</p>
</div>
</div>
<p>he car can now make it to the top of the mountain! Emulating the reward function and using the EI helped as to find a linear controller that solves the problem.</p>
<h2 id="data-efficient-emulation-edit">Data Efficient Emulation <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-data-efficient.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-data-efficient.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>In the previous section we solved the mountain car problem by directly emulating the reward but no considerations about the dynamics <span class="math inline">$\inputVector_{t+1} = \mappingFunction(\inputVector_{t},\textbf{u}_{t})$</span> of the system were made. Note that we had to run 75 episodes of 500 steps each to solve the problem, which required to call the simulator <span class="math inline">500 × 75 = 37500</span> times. In this section we will show how it is possible to reduce this number by building an emulator for <span class="math inline"><em>f</em></span> that can later be used to directly optimize the control.</p>
<p>The inputs of the model for the dynamics are the velocity, the position and the value of the control so create this space accordingly.</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb162-1" data-line-number="1"><span class="im">import</span> gym</a></code></pre></div>
<div class="sourceCode" id="cb163"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb163-1" data-line-number="1">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb164"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb164-1" data-line-number="1"><span class="im">import</span> GPyOpt</a></code></pre></div>
<div class="sourceCode" id="cb165"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb165-1" data-line-number="1">space_dynamics <span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;position&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="fl">1.2</span>, <span class="fl">+0.6</span>]},</a>
<a class="sourceLine" id="cb165-2" data-line-number="2">                  {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="fl">0.07</span>, <span class="fl">+0.07</span>]},</a>
<a class="sourceLine" id="cb165-3" data-line-number="3">                  {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;action&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:[<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>]}]</a>
<a class="sourceLine" id="cb165-4" data-line-number="4">design_space_dynamics <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space_dynamics)</a></code></pre></div>
<p>The outputs are the velocity and the position. Indeed our model will capture the change in position and velocity on time. That is, we will model</p>
<p><br /><span class="math display"><em>Δ</em><em>v</em><sub><em>t</em> + 1</sub> = <em>v</em><sub><em>t</em> + 1</sub> − <em>v</em><sub><em>t</em></sub></span><br /></p>
<p><br /><span class="math display"><em>Δ</em><em>x</em><sub><em>t</em> + 1</sub> = <em>p</em><sub><em>t</em> + 1</sub> − <em>p</em><sub><em>t</em></sub></span><br /></p>
<p>with Gaussian processes with prior mean <span class="math inline"><em>v</em><sub><em>t</em></sub></span> and <span class="math inline"><em>p</em><sub><em>t</em></sub></span> respectively. As a covariance function, we use a Matern52. We need therefore two models to capture the full dynamics of the system.</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb166-1" data-line-number="1">position_model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb166-2" data-line-number="2">velocity_model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>Next, we sample some input parameters and use the simulator to compute the outputs. Note that in this case we are not running the full episodes, we are just using the simulator to compute <span class="math inline">$\inputVector_{t+1}$</span> given <span class="math inline">$\inputVector_{t}$</span> and <span class="math inline"><strong>u</strong><sub><em>t</em></sub></span>.</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb167-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb167-2" data-line-number="2"><span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign</a>
<a class="sourceLine" id="cb167-3" data-line-number="3"><span class="im">import</span> mountain_car <span class="im">as</span> mc</a></code></pre></div>
<div class="sourceCode" id="cb168"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb168-1" data-line-number="1"><span class="co">### --- Random locations of the inputs</span></a>
<a class="sourceLine" id="cb168-2" data-line-number="2">n_initial_points <span class="op">=</span> <span class="dv">500</span></a>
<a class="sourceLine" id="cb168-3" data-line-number="3">random_design_dynamics <span class="op">=</span> RandomDesign(design_space_dynamics)</a>
<a class="sourceLine" id="cb168-4" data-line-number="4">initial_design_dynamics <span class="op">=</span> random_design_dynamics.get_samples(n_initial_points)</a></code></pre></div>
<div class="sourceCode" id="cb169"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb169-1" data-line-number="1"><span class="co">### --- Simulation of the (normalized) outputs</span></a>
<a class="sourceLine" id="cb169-2" data-line-number="2">y <span class="op">=</span> np.zeros((initial_design_dynamics.shape[<span class="dv">0</span>], <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb169-3" data-line-number="3"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(initial_design_dynamics.shape[<span class="dv">0</span>]):</a>
<a class="sourceLine" id="cb169-4" data-line-number="4">    y[i, :] <span class="op">=</span> mc.simulation(initial_design_dynamics[i, :])</a>
<a class="sourceLine" id="cb169-5" data-line-number="5"></a>
<a class="sourceLine" id="cb169-6" data-line-number="6"><span class="co"># Normalize the data from the simulation</span></a>
<a class="sourceLine" id="cb169-7" data-line-number="7">y_normalisation <span class="op">=</span> np.std(y, axis<span class="op">=</span><span class="dv">0</span>)</a>
<a class="sourceLine" id="cb169-8" data-line-number="8">y_normalised <span class="op">=</span> y<span class="op">/</span>y_normalisation</a></code></pre></div>
<p>In general we might use much smarter strategies to design our emulation of the simulator. For example, we could use the variance of the predictive distributions of the models to collect points using uncertainty sampling, which will give us a better coverage of the space. For simplicity, we move ahead with the 500 randomly selected points.</p>
<p>Now that we have a data set, we can update the emulators for the location and the velocity.</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb170-1" data-line-number="1">position_model.updateModel(initial_design_dynamics, y[:, [<span class="dv">0</span>]], <span class="va">None</span>, <span class="va">None</span>)</a>
<a class="sourceLine" id="cb170-2" data-line-number="2">velocity_model.updateModel(initial_design_dynamics, y[:, [<span class="dv">1</span>]], <span class="va">None</span>, <span class="va">None</span>)</a></code></pre></div>
<p>We can now have a look to how the emulator and the simulator match. First, we show a contour plot of the car aceleration for each pair of can position and velocity. You can use the bar bellow to play with the values of the controler to compare the emulator and the simulator.</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb171-1" data-line-number="1"><span class="im">from</span> IPython.html.widgets <span class="im">import</span> interact</a></code></pre></div>
<p>We can see how the emulator is doing a fairly good job approximating the simulator. On the edges, however, it struggles to captures the dynamics of the simulator.</p>
<p>Given some input parameters of the linear controlling, how do the dynamics of the emulator and simulator match? In the following figure we show the position and velocity of the car for the 500 time steps of an episode in which the parameters of the linear controller have been fixed beforehand. The value of the input control is also shown.</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb172-1" data-line-number="1">controller_gains <span class="op">=</span> np.atleast_2d([<span class="dv">0</span>, <span class="fl">.6</span>, <span class="dv">1</span>])  <span class="co"># change the valus of the linear controller to observe the trayectories.</span></a></code></pre></div>
<div class="figure">
<div id="emu-sim-comparison-figure" class="figure-frame">
<object class="svgplot " data="../slides/diagrams/uq/emu_sim_comparison.svg" width="80%" style=" ">
</object>
</div>
<div id="emu-sim-comparison-magnify" class="magnify" onclick="magnifyFigure(&#39;emu-sim-comparison&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="emu-sim-comparison-caption" class="caption-frame">
<p>Figure: Comparison between the mountain car simulator and the emulator.</p>
</div>
</div>
<p>We now make explicit use of the emulator, using it to replace the simulator and optimize the linear controller. Note that in this optimization, we don’t need to query the simulator anymore as we can reproduce the full dynamics of an episode using the emulator. For illustrative purposes, in this example we fix the initial location of the car.</p>
<p>We define the objective reward function in terms of the simulator.</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb173-1" data-line-number="1"><span class="co">### --- Optimize control parameters with emulator</span></a>
<a class="sourceLine" id="cb173-2" data-line-number="2">car_initial_location <span class="op">=</span> np.asarray([<span class="op">-</span><span class="fl">0.58912799</span>, <span class="dv">0</span>]) </a>
<a class="sourceLine" id="cb173-3" data-line-number="3"></a>
<a class="sourceLine" id="cb173-4" data-line-number="4"><span class="co">### --- Reward objective function using the emulator</span></a>
<a class="sourceLine" id="cb173-5" data-line-number="5">obj_func_emulator <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_emulation([position_model, velocity_model], x, car_initial_location)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb173-6" data-line-number="6">objective_emulator <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func_emulator)</a></code></pre></div>
<p>And as before, we use Bayesian optimization to find the best possible linear controller.</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb174-1" data-line-number="1"><span class="co">### --- Elements of the optimization that will use the multi-fidelity emulator</span></a>
<a class="sourceLine" id="cb174-2" data-line-number="2">model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</a></code></pre></div>
<p>The design space is the three continuous variables that make up the linear controller.</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb175-1" data-line-number="1">space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_1&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},</a>
<a class="sourceLine" id="cb175-2" data-line-number="2">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_2&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},</a>
<a class="sourceLine" id="cb175-3" data-line-number="3">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]</a>
<a class="sourceLine" id="cb175-4" data-line-number="4"></a>
<a class="sourceLine" id="cb175-5" data-line-number="5">design_space         <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)</a>
<a class="sourceLine" id="cb175-6" data-line-number="6">aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)</a>
<a class="sourceLine" id="cb175-7" data-line-number="7"></a>
<a class="sourceLine" id="cb175-8" data-line-number="8">random_design <span class="op">=</span> RandomDesign(design_space)</a>
<a class="sourceLine" id="cb175-9" data-line-number="9">initial_design <span class="op">=</span> random_design.get_samples(<span class="dv">25</span>)</a></code></pre></div>
<p>We set the acquisition function to be expected improvement using <code>GPyOpt</code>.</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb176-1" data-line-number="1">acquisition          <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)</a>
<a class="sourceLine" id="cb176-2" data-line-number="2">evaluator            <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition)</a></code></pre></div>
<div class="sourceCode" id="cb177"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb177-1" data-line-number="1">bo_emulator <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective_emulator, acquisition, evaluator, initial_design)</a>
<a class="sourceLine" id="cb177-2" data-line-number="2">bo_emulator.run_optimization(max_iter<span class="op">=</span><span class="dv">50</span>)</a></code></pre></div>
<div class="sourceCode" id="cb178"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb178-1" data-line-number="1">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo_emulator.x_opt), render<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb178-2" data-line-number="2">anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller using the emulator of the dynamics&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb179"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb179-1" data-line-number="1"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</a></code></pre></div>
<div class="sourceCode" id="cb180"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb180-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<div class="figure">
<div id="mountain-car-emulated-figure" class="figure-frame">
<iframe src="../slides/diagrams/uq/mountain_car_emulated.html" width="800px" height="600px" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-emulated-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-emulated&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mountain-car-emulated-caption" class="caption-frame">
<p>Figure: Mountain car controller learnt through emulation. Here 500 calls to the simulator are used to fit the controller rather than 37,500 calls to the simulator required in the standard learning.</p>
</div>
</div>
<p>And the problem is again solved, but in this case we have replaced the simulator of the car dynamics by a Gaussian process emulator that we learned by calling the simulator only 500 times. Compared to the 37500 calls that we needed when applying Bayesian optimization directly on the simulator this is a great gain.</p>
<h2 id="multi-fidelity-emulation-edit">Multi-Fidelity Emulation <span class="editsection-bracket" style="">[</span><span class="editsection" style=""><a href="https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-multi-fidelity.md" target="_blank" onclick="ga('send', 'event', 'Edit Page', 'Edit', 'https://github.com/lawrennd/talks/edit/gh-pages/_uq/includes/mountain-car-multi-fidelity.md', 13);">edit</a></span><span class="editsection-bracket" style="">]</span></h2>
<p>In some scenarios we have simulators of the same environment that have different fidelities, that is that reflect with different level of accuracy the dynamics of the real world. Running simulations of the different fidelities also have a different cost: hight fidelity simulations are more expensive the cheaper ones. If we have access to these simulators we can combine high and low fidelity simulations under the same model.</p>
<p>So let’s assume that we have two simulators of the mountain car dynamics, one of high fidelity (the one we have used) and another one of low fidelity. The traditional approach to this form of multi-fidelity emulation is to assume that</p>
<p><br /><span class="math display">$$\mappingFunction_i\left(\inputVector\right) = \rho\mappingFunction_{i-1}\left(\inputVector\right) + \delta_i\left(\inputVector \right)$$</span><br /></p>
<p>where <span class="math inline">$\mappingFunction_{i-1}\left(\inputVector\right)$</span> is a low fidelity simulation of the problem of interest and <span class="math inline">$\mappingFunction_i\left(\inputVector\right)$</span> is a higher fidelity simulation. The function <span class="math inline">$\delta_i\left(\inputVector \right)$</span> represents the difference between the lower and higher fidelity simulation, which is considered additive. The additive form of this covariance means that if <span class="math inline">$\mappingFunction_{0}\left(\inputVector\right)$</span> and <span class="math inline">$\left\{\delta_i\left(\inputVector \right)\right\}_{i=1}^m$</span> are all Gaussian processes, then the process over all fidelities of simuation will be a joint Gaussian process.</p>
<p>But with Deep Gaussian processes we can consider the form</p>
<p><br /><span class="math display">$$\mappingFunction_i\left(\inputVector\right) = \mappingFunctionTwo_{i}\left(\mappingFunction_{i-1}\left(\inputVector\right)\right) + \delta_i\left(\inputVector \right),$$</span><br /></p>
<p>where the low fidelity representation is non linearly transformed by <span class="math inline">$\mappingFunctionTwo(\cdot)$</span> before use in the process. This is the approach taken in <span class="citation" data-cites="Perdikaris:multifidelity17">Perdikaris et al. (2017)</span>. But once we accept that these models can be composed, a highly flexible framework can emerge. A key point is that the data enters the model at different levels, and represents different aspects. For example these correspond to the two fidelities of the mountain car simulator.</p>
<p>We start by sampling both of them at 250 random input locations.</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb181-1" data-line-number="1"><span class="im">import</span> gym</a></code></pre></div>
<div class="sourceCode" id="cb182"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb182-1" data-line-number="1">env <span class="op">=</span> gym.make(<span class="st">&#39;MountainCarContinuous-v0&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb183"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb183-1" data-line-number="1"><span class="im">import</span> GPyOpt</a></code></pre></div>
<div class="sourceCode" id="cb184"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb184-1" data-line-number="1"><span class="co">### --- Collect points from low and high fidelity simulator --- </span><span class="al">###</span></a>
<a class="sourceLine" id="cb184-2" data-line-number="2"></a>
<a class="sourceLine" id="cb184-3" data-line-number="3">space <span class="op">=</span> GPyOpt.Design_space([</a>
<a class="sourceLine" id="cb184-4" data-line-number="4">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;position&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},</a>
<a class="sourceLine" id="cb184-5" data-line-number="5">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;velocity&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="fl">0.07</span>, <span class="fl">+0.07</span>)},</a>
<a class="sourceLine" id="cb184-6" data-line-number="6">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;action&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}])</a>
<a class="sourceLine" id="cb184-7" data-line-number="7"></a>
<a class="sourceLine" id="cb184-8" data-line-number="8">n_points <span class="op">=</span> <span class="dv">250</span></a>
<a class="sourceLine" id="cb184-9" data-line-number="9">random_design <span class="op">=</span> GPyOpt.experiment_design.RandomDesign(space)</a>
<a class="sourceLine" id="cb184-10" data-line-number="10">x_random <span class="op">=</span> random_design.get_samples(n_points)</a></code></pre></div>
<p>Next, we evaluate the high and low fidelity simualtors at those locations.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb185-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb185-2" data-line-number="2"><span class="im">import</span> mountain_car <span class="im">as</span> mc</a></code></pre></div>
<div class="sourceCode" id="cb186"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb186-1" data-line-number="1">d_position_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb186-2" data-line-number="2">d_velocity_hf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb186-3" data-line-number="3">d_position_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb186-4" data-line-number="4">d_velocity_lf <span class="op">=</span> np.zeros((n_points, <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb186-5" data-line-number="5"></a>
<a class="sourceLine" id="cb186-6" data-line-number="6"><span class="co"># --- Collect high fidelity points</span></a>
<a class="sourceLine" id="cb186-7" data-line-number="7"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):</a>
<a class="sourceLine" id="cb186-8" data-line-number="8">    d_position_hf[i], d_velocity_hf[i] <span class="op">=</span> mc.simulation(x_random[i, :])</a>
<a class="sourceLine" id="cb186-9" data-line-number="9"></a>
<a class="sourceLine" id="cb186-10" data-line-number="10"><span class="co"># --- Collect low fidelity points  </span></a>
<a class="sourceLine" id="cb186-11" data-line-number="11"><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, n_points):</a>
<a class="sourceLine" id="cb186-12" data-line-number="12">    d_position_lf[i], d_velocity_lf[i] <span class="op">=</span> mc.low_cost_simulation(x_random[i, :])</a></code></pre></div>
<p>It is time to build the multi-fidelity model for both the position and the velocity.</p>
<p>As we did in the previous section we use the emulator to optimize the simulator. In this case we use the high fidelity output of the emulator.</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb187-1" data-line-number="1"><span class="co">### --- Optimize controller parameters </span></a>
<a class="sourceLine" id="cb187-2" data-line-number="2">obj_func <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_simulation(env, x)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb187-3" data-line-number="3">obj_func_emulator <span class="op">=</span> <span class="kw">lambda</span> x: mc.run_emulation([position_model, velocity_model], x, car_initial_location)[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb187-4" data-line-number="4">objective_multifidelity <span class="op">=</span> GPyOpt.core.task.SingleObjective(obj_func)</a></code></pre></div>
<p>And we optimize using Bayesian optimzation.</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb188-1" data-line-number="1"><span class="im">from</span> GPyOpt.experiment_design.random_design <span class="im">import</span> RandomDesign</a></code></pre></div>
<div class="sourceCode" id="cb189"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb189-1" data-line-number="1">model <span class="op">=</span> GPyOpt.models.GPModel(optimize_restarts<span class="op">=</span><span class="dv">5</span>, verbose<span class="op">=</span><span class="va">False</span>, exact_feval<span class="op">=</span><span class="va">True</span>, ARD<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb189-2" data-line-number="2">space<span class="op">=</span> [{<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_1&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">1.2</span>, <span class="op">+</span><span class="dv">1</span>)},</a>
<a class="sourceLine" id="cb189-3" data-line-number="3">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;linear_2&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>, <span class="op">+</span><span class="dv">1</span><span class="op">/</span><span class="fl">0.07</span>)},</a>
<a class="sourceLine" id="cb189-4" data-line-number="4">        {<span class="st">&#39;name&#39;</span>:<span class="st">&#39;constant&#39;</span>, <span class="st">&#39;type&#39;</span>:<span class="st">&#39;continuous&#39;</span>, <span class="st">&#39;domain&#39;</span>:(<span class="op">-</span><span class="dv">1</span>, <span class="op">+</span><span class="dv">1</span>)}]</a>
<a class="sourceLine" id="cb189-5" data-line-number="5"></a>
<a class="sourceLine" id="cb189-6" data-line-number="6">design_space <span class="op">=</span> GPyOpt.Design_space(space<span class="op">=</span>space)</a>
<a class="sourceLine" id="cb189-7" data-line-number="7">aquisition_optimizer <span class="op">=</span> GPyOpt.optimization.AcquisitionOptimizer(design_space)</a>
<a class="sourceLine" id="cb189-8" data-line-number="8"></a>
<a class="sourceLine" id="cb189-9" data-line-number="9">n_initial_points <span class="op">=</span> <span class="dv">25</span></a>
<a class="sourceLine" id="cb189-10" data-line-number="10">random_design <span class="op">=</span> RandomDesign(design_space)</a>
<a class="sourceLine" id="cb189-11" data-line-number="11">initial_design <span class="op">=</span> random_design.get_samples(n_initial_points)</a>
<a class="sourceLine" id="cb189-12" data-line-number="12">acquisition <span class="op">=</span> GPyOpt.acquisitions.AcquisitionEI(model, design_space, optimizer<span class="op">=</span>aquisition_optimizer)</a>
<a class="sourceLine" id="cb189-13" data-line-number="13">evaluator <span class="op">=</span> GPyOpt.core.evaluators.Sequential(acquisition)</a></code></pre></div>
<div class="sourceCode" id="cb190"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb190-1" data-line-number="1">bo_multifidelity <span class="op">=</span> GPyOpt.methods.ModularBayesianOptimization(model, design_space, objective_multifidelity, acquisition, evaluator, initial_design)</a>
<a class="sourceLine" id="cb190-2" data-line-number="2">bo_multifidelity.run_optimization(max_iter<span class="op">=</span><span class="dv">50</span>)</a></code></pre></div>
<div class="sourceCode" id="cb191"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb191-1" data-line-number="1">_, _, _, frames <span class="op">=</span> mc.run_simulation(env, np.atleast_2d(bo_multifidelity.x_opt), render<span class="op">=</span><span class="va">True</span>)</a>
<a class="sourceLine" id="cb191-2" data-line-number="2">anim<span class="op">=</span>mc.animate_frames(frames, <span class="st">&#39;Best controller with multi-fidelity emulator&#39;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb192"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb192-1" data-line-number="1"><span class="im">from</span> IPython.core.display <span class="im">import</span> HTML</a></code></pre></div>
<div class="sourceCode" id="cb193"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb193-1" data-line-number="1">HTML(anim.to_jshtml())</a></code></pre></div>
<h3 id="best-controller-with-multi-fidelity-emulator">Best Controller with Multi-Fidelity Emulator</h3>
<div class="figure">
<div id="mountain-car-multi-fidelity-figure" class="figure-frame">
<iframe src="../slides/diagrams/uq/mountain_car_multi_fidelity.html" width="800px" height="600px" allowtransparency="true" frameborder="0">
</iframe>
</div>
<div id="mountain-car-multi-fidelity-magnify" class="magnify" onclick="magnifyFigure(&#39;mountain-car-multi-fidelity&#39;)">
<p><img class="img-button" src="/icons/Magnify_Large.svg" style="width:1.5ex"></p>
</div>
<div id="mountain-car-multi-fidelity-caption" class="caption-frame">
<p>Figure: Mountain car learnt with multi-fidelity model. Here 250 observations of the high fidelity simulator and 250 observations of the low fidelity simulator are used to learn the controller.</p>
</div>
</div>
<p>And problem solved! We see how the problem is also solved with 250 observations of the high fidelity simulator and 250 of the low fidelity simulator.</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Stefanos Eleftheriadis, John Bronskill, Hugh Salimbeni, Rich Turner, Zhenwen Dai, Javier Gonzalez, Andreas Damianou, Mark Pullin.</p>
<h2 id="ongoing-code">Ongoing Code</h2>
<ul>
<li><p>Powerful framework but</p></li>
<li><p>Software isn’t there yet.</p></li>
<li><p>Our focus: Gaussian Processes driven by MXNet</p></li>
<li><p>Composition of GPs, Neural Networks, Other Models</p></li>
</ul>
<h2 id="thanks">Thanks!</h2>
<ul>
<li>twitter: @lawrennd</li>
<li>blog: <a href="http://inverseprobability.com/blog.html">http://inverseprobability.com</a></li>
</ul>
<h2 id="references" class="unnumbered">References</h2>
<div id="refs" class="references">
<div id="ref-Alaa:deep2017">
<p>Alaa, Ahmed M., and Mihaela van der Schaar. 2017. “Deep Multi-Task Gaussian Processes for Survival Analysis with Competing Risks.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 2326–34. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6827-deep-multi-task-gaussian-processes-for-survival-analysis-with-competing-risks.pdf" class="uri">http://papers.nips.cc/paper/6827-deep-multi-task-gaussian-processes-for-survival-analysis-with-competing-risks.pdf</a>.</p>
</div>
<div id="ref-Andrade:consistent14">
<p>Andrade-Pacheco, Ricardo, Martin Mubangizi, John Quinn, and Neil D. Lawrence. 2014. “Consistent Mapping of Government Malaria Records Across a Changing Territory Delimitation.” <em>Malaria Journal</em> 13 (Suppl 1). <a href="https://doi.org/10.1186/1475-2875-13-S1-P5" class="uri">https://doi.org/10.1186/1475-2875-13-S1-P5</a>.</p>
</div>
<div id="ref-Alvarez:efficient10">
<p>Álvarez, Mauricio A., David Luengo, Michalis K. Titsias, and Neil D. Lawrence. 2010. “Efficient Multioutput Gaussian Processes Through Variational Inducing Kernels.” In, 9:25–32.</p>
</div>
<div id="ref-Bochner:book59">
<p>Bochner, Salomon. 1959. <em>Lectures on Fourier Integrals</em>. Princeton University Press. <a href="http://books.google.co.uk/books?id=-vU02QewWK8C" class="uri">http://books.google.co.uk/books?id=-vU02QewWK8C</a>.</p>
</div>
<div id="ref-Thang:unifying17">
<p>Bui, Thang D., Josiah Yan, and Richard E. Turner. 2017. “A Unifying Framework for Gaussian Process Pseudo-Point Approximations Using Power Expectation Propagation.” <em>Journal of Machine Learning Research</em> 18 (104): 1–72. <a href="http://jmlr.org/papers/v18/16-603.html" class="uri">http://jmlr.org/papers/v18/16-603.html</a>.</p>
</div>
<div id="ref-Bui:deep16">
<p>Bui, Thang, Daniel Hernandez-Lobato, Jose Hernandez-Lobato, Yingzhen Li, and Richard Turner. 2016. “Deep Gaussian Processes for Regression Using Approximate Expectation Propagation.” In <em>Proceedings of the 33rd International Conference on Machine Learning</em>, edited by Maria Florina Balcan and Kilian Q. Weinberger, 48:1472–81. Proceedings of Machine Learning Research. New York, New York, USA: PMLR. <a href="http://proceedings.mlr.press/v48/bui16.html" class="uri">http://proceedings.mlr.press/v48/bui16.html</a>.</p>
</div>
<div id="ref-Cho:deep09">
<p>Cho, Youngmin, and Lawrence K. Saul. 2009. “Kernel Methods for Deep Learning.” In <em>Advances in Neural Information Processing Systems 22</em>, edited by Y. Bengio, D. Schuurmans, J. D. Lafferty, C. K. I. Williams, and A. Culotta, 342–50. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/3628-kernel-methods-for-deep-learning.pdf" class="uri">http://papers.nips.cc/paper/3628-kernel-methods-for-deep-learning.pdf</a>.</p>
</div>
<div id="ref-Csato:thesis02">
<p>Csató, Lehel. 2002. “Gaussian Processes — Iterative Sparse Approximations.” PhD thesis, Aston University.</p>
</div>
<div id="ref-Csato:sparse02">
<p>Csató, Lehel, and Manfred Opper. 2002. “Sparse on-Line Gaussian Processes.” <em>Neural Computation</em> 14 (3): 641–68.</p>
</div>
<div id="ref-Dai:gpu14">
<p>Dai, Zhenwen, Andreas Damianou, James Hensman, and Neil D. Lawrence. 2014. “Gaussian Process Models with Parallelization and GPU Acceleration.”</p>
</div>
<div id="ref-Damianou:thesis2015">
<p>Damianou, Andreas. 2015. “Deep Gaussian Processes and Variational Propagation of Uncertainty.” PhD thesis, University of Sheffield.</p>
</div>
<div id="ref-Damianou:variational15">
<p>Damianou, Andreas, Michalis K. Titsias, and Neil D. Lawrence. 2016. “Variational Inference for Latent Variables and Uncertain Inputs in Gaussian Processes.” <em>Journal of Machine Learning Research</em> 17.</p>
</div>
<div id="ref-DellaGatta:direct08">
<p>Della Gatta, Giusy, Mukesh Bansal, Alberto Ambesi-Impiombato, Dario Antonini, Caterina Missero, and Diego di Bernardo. 2008. “Direct Targets of the Trp63 Transcription Factor Revealed by a Combination of Gene Expression Profiling and Reverse Engineering.” <em>Genome Research</em> 18 (6). Telethon Institute of Genetics; Medicine, 80131 Naples, Italy.: 939–48. <a href="https://doi.org/10.1101/gr.073601.107" class="uri">https://doi.org/10.1101/gr.073601.107</a>.</p>
</div>
<div id="ref-Dunlop:deep2017">
<p>Dunlop, Matthew M., Mark A. Girolami, Andrew M. Stuart, and Aretha L. Teckentrup. n.d. “How Deep Are Deep Gaussian Processes?” <em>Journal of Machine Learning Research</em> 19 (54): 1–46. <a href="http://jmlr.org/papers/v19/18-015.html" class="uri">http://jmlr.org/papers/v19/18-015.html</a>.</p>
</div>
<div id="ref-Duvenaud:pathologies14">
<p>Duvenaud, David, Oren Rippel, Ryan Adams, and Zoubin Ghahramani. 2014. “Avoiding Pathologies in Very Deep Networks.” In.</p>
</div>
<div id="ref-Gal:distributed14">
<p>Gal, Yarin, Mark van der Wilk, and Carl E. Rasmussen. n.d. “Distributed Variational Inference in Sparse Gaussian Process Regression and Latent Variable Models.” In.</p>
</div>
<div id="ref-Gelman:bayesian13">
<p>Gelman, Andrew, John B. Carlin, Hal S. Stern, and Donald B. Rubin. 2013. <em>Bayesian Data Analysis</em>. 3rd ed. Chapman; Hall.</p>
</div>
<div id="ref-Gething:hmis06">
<p>Gething, Peter W., Abdisalan M. Noor, Priscilla W. Gikandi, Esther A. A. Ogara, Simon I. Hay, Mark S. Nixon, Robert W. Snow, and Peter M. Atkinson. 2006. “Improving Imperfect Data from Health Management Information Systems in Africa Using Space–Time Geostatistics.” <em>PLoS Medicine</em> 3 (6). Public Library of Science. <a href="https://doi.org/10.1371/journal.pmed.0030271" class="uri">https://doi.org/10.1371/journal.pmed.0030271</a>.</p>
</div>
<div id="ref-Havasi:deepgp18">
<p>Havasi, Marton, José Miguel Hernández-Lobato, and Juan José Murillo-Fuentes. 2018. “Inference in Deep Gaussian Processes Using Stochastic Gradient Hamiltonian Monte Carlo.” In <em>Advances in Neural Information Processing Systems 31</em>, edited by S. Bengio, H. Wallach, H. Larochelle, K. Grauman, N. Cesa-Bianchi, and R. Garnett, 7506–16. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/7979-inference-in-deep-gaussian-processes-using-stochastic-gradient-hamiltonian-monte-carlo.pdf" class="uri">http://papers.nips.cc/paper/7979-inference-in-deep-gaussian-processes-using-stochastic-gradient-hamiltonian-monte-carlo.pdf</a>.</p>
</div>
<div id="ref-Hensman:bigdata13">
<p>Hensman, James, Nicoló Fusi, and Neil D. Lawrence. n.d. “Gaussian Processes for Big Data.” In.</p>
</div>
<div id="ref-Hoffman:stochastic12">
<p>Hoffman, Matthew, David M. Blei, Chong Wang, and John Paisley. 2012. “Stochastic Variational Inference.” <em>arXiv Preprint arXiv:1206.7051</em>.</p>
</div>
<div id="ref-Ioffe:batch15">
<p>Ioffe, Sergey, and Christian Szegedy. 2015. “Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift.” In <em>Proceedings of the 32nd International Conference on Machine Learning</em>, edited by Francis Bach and David Blei, 37:448–56. Proceedings of Machine Learning Research. Lille, France: PMLR. <a href="http://proceedings.mlr.press/v37/ioffe15.html" class="uri">http://proceedings.mlr.press/v37/ioffe15.html</a>.</p>
</div>
<div id="ref-Izmailov:subspace19">
<p>Izmailov, Pavel, Wesley J. Maddox, Polina Kirichenko, Timur Garipov, Dmitry P. Vetrov, and Andrew Gordon Wilson. 2019. “Subspace Inference for Bayesian Deep Learning.” <em>CoRR</em> abs/1907.07504. <a href="http://arxiv.org/abs/1907.07504" class="uri">http://arxiv.org/abs/1907.07504</a>.</p>
</div>
<div id="ref-Kalaitzis:simple11">
<p>Kalaitzis, Alfredo A., and Neil D. Lawrence. 2011. “A Simple Approach to Ranking Differentially Expressed Gene Expression Time Courses Through Gaussian Process Regression.” <em>BMC Bioinformatics</em> 12 (180). <a href="https://doi.org/10.1186/1471-2105-12-180" class="uri">https://doi.org/10.1186/1471-2105-12-180</a>.</p>
</div>
<div id="ref-Lawrence:larger07">
<p>Lawrence, Neil D. n.d. “Learning for Larger Datasets with the Gaussian Process Latent Variable Model.” In, 243–50.</p>
</div>
<div id="ref-Lawrence:hgplvm07">
<p>Lawrence, Neil D., and Andrew J. Moore. 2007. “Hierarchical Gaussian Process Latent Variable Models.” In, 481–88.</p>
</div>
<div id="ref-Lazaro:spectrum10">
<p>Lázaro-Gredilla, Miguel, Joaquin Quiñonero-Candela, and Carl Edward Rasmussen. 2010. “Sparse Spectrum Gaussian Processes.” <em>Journal of Machine Learning Research</em> 11: 1865–81.</p>
</div>
<div id="ref-MacKay:bayesian92">
<p>MacKay, David J. C. 1992. “Bayesian Methods for Adaptive Models.” PhD thesis, California Institute of Technology.</p>
</div>
<div id="ref-MacKay:gpintroduction98">
<p>MacKay, David J. C. n.d. “Introduction to Gaussian Processes.” In, 133–66.</p>
</div>
<div id="ref-Mattos:recurrent15">
<p>Mattos, César Lincoln C., Zhenwen Dai, Andreas C. Damianou, Jeremy Forth, Guilherme A. Barreto, and Neil D. Lawrence. 2015. “Recurrent Gaussian Processes.” <em>CoRR</em> abs/1511.06644. <a href="http://arxiv.org/abs/1511.06644" class="uri">http://arxiv.org/abs/1511.06644</a>.</p>
</div>
<div id="ref-McCulloch:neuron43">
<p>McCulloch, Warren S., and Walter Pitts. 1943. “A Logical Calculus of the Ideas Immanent in Nervous Activity.” <em>Bulletin of Mathematical Biophysics</em> 5: 115–33.</p>
</div>
<div id="ref-Mubangizi:malaria14">
<p>Mubangizi, Martin, Ricardo Andrade-Pacheco, Michael Thomas Smith, John Quinn, and Neil D. Lawrence. 2014. “Malaria Surveillance with Multiple Data Sources Using Gaussian Process Models.” In <em>1st International Conference on the Use of Mobile ICT in Africa</em>.</p>
</div>
<div id="ref-Neal:bayesian94">
<p>Neal, Radford M. 1994. “Bayesian Learning for Neural Networks.” PhD thesis, Dept. of Computer Science, University of Toronto.</p>
</div>
<div id="ref-Pearl:causality95">
<p>Pearl, Judea. 1995. “From Bayesian Networks to Causal Networks.” In <em>Probabilistic Reasoning and Bayesian Belief Networks</em>, edited by A. Gammerman, 1–31. Alfred Waller.</p>
</div>
<div id="ref-Perdikaris:multifidelity17">
<p>Perdikaris, P., M. Raissi, A. Damianou, N. D. Lawrence, and G. E. Karniadakis. 2017. “Nonlinear Information Fusion Algorithms for Data-Efficient Multi-Fidelity Modelling.” <em>Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences</em> 473 (2198). The Royal Society. <a href="https://doi.org/10.1098/rspa.2016.0751" class="uri">https://doi.org/10.1098/rspa.2016.0751</a>.</p>
</div>
<div id="ref-Quinonero:unifying05">
<p>Quiñonero Candela, Joaquin, and Carl Edward Rasmussen. 2005. “A Unifying View of Sparse Approximate Gaussian Process Regression.” <em>Journal of Machine Learning Research</em> 6: 1939–59.</p>
</div>
<div id="ref-Ranganath-survival16">
<p>Ranganath, Rajesh, Adler Perotte, Noémie Elhadad, and David Blei. 2016. “Deep Survival Analysis.” In <em>Proceedings of the 1st Machine Learning for Healthcare Conference</em>, edited by Finale Doshi-Velez, Jim Fackler, David Kale, Byron Wallace, and Jenna Wiens, 56:101–14. Proceedings of Machine Learning Research. Children’s Hospital LA, Los Angeles, CA, USA: PMLR. <a href="http://proceedings.mlr.press/v56/Ranganath16.html" class="uri">http://proceedings.mlr.press/v56/Ranganath16.html</a>.</p>
</div>
<div id="ref-Salimbeni:doubly2017">
<p>Salimbeni, Hugh, and Marc Deisenroth. 2017. “Doubly Stochastic Variational Inference for Deep Gaussian Processes.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 4591–4602. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/7045-doubly-stochastic-variational-inference-for-deep-gaussian-processes.pdf" class="uri">http://papers.nips.cc/paper/7045-doubly-stochastic-variational-inference-for-deep-gaussian-processes.pdf</a>.</p>
</div>
<div id="ref-Saul:thesis2016">
<p>Saul, Alan Daniel. 2016. “Gaussian Process Based Approaches for Survival Analysis.” PhD thesis, University of Sheffield.</p>
</div>
<div id="ref-Schulam:counterfactual17">
<p>Schulam, Peter, and Suchi Saria. 2017. “Counterfactual Gaussian Processes for Reliable Decision-Making and What-If Reasoning.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 1696–1706. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6767-counterfactual-gaussian-processes-for-reliable-decision-making-and-what-if-reasoning.pdf" class="uri">http://papers.nips.cc/paper/6767-counterfactual-gaussian-processes-for-reliable-decision-making-and-what-if-reasoning.pdf</a>.</p>
</div>
<div id="ref-Seeger:auto17">
<p>Seeger, Matthias W., Asmus Hetzel, Zhenwen Dai, and Neil D. Lawrence. 2017. “Auto-Differentiating Linear Algebra.” <em>CoRR</em> abs/1710.08717. <a href="http://arxiv.org/abs/1710.08717" class="uri">http://arxiv.org/abs/1710.08717</a>.</p>
</div>
<div id="ref-Seeger:fast03">
<p>Seeger, Matthias, Christopher K. I. Williams, and Neil D. Lawrence. n.d. “Fast Forward Selection to Speed up Sparse Gaussian Process Regression.” In.</p>
</div>
<div id="ref-Smola:sparsegp00">
<p>Smola, Alexander J., and Peter L. Bartlett. n.d. “Sparse Greedy Gaussian Process Regression.” In, 619–25.</p>
</div>
<div id="ref-Snelson:pseudo05">
<p>Snelson, Edward, and Zoubin Ghahramani. n.d. “Sparse Gaussian Processes Using Pseudo-Inputs.” In.</p>
</div>
<div id="ref-Steele:predictive12">
<p>Steele, S, A Bilchik, J Eberhardt, P Kalina, A Nissan, E Johnson, I Avital, and A Stojadinovic. 2012. “Using Machine-Learned Bayesian Belief Networks to Predict Perioperative Risk of Clostridium Difficile Infection Following Colon Surgery.” <em>Interact J Med Res</em> 1 (2): e6. <a href="https://doi.org/10.2196/ijmr.2131" class="uri">https://doi.org/10.2196/ijmr.2131</a>.</p>
</div>
<div id="ref-Taigman:deepface14">
<p>Taigman, Yaniv, Ming Yang, Marc’Aurelio Ranzato, and Lior Wolf. 2014. “DeepFace: Closing the Gap to Human-Level Performance in Face Verification.” In <em>Proceedings of the IEEE Computer Society Conference on Computer Vision and Pattern Recognition</em>. <a href="https://doi.org/10.1109/CVPR.2014.220" class="uri">https://doi.org/10.1109/CVPR.2014.220</a>.</p>
</div>
<div id="ref-Tipping:probpca99">
<p>Tipping, Michael E., and Christopher M. Bishop. 1999. “Probabilistic Principal Component Analysis.” <em>Journal of the Royal Statistical Society, B</em> 6 (3): 611–22. <a href="https://doi.org/doi:10.1111/1467-9868.00196" class="uri">https://doi.org/doi:10.1111/1467-9868.00196</a>.</p>
</div>
<div id="ref-Titsias:variational09">
<p>Titsias, Michalis K. n.d. “Variational Learning of Inducing Variables in Sparse Gaussian Processes.” In, 567–74.</p>
</div>
<div id="ref-Williams:nystrom00">
<p>Williams, Christopher K. I., and Matthias Seeger. n.d. “Using the Nyström Method to Speed up Kernel Machines.” In, 682–88.</p>
</div>
<div id="ref-Anqi:gpspike2017">
<p>Wu, Anqi, Nicholas G Roy, Stephen Keeley, and Jonathan W Pillow. 2017. “Gaussian Process Based Nonlinear Latent Structure Discovery in Multivariate Spike Train Data.” In <em>Advances in Neural Information Processing Systems 30</em>, edited by I. Guyon, U. V. Luxburg, S. Bengio, H. Wallach, R. Fergus, S. Vishwanathan, and R. Garnett, 3499–3508. Curran Associates, Inc. <a href="http://papers.nips.cc/paper/6941-gaussian-process-based-nonlinear-latent-structure-discovery-in-multivariate-spike-train-data.pdf" class="uri">http://papers.nips.cc/paper/6941-gaussian-process-based-nonlinear-latent-structure-discovery-in-multivariate-spike-train-data.pdf</a>.</p>
</div>
</div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In classical statistics we often interpret these parameters, <span class="math inline"><em>β</em></span>, whereas in machine learning we are normally more interested in the result of the prediction, and less in the prediction. Although this is changing with more need for accountability. In honour of this I normally use <span class="math inline"><strong>β</strong></span> when I care about the value of these parameters, and <span class="math inline">$\mappingVector$</span> when I care more about the quality of the prediction.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>


